\input texinfo.tex
@c %**start of header
@setfilename mmux-bash-pointers.info
@settitle MMUX Bash Pointers
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX Bash Pointers

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX Bash Pointers

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-bash-pointers

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_BASH_POINTERS
@set PackagePkgconfigModule             mmux-bash-pointers
@set PackageLibsVar                     @env{MMUX_BASH_POINTERS_LIBS}
@set PackageCflagsVar                   @env{MMUX_BASH_POINTERS_CFLAGS}
@c This is the stem of the library in "libmmux-bash-pointers.so".
@set PackageLibstem                     mmux-bash-pointers
@set PackageApiPrefixLower              mmux_bash_pointers_
@set PackageApiPrefixUpper              MMUX_BASH_POINTERS_

@set PackageHeader                      mmux-bash-pointers.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mbfl{}
@acronym{MBFL}
@end macro
@end ifinfo
@ifnotinfo
@macro mbfl{}
@acronym{mbfl}
@end macro
@end ifnotinfo

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying

This  document  describes  version  @value{VERSION}   of  @value{PACKAGE},  a  package  implementing
additional builtin commands for the @gnu{} Bash shell; to do so it installs a C language library and
a shell script  which is meant to  be sourced in a Bash  session or script.

This package makes raw memory pointers available in shell scripts; it also interfaces some basic
functions from the C language @posix{} standard library.  The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} Lesser General Public License (@lgpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-bash-pointers: (mmux-bash-pointers).  Additional GNU Bash builtins.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* variables::                   Global variables.
* memory::                      Standard memory allocation.
* operations::                  Standard memory operations.
* pointers::                    Memory block accessors and mutators.
* arrays::                      Memory arrays accessors and mutators.
* conversions::                 Converting data to and from memory blocks.
* predicates::                  Type predicates.
* errors::                      Handling errors.

Appendices

* Package License::             GNU Lesser General Public License.
* Documentation License::       GNU Free Documentation License.
* shared library::              Using the shared library.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a package implementing
additional builtin commands for the @gnu{} Bash shell; to do so it installs a C language library and
a shell script which is meant to be sourced in a Bash session or script.

This package makes raw memory pointers available in shell scripts:

@example
source /usr/local/share/bash/libmmux-bash-pointers.bash

declare PTR VALUE

libc_malloc PTR 1024
@{
  pointer-set-sint $PTR 0 123
  pointer-ref-sint VALUE $PTR 0
@}
libc_free $PTR
$VALUE  @result{} 123
@end example

@menu
* overview install::            Installed files.
* overview linking::            Linking code with the library.
@end menu

@c page
@node overview install
@section Installed files


@value{PACKAGE} installs a shell script, a ``shell library'', under @code{$datavar/bash}; for
example:

@center @file{/usr/local/share/bash/libmmux-bash-pointers.bash}

@noindent
to use the builtins, we have to load the shell library using Bash's builtin @code{source}.  A shared
library, actually implementing the builtins, is installed under @code{$libdir}; for example:

@center @file{/usr/local/lib64/libmmux-bash-pointers.so}

@noindent
the shared library is automatically loaded by the shell library.

A C language header file is also installed under @code{$includedir}, for example:

@center @file{/usr/local/include/libmmux-bash-pointers.h}

@noindent
we can write code that links to the shared library to reuse some of its facilities.

@c page

@include overview-linking.texi

@c page
@node variables
@chapter Global variables


The shell library installed by @value{PACKAGE} defines global variables to allow inspection of the
underlying C language platform.

@menu
* variables version::           Version variables.
* variables sizeof::            C language type sizes.
* variables limits::            C language type maximum and minimum values.
* variables errno::             Values of @code{errno}.
@end menu

@c page
@node variables version
@section Version variables


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defvr {Shell Variable} MMUX_BASH_POINTERS_CURRENT
An integer representing the library interface current number.
@end defvr


@defvr {Shell Variable} MMUX_BASH_POINTERS_REVISION
An integer representing the library interface current revision number.
@end defvr


@defvr {Shell Variable} MMUX_BASH_POINTERS_AGE
An integer representing the library interface current age.
@end defvr

@c page
@node variables sizeof
@section C language type sizes


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined; we can test this condition with @code{test -v}; to test if the
underlying platform implements the type @code{signed long long int}, we can do:

@example
if test -v libc_SIZEOF_SLLONG
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarSizeof{NAME,TYPE}
@defvar libc_SIZEOF_\NAME\
Global variable holding the size, measured in bytes, of the C language type @code{\TYPE\}.
@end defvar

@end macro

@MmuxDefineGlobalVarSizeof{POINTER,void *}

@MmuxDefineGlobalVarSizeof{SCHAR, signed char}
@MmuxDefineGlobalVarSizeof{UCHAR, unsigned char}
@MmuxDefineGlobalVarSizeof{SSHORT, signed short int}
@MmuxDefineGlobalVarSizeof{USHORT, unsigned short int}
@MmuxDefineGlobalVarSizeof{SINT, signed int}
@MmuxDefineGlobalVarSizeof{UINT, unsigned int}
@MmuxDefineGlobalVarSizeof{SLONG, signed long int}
@MmuxDefineGlobalVarSizeof{ULONG, unsigned long int}
@MmuxDefineGlobalVarSizeof{SLLONG, signed long long int}
@MmuxDefineGlobalVarSizeof{ULLONG, unsigned long long int}
@MmuxDefineGlobalVarSizeof{FLOAT, float}
@MmuxDefineGlobalVarSizeof{DOUBLE, double}
@MmuxDefineGlobalVarSizeof{LDOUBLE, long double}
@MmuxDefineGlobalVarSizeof{COMPLEX, double complex}

@MmuxDefineGlobalVarSizeof{SINT8, int8_t}
@MmuxDefineGlobalVarSizeof{UINT8, uint8_t}
@MmuxDefineGlobalVarSizeof{SINT16, int16_t}
@MmuxDefineGlobalVarSizeof{UINT16, uint16_t}
@MmuxDefineGlobalVarSizeof{SINT32, int32_t}
@MmuxDefineGlobalVarSizeof{UINT32, uint32_t}
@MmuxDefineGlobalVarSizeof{SINT64, int64_t}
@MmuxDefineGlobalVarSizeof{UINT64, uint64_t}

@MmuxDefineGlobalVarSizeof{SSIZE, ssize_t}
@MmuxDefineGlobalVarSizeof{USIZE, size_t}
@MmuxDefineGlobalVarSizeof{SINTMAX, intmax_t}
@MmuxDefineGlobalVarSizeof{UINTMAX, uintmax_t}
@MmuxDefineGlobalVarSizeof{SINTPTR, intptr_t}
@MmuxDefineGlobalVarSizeof{UINTPTR, uintptr_t}
@MmuxDefineGlobalVarSizeof{PTRDIFF, ptrdiff_t}
@MmuxDefineGlobalVarSizeof{MODE, mode_t}
@MmuxDefineGlobalVarSizeof{OFF, off_t}
@MmuxDefineGlobalVarSizeof{PID, pid_t}
@MmuxDefineGlobalVarSizeof{UID, uid_t}
@MmuxDefineGlobalVarSizeof{GID, gid_t}
@MmuxDefineGlobalVarSizeof{WCHAR, wchar_t}
@MmuxDefineGlobalVarSizeof{WINT, wint_t}

@c page
@node variables limits
@section C language type maximum and minimum values


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined; we can test this condition with @code{test -v}; to test if the
underlying platform implements the type @code{signed long long int}, we can do:

@example
if test -v libc_MAX_SLLONG
then # implemented
else # not implemented
fi
@end example

Notice that the C language type @objtype{double complex} has no maximum or minimum limit.

@macro MmuxDefineGlobalVarLimits{NAME,TYPE}
@defvar libc_MAX_\NAME\
@defvarx libc_MIN_\NAME\
Global variables holding the maximum and minimum values of the C language type @code{\TYPE\}.
@end defvar

@end macro

@MmuxDefineGlobalVarLimits{POINTER,void *}

@MmuxDefineGlobalVarLimits{SCHAR, signed char}
@MmuxDefineGlobalVarLimits{UCHAR, unsigned char}
@MmuxDefineGlobalVarLimits{SSHORT, signed short int}
@MmuxDefineGlobalVarLimits{USHORT, unsigned short int}
@MmuxDefineGlobalVarLimits{SINT, signed int}
@MmuxDefineGlobalVarLimits{UINT, unsigned int}
@MmuxDefineGlobalVarLimits{SLONG, signed long int}
@MmuxDefineGlobalVarLimits{ULONG, unsigned long int}
@MmuxDefineGlobalVarLimits{SLLONG, signed long long int}
@MmuxDefineGlobalVarLimits{ULLONG, unsigned long long int}
@MmuxDefineGlobalVarLimits{FLOAT, float}
@MmuxDefineGlobalVarLimits{DOUBLE, double}
@MmuxDefineGlobalVarLimits{LDOUBLE, long double}
@c @MmuxDefineGlobalVarLimits{COMPLEX, double complex}

@MmuxDefineGlobalVarLimits{SINT8, int8_t}
@MmuxDefineGlobalVarLimits{UINT8, uint8_t}
@MmuxDefineGlobalVarLimits{SINT16, int16_t}
@MmuxDefineGlobalVarLimits{UINT16, uint16_t}
@MmuxDefineGlobalVarLimits{SINT32, int32_t}
@MmuxDefineGlobalVarLimits{UINT32, uint32_t}
@MmuxDefineGlobalVarLimits{SINT64, int64_t}
@MmuxDefineGlobalVarLimits{UINT64, uint64_t}

@MmuxDefineGlobalVarLimits{SSIZE, ssize_t}
@MmuxDefineGlobalVarLimits{USIZE, size_t}
@MmuxDefineGlobalVarLimits{SINTMAX, intmax_t}
@MmuxDefineGlobalVarLimits{UINTMAX, uintmax_t}
@MmuxDefineGlobalVarLimits{SINTPTR, intptr_t}
@MmuxDefineGlobalVarLimits{UINTPTR, uintptr_t}
@MmuxDefineGlobalVarLimits{PTRDIFF, ptrdiff_t}
@MmuxDefineGlobalVarLimits{MODE, mode_t}
@MmuxDefineGlobalVarLimits{OFF, off_t}
@MmuxDefineGlobalVarLimits{PID, pid_t}
@MmuxDefineGlobalVarLimits{UID, uid_t}
@MmuxDefineGlobalVarLimits{GID, gid_t}
@MmuxDefineGlobalVarLimits{WCHAR, wchar_t}
@MmuxDefineGlobalVarLimits{WINT, wint_t}

@c page
@node variables errno
@section Values of @code{errno}


If a C language constant referenced by one of the following variables is undefined: the
corresponding Bash variable is undefined; we can test this condition with @code{test -v}; to test if
the underlying platform implements the constant @code{ENOMEM}, we can do:

@example
if test -v libc_ENOMEM
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarErrno{NAME}
@defvar libc_\NAME\
Global variable holding the value of the C language constant @code{\NAME\}.
@end defvar

@end macro

@MmuxDefineGlobalVarErrno{EPERM}
@MmuxDefineGlobalVarErrno{ENOENT}
@MmuxDefineGlobalVarErrno{ESRCH}
@MmuxDefineGlobalVarErrno{EINTR}
@MmuxDefineGlobalVarErrno{EIO}
@MmuxDefineGlobalVarErrno{ENXIO}
@MmuxDefineGlobalVarErrno{E2BIG}
@MmuxDefineGlobalVarErrno{ENOEXEC}
@MmuxDefineGlobalVarErrno{EBADF}
@MmuxDefineGlobalVarErrno{ECHILD}
@MmuxDefineGlobalVarErrno{EAGAIN}
@MmuxDefineGlobalVarErrno{ENOMEM}
@MmuxDefineGlobalVarErrno{EACCES}
@MmuxDefineGlobalVarErrno{EFAULT}
@MmuxDefineGlobalVarErrno{ENOTBLK}
@MmuxDefineGlobalVarErrno{EBUSY}
@MmuxDefineGlobalVarErrno{EEXIST}
@MmuxDefineGlobalVarErrno{EXDEV}
@MmuxDefineGlobalVarErrno{ENODEV}
@MmuxDefineGlobalVarErrno{ENOTDIR}
@MmuxDefineGlobalVarErrno{EISDIR}
@MmuxDefineGlobalVarErrno{EINVAL}
@MmuxDefineGlobalVarErrno{ENFILE}
@MmuxDefineGlobalVarErrno{EMFILE}
@MmuxDefineGlobalVarErrno{ENOTTY}
@MmuxDefineGlobalVarErrno{ETXTBSY}
@MmuxDefineGlobalVarErrno{EFBIG}
@MmuxDefineGlobalVarErrno{ENOSPC}
@MmuxDefineGlobalVarErrno{ESPIPE}
@MmuxDefineGlobalVarErrno{EROFS}
@MmuxDefineGlobalVarErrno{EMLINK}
@MmuxDefineGlobalVarErrno{EPIPE}
@MmuxDefineGlobalVarErrno{EDOM}
@MmuxDefineGlobalVarErrno{ERANGE}
@MmuxDefineGlobalVarErrno{EDEADLK}
@MmuxDefineGlobalVarErrno{ENAMETOOLONG}
@MmuxDefineGlobalVarErrno{ENOLCK}
@MmuxDefineGlobalVarErrno{ENOSYS}
@MmuxDefineGlobalVarErrno{ENOTEMPTY}
@MmuxDefineGlobalVarErrno{ELOOP}
@MmuxDefineGlobalVarErrno{EWOULDBLOCK}
@MmuxDefineGlobalVarErrno{ENOMSG}
@MmuxDefineGlobalVarErrno{EIDRM}
@MmuxDefineGlobalVarErrno{ECHRNG}
@MmuxDefineGlobalVarErrno{EL2NSYNC}
@MmuxDefineGlobalVarErrno{EL3HLT}
@MmuxDefineGlobalVarErrno{EL3RST}
@MmuxDefineGlobalVarErrno{ELNRNG}
@MmuxDefineGlobalVarErrno{EUNATCH}
@MmuxDefineGlobalVarErrno{ENOCSI}
@MmuxDefineGlobalVarErrno{EL2HLT}
@MmuxDefineGlobalVarErrno{EBADE}
@MmuxDefineGlobalVarErrno{EBADR}
@MmuxDefineGlobalVarErrno{EXFULL}
@MmuxDefineGlobalVarErrno{ENOANO}
@MmuxDefineGlobalVarErrno{EBADRQC}
@MmuxDefineGlobalVarErrno{EBADSLT}
@MmuxDefineGlobalVarErrno{EDEADLOCK}
@MmuxDefineGlobalVarErrno{EBFONT}
@MmuxDefineGlobalVarErrno{ENOSTR}
@MmuxDefineGlobalVarErrno{ENODATA}
@MmuxDefineGlobalVarErrno{ETIME}
@MmuxDefineGlobalVarErrno{ENOSR}
@MmuxDefineGlobalVarErrno{ENONET}
@MmuxDefineGlobalVarErrno{ENOPKG}
@MmuxDefineGlobalVarErrno{EREMOTE}
@MmuxDefineGlobalVarErrno{ENOLINK}
@MmuxDefineGlobalVarErrno{EADV}
@MmuxDefineGlobalVarErrno{ESRMNT}
@MmuxDefineGlobalVarErrno{ECOMM}
@MmuxDefineGlobalVarErrno{EPROTO}
@MmuxDefineGlobalVarErrno{EMULTIHOP}
@MmuxDefineGlobalVarErrno{EDOTDOT}
@MmuxDefineGlobalVarErrno{EBADMSG}
@MmuxDefineGlobalVarErrno{EOVERFLOW}
@MmuxDefineGlobalVarErrno{ENOTUNIQ}
@MmuxDefineGlobalVarErrno{EBADFD}
@MmuxDefineGlobalVarErrno{EREMCHG}
@MmuxDefineGlobalVarErrno{ELIBACC}
@MmuxDefineGlobalVarErrno{ELIBBAD}
@MmuxDefineGlobalVarErrno{ELIBSCN}
@MmuxDefineGlobalVarErrno{ELIBMAX}
@MmuxDefineGlobalVarErrno{ELIBEXEC}
@MmuxDefineGlobalVarErrno{EILSEQ}
@MmuxDefineGlobalVarErrno{ERESTART}
@MmuxDefineGlobalVarErrno{ESTRPIPE}
@MmuxDefineGlobalVarErrno{EUSERS}
@MmuxDefineGlobalVarErrno{ENOTSOCK}
@MmuxDefineGlobalVarErrno{EDESTADDRREQ}
@MmuxDefineGlobalVarErrno{EMSGSIZE}
@MmuxDefineGlobalVarErrno{EPROTOTYPE}
@MmuxDefineGlobalVarErrno{ENOPROTOOPT}
@MmuxDefineGlobalVarErrno{EPROTONOSUPPORT}
@MmuxDefineGlobalVarErrno{ESOCKTNOSUPPORT}
@MmuxDefineGlobalVarErrno{EOPNOTSUPP}
@MmuxDefineGlobalVarErrno{EPFNOSUPPORT}
@MmuxDefineGlobalVarErrno{EAFNOSUPPORT}
@MmuxDefineGlobalVarErrno{EADDRINUSE}
@MmuxDefineGlobalVarErrno{EADDRNOTAVAIL}
@MmuxDefineGlobalVarErrno{ENETDOWN}
@MmuxDefineGlobalVarErrno{ENETUNREACH}
@MmuxDefineGlobalVarErrno{ENETRESET}
@MmuxDefineGlobalVarErrno{ECONNABORTED}
@MmuxDefineGlobalVarErrno{ECONNRESET}
@MmuxDefineGlobalVarErrno{ENOBUFS}
@MmuxDefineGlobalVarErrno{EISCONN}
@MmuxDefineGlobalVarErrno{ENOTCONN}
@MmuxDefineGlobalVarErrno{ESHUTDOWN}
@MmuxDefineGlobalVarErrno{ETOOMANYREFS}
@MmuxDefineGlobalVarErrno{ETIMEDOUT}
@MmuxDefineGlobalVarErrno{ECONNREFUSED}
@MmuxDefineGlobalVarErrno{EHOSTDOWN}
@MmuxDefineGlobalVarErrno{EHOSTUNREACH}
@MmuxDefineGlobalVarErrno{EALREADY}
@MmuxDefineGlobalVarErrno{EINPROGRESS}
@MmuxDefineGlobalVarErrno{ESTALE}
@MmuxDefineGlobalVarErrno{EUCLEAN}
@MmuxDefineGlobalVarErrno{ENOTNAM}
@MmuxDefineGlobalVarErrno{ENAVAIL}
@MmuxDefineGlobalVarErrno{EISNAM}
@MmuxDefineGlobalVarErrno{EREMOTEIO}
@MmuxDefineGlobalVarErrno{EDQUOT}
@MmuxDefineGlobalVarErrno{ENOMEDIUM}
@MmuxDefineGlobalVarErrno{EMEDIUMTYPE}
@MmuxDefineGlobalVarErrno{ECANCELED}
@MmuxDefineGlobalVarErrno{ENOKEY}
@MmuxDefineGlobalVarErrno{EKEYEXPIRED}
@MmuxDefineGlobalVarErrno{EKEYREVOKED}
@MmuxDefineGlobalVarErrno{EKEYREJECTED}
@MmuxDefineGlobalVarErrno{EOWNERDEAD}
@MmuxDefineGlobalVarErrno{ENOTRECOVERABLE}

@c page
@node memory
@chapter Standard memory allocation


Basically, to allocate new memory we should do:

@example
declare PTR

if libc_malloc PTR 123
then exit 1
fi
@{
  # do something
@}
libc_free $PTR
@end example

@noindent
we must remember that if we execute code in a subshell: the pointers will not be valid across
shells; so the following will not work:

@example
declare PTR

$(libc_malloc PTR 123)
libc_free $PTR
@end example

@noindent
because @func{libc_malloc} allocates memory in a subshell.


@deffn Builtin libc_malloc @var{PTRVAR} @var{SIZE}
Allocate a memory block using the standard @cfunc{malloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing the @code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{SIZE} must be the string representation of an exact, positive, integer, itself
representing the requested number of bytes in the newly allocated block; it must fit the C language
type @objtype{size_t}.
@end deffn


@deffn Builtin libc_calloc @var{PTRVAR} @var{ITEM_COUNT} @var{ITEM_SIZE}
Allocate a memory block using the standard @cfunc{calloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to an exact integer representing the
@code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{ITEM_COUNT} must be the string representation of an exact, positive, integer,
itself representing the number of items the memory block has to contain; it must fit the C language
type @objtype{size_t}.

The argument @var{ITEM_SIZE} must be the string representation of an exact, positive, integer, itself
representing the size of each item the memory block has to contain; it must fit the C language type
@objtype{size_t}.
@end deffn


@deffn Builtin libc_realloc @var{PTRVAR} @var{OLDPTR} @var{NEWSIZE}
Reallocate a memory block using the standard @cfunc{realloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to an exact integer representing the
@code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{OLDPTR} must be the string representation of the old memory pointer.

The argument @var{SIZE} must be the string representation of an exact, positive, integer, itself
representing the newly requested number of bytes in the newly allocated block; it must fit the C
language type @objtype{size_t}.
@end deffn


@deffn Builtin libc_free @var{PTR}
Release a previously allocated memory block using the standard @cfunc{free} function; if successful
return true, otherwise return false and set the shell variable @code{ERRNO} to an exact integer
representing the @code{errno} error code.

The argument @var{PTR} must be the string representation of a memory pointer referencing a
previously allocated block.

Notice that this builtin can fail if the argument @var{PTR} is not a valid pointer string
representation; in this case the error code is @samp{EINVAL}.
@end deffn

@c page
@node operations
@chapter Standard memory operations


The following builtins can fail if one of the arguments @var{PTR} is not a valid pointer string
representation; in this case the @code{ERRNO} error code is @samp{EINVAL}.


@deffn Builtin libc_memset @var{PTR} @var{BYTE} @var{SIZE}
Interface to the standard C language function @cfunc{memset}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer referencing a previously
allocated memory block.

The argument @var{BYTE} must be the string representation of an exact, positive, integer itself
representing the value to which memory bytes must be set; it must fit an unsigned 8-bit integer.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to set to @var{BYTE}; it must fit the C language type
@objtype{size_t}.

@example
declare PTR SIZE=123

libc_malloc PTR $SIZE
libc_memset $PTR 1 $SIZE
@end example
@end deffn


@deffn Builtin libc_memcpy @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Interface to the standard C language function @cfunc{memcpy}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the destination of the copy operation.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare PTR_FROM PTR_TO SIZE=123

libc_malloc PTR_FROM $SIZE
libc_malloc PTR_TO   $SIZE

libc_memcpy $PTR_TO $PTR_FROM $SIZE
@end example
@end deffn


@deffn Builtin libc_memmove @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Interface to the standard C language function @cfunc{memmove}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the destination of the copy operation.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy.

@example
declare PTR_FROM PTR_TO SIZE=123

libc_malloc PTR_FROM $SIZE
libc_malloc PTR_TO   $SIZE

libc_memmove $PTR_TO $PTR_FROM $SIZE
@end example
@end deffn

@c page
@node pointers
@chapter Memory block accessors and mutators


If we allocate memory using the standard C library functions, we can poke and peek values in the
memory blocks:

@example
declare PTR VALUE

libc_malloc PTR 1024
@{
  pointer-set-double $PTR 0 1.23
  pointer-ref-double VALUE $PTR 0
@}
libc_free $PTR
@end example

For all the following builtins, the argument:

@table @var
@item POINTER
must be the string representation of a memory pointer referencing a previously allocated block;

@item OFFSET
must be the string representation of an exact, non--negative integer, compatible with the C language
type @code{size_t}, itself representing an offset from @var{POINTER} @strong{measured in bytes};

@item VALUE
must be the string representation of a number, compatible with a C language type of the specific
mutator: such number is stored by the mutators at @var{OFFSET} from @var{POINTER};

@item VALUEVAR
must be a string representing the name of a shell variable: it is used by the accessors to store the
value extracted at @var{OFFSET} from @var{POINTER}.
@end table

For all the following builtins: if the operation is successful, the return value is true; otherwise
the return value is false and the shell variable @code{ERRNO} is set to the string representation of
an exact integer, itself representing an @code{errno} error code.


@macro MmuxDefineAccessorMutator{STEM,TYPE}
@deffn {Builtin Mutator} pointer-set-\STEM\ @var{POINTER} @var{OFFSET} @var{VALUE}
@deffnx {Builtin Accessor} pointer-ref-\STEM\ @var{VALUEVAR} @var{POINTER} @var{OFFSET}
Accessor and mutator for memory blocks operating on the C language type @code{\TYPE\}.
@end deffn

@end macro

@MmuxDefineAccessorMutator{pointer,void *}

@MmuxDefineAccessorMutator{schar,signed char}
@MmuxDefineAccessorMutator{uchar,unsigned char}
@MmuxDefineAccessorMutator{sint,signed int}
@MmuxDefineAccessorMutator{uint,unsigned int}
@MmuxDefineAccessorMutator{sshort,signed short int}
@MmuxDefineAccessorMutator{ushort,unsigned short int}
@MmuxDefineAccessorMutator{slong,signed long}
@MmuxDefineAccessorMutator{ulong,unsigned long}
@MmuxDefineAccessorMutator{sllong,signed long long}
@MmuxDefineAccessorMutator{ullong,unsigned long long}
@MmuxDefineAccessorMutator{float,float}
@MmuxDefineAccessorMutator{double,double}
@MmuxDefineAccessorMutator{ldouble,long double}
@MmuxDefineAccessorMutator{complex,double complex}

@MmuxDefineAccessorMutator{sint8,int8_t}
@MmuxDefineAccessorMutator{uint8,uint8_t}
@MmuxDefineAccessorMutator{sint16,int16_t}
@MmuxDefineAccessorMutator{uint16,uint16_t}
@MmuxDefineAccessorMutator{sint32,int32_t}
@MmuxDefineAccessorMutator{uint32,uint32_t}
@MmuxDefineAccessorMutator{sint64,int64_t}
@MmuxDefineAccessorMutator{uint64,uint64_t}

@MmuxDefineAccessorMutator{ssize,ssize_t}
@MmuxDefineAccessorMutator{usize,size_t}
@MmuxDefineAccessorMutator{sintmax, intmax_t}
@MmuxDefineAccessorMutator{uintmax, uintmax_t}
@MmuxDefineAccessorMutator{sintptr, intptr_t}
@MmuxDefineAccessorMutator{uintptr, uintptr_t}
@MmuxDefineAccessorMutator{mode, mode_t}
@MmuxDefineAccessorMutator{off, off_t}
@MmuxDefineAccessorMutator{pid, pid_t}
@MmuxDefineAccessorMutator{uid, uid_t}
@MmuxDefineAccessorMutator{gid, gid_t}

@c page
@node arrays
@chapter Memory arrays accessors and mutators


If we allocate memory using the standard C library functions, we can poke and peek values in the
memory blocks, handling them as arrays of a specified C type:

@example
declare PTR VALUE

libc_malloc PTR $(( 55 * libc_SIZEOF_ULONG ))
@{
  array-set-ulong $PTR 0 1234567890
  array-ref-ulong VALUE $PTR 0
@}
libc_free $PTR
@end example

For all the following builtins, the argument:

@table @var
@item ARRAY
must be the string representation of a memory pointer referencing a previously allocated block; the
block is to be interpreted as an array of a specified C type;

@item INDEX
must be the string representation of an exact, non--negative integer, compatible with the C language
type @code{size_t}, itself representing an index in @var{ARRAY};

@item VALUE
must be the string representation of a number, compatible with a C language type of the specific
mutator: it is stored by the mutators at @var{INDEX} in @var{ARRAY};

@item VALUEVAR
must be a string representing the name of a shell variable: it is used by the accessors to store the
value extracted at @var{INDEX} from @var{ARRAY}.
@end table

For all the following builtins: if the operation is successful, the return value is true; otherwise
the return value is false and the shell variable @code{ERRNO} is set to the string representation of
an exact integer, itself representing an @code{errno} error code.


@macro MmuxDefineArrayAccessorMutator{STEM,TYPE}
@deffn {Builtin Mutator} array-set-\STEM\ @var{ARRAY} @var{INDEX} @var{VALUE}
@deffnx {Builtin Accessor} array-ref-\STEM\ @var{VALUEVAR} @var{ARRAY} @var{INDEX}
Accessor and mutator for memory blocks operating on the C language type @code{\TYPE\}.
@end deffn

@end macro

@MmuxDefineArrayAccessorMutator{pointer,void *}

@MmuxDefineArrayAccessorMutator{schar,signed char}
@MmuxDefineArrayAccessorMutator{uchar,unsigned char}
@MmuxDefineArrayAccessorMutator{sshort,signed short int}
@MmuxDefineArrayAccessorMutator{ushort,unsigned short int}
@MmuxDefineArrayAccessorMutator{sint,signed int}
@MmuxDefineArrayAccessorMutator{uint,unsigned int}
@MmuxDefineArrayAccessorMutator{slong,signed long}
@MmuxDefineArrayAccessorMutator{ulong,unsigned long}
@MmuxDefineArrayAccessorMutator{sllong,signed long long}
@MmuxDefineArrayAccessorMutator{ullong,unsigned long long}
@MmuxDefineArrayAccessorMutator{float,float}
@MmuxDefineArrayAccessorMutator{double,double}
@MmuxDefineArrayAccessorMutator{ldouble,long double}
@MmuxDefineArrayAccessorMutator{complex,double complex}

@MmuxDefineArrayAccessorMutator{sint8,int8_t}
@MmuxDefineArrayAccessorMutator{uint8,uint8_t}
@MmuxDefineArrayAccessorMutator{sint16,int16_t}
@MmuxDefineArrayAccessorMutator{uint16,uint16_t}
@MmuxDefineArrayAccessorMutator{sint32,int32_t}
@MmuxDefineArrayAccessorMutator{uint32,uint32_t}
@MmuxDefineArrayAccessorMutator{sint64,int64_t}
@MmuxDefineArrayAccessorMutator{uint64,uint64_t}

@MmuxDefineArrayAccessorMutator{ssize,ssize_t}
@MmuxDefineArrayAccessorMutator{usize,size_t}
@MmuxDefineArrayAccessorMutator{sintmax, intmax_t}
@MmuxDefineArrayAccessorMutator{uintmax, uintmax_t}
@MmuxDefineArrayAccessorMutator{sintptr, intptr_t}
@MmuxDefineArrayAccessorMutator{uintptr, uintptr_t}
@MmuxDefineArrayAccessorMutator{mode, mode_t}
@MmuxDefineArrayAccessorMutator{off, off_t}
@MmuxDefineArrayAccessorMutator{pid, pid_t}
@MmuxDefineArrayAccessorMutator{uid, uid_t}
@MmuxDefineArrayAccessorMutator{gid, gid_t}

@c page
@node conversions
@chapter Converting data to and from memory blocks


@menu
* conversions arrays::          Converting data to and from index arrays.
* conversions strings::         Converting data to and from strings.
@end menu

@c page
@node conversions arrays
@section Converting data to and from index arrays


@defun mmux-bash-pointers-array-from-memory @var{ARRY_TO} @var{PTR_FROM} @var{SIZE}
Copy byte by byte data from a memory block into a Bash index array.

The argument @var{ARRY_TO} must be a string representing the name of a Bash index array; this
function stores in this array the bytes from the memory block, starting from index zero.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a ARRY

if ! libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-array-from-memory ARRY $POINTER $SIZE
@end example
@end defun


@defun mmux-bash-pointers-memory-from-array @var{PTR_TO} @var{ARRY_FROM} @var{SIZE}
Copy byte by byte data from a Bash index array into a memory block.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the target of the copy operation.

The argument @var{ARRY_FROM} must be a string representing the name of a Bash index array; this
function reads from this array the bytes to store in the memory block, starting from index zero.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a ARRY=(1 2 3 4 5)

if ! libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-memory-from-array $POINTER ARRY $SIZE
@end example
@end defun

@c page
@node conversions strings
@section Converting data to and from strings


@defun mmux-bash-pointers-string-from-memory @var{STRINGVAR_TO} @var{PTR_FROM} @var{SIZE}
Copy byte by byte data from a memory block into a Bash string.

The argument @var{STRINGVAR_TO} must be a string representing a Bash variable name; this function
stores in this variable a string built with the bytes from the memory block, starting from index
zero.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare STRING

if ! libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-string-from-memory STRING $POINTER $SIZE
@end example
@end defun


@defun mmux-bash-pointers-memory-from-string @var{PTR_TO} @var{STRING_FROM} @var{SIZE}
Copy byte by byte data from a Bash string into a memory block.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the target of the copy operation.

The argument @var{STRING_FROM} must be a string; this function reads from this strings the bytes to
store in the memory block, starting from index zero.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a STRING="12345"

if ! libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-memory-from-string $POINTER $STRING $SIZE
@end example
@end defun

@c page
@node predicates
@chapter Type predicates


@macro MmuxDefineTypePredicateBuiltin{STEM}
@deffn Builtin libc_\STEM\_p @var{STRING_REP}
Return true if @var{STRING_REP} is a valid string representation for the C language type; otherwise
return false.
@end deffn

@end macro

@MmuxDefineTypePredicateBuiltin{pointer}

@MmuxDefineTypePredicateBuiltin{schar}
@MmuxDefineTypePredicateBuiltin{uchar}
@MmuxDefineTypePredicateBuiltin{sshort}
@MmuxDefineTypePredicateBuiltin{ushort}
@MmuxDefineTypePredicateBuiltin{sint}
@MmuxDefineTypePredicateBuiltin{uint}
@MmuxDefineTypePredicateBuiltin{slong}
@MmuxDefineTypePredicateBuiltin{ulong}
@MmuxDefineTypePredicateBuiltin{sllong}
@MmuxDefineTypePredicateBuiltin{ullong}
@MmuxDefineTypePredicateBuiltin{float}
@MmuxDefineTypePredicateBuiltin{double}
@MmuxDefineTypePredicateBuiltin{ldouble}
@MmuxDefineTypePredicateBuiltin{complex}

@MmuxDefineTypePredicateBuiltin{sint8}
@MmuxDefineTypePredicateBuiltin{uint8}
@MmuxDefineTypePredicateBuiltin{sint16}
@MmuxDefineTypePredicateBuiltin{uint16}
@MmuxDefineTypePredicateBuiltin{sint32}
@MmuxDefineTypePredicateBuiltin{uint32}
@MmuxDefineTypePredicateBuiltin{sint64}
@MmuxDefineTypePredicateBuiltin{uint64}

@MmuxDefineTypePredicateBuiltin{ssize}
@MmuxDefineTypePredicateBuiltin{usize}
@MmuxDefineTypePredicateBuiltin{sintmax}
@MmuxDefineTypePredicateBuiltin{uintmax}
@MmuxDefineTypePredicateBuiltin{sintptr}
@MmuxDefineTypePredicateBuiltin{uintptr}
@MmuxDefineTypePredicateBuiltin{mode}
@MmuxDefineTypePredicateBuiltin{off}
@MmuxDefineTypePredicateBuiltin{pid}
@MmuxDefineTypePredicateBuiltin{uid}
@MmuxDefineTypePredicateBuiltin{gid}
@MmuxDefineTypePredicateBuiltin{wchar}
@MmuxDefineTypePredicateBuiltin{wint}

@c page
@node errors
@chapter Handling errors


@defvr {Shell Variable} ERRNO
If an error occurs in the call to a builtin that interfaces a Standard C Library function: the
builtin will set the shell variable @env{ERRNO} to the string representation of an exact integer,
itself representing a standard @code{errno} code.

@example
declare PTR ERRNO=0 SYM

libc_malloc PTR 'ciao'
mmux-bash-pointers-errno-to-string SYM $ERRNO
$SYM    @result{} EINVAL
@end example
@end defvr


@deffn Builtin libc_strerror @var{MSGVAR} @var{ERRNUM}
Store in @var{MSGVAR} the error message corresponding to @var{ERRNUM}, which must be the string
representation of an exact integer, itself representing a valid value for @code{errno}; @var{ERRNUM}
must fit the C language type @code{int}.

@example
declare MSG

if test -v libc_EINVAL
then libc_strerror MSG $libc_EINVAL
else MSG='EINVAL undefined'
fi

"$MSG"  @result{} Invalid argument
@end example
@end deffn


@defun mmux-bash-pointers-errno-to-string @var{SYMVAR} @var{ERRNUM}
Store in @var{SYMVAR} a string representation of the @code{errno} code @var{ERRNUM}.  When
successful return true, otherwise return false.

@example
declare SYM

mmux-bash-pointers-errno-to-string SYM $libc_ENOMEM
"$SYM"  @result{} ENOMEM
@end example
@end defun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include lgpl-3.0.texi
@include fdl-1.3.texi

@c page
@node shared library
@appendix Using the shared library


@value{PACKAGE} installs a shared library:

@center @file{libmmux-bash-pointers.so}

@noindent
and a C language header:

@center @file{libmmux-bash-pointers.h}

@noindent
we can write code that links to the shared library to reuse some of its facilities.  @ref{overview
linking} for details.

@menu
* shared library config::       How to configure a package to link the shared library.
* shared library version::      Version functions.
* shared library typedefs::     Type definitions.
* shared library sizeof::       Type size measured in bytes.
* shared library predicates::   Type predicates for string representations.
* shared library maximum::      Type representations of maximum values.
* shared library minimum::      Type representations of minimum values.
* shared library parsers::      Parsing string representations of C language types.
* shared library sprinters::    Printing string representations of C language types.
@end menu

@c page
@node shared library config
@appendixsec How to configure a package to link the shared library


It happens that some rare platform may not implement the C language types @code{long long} and
@code{long double}.  When writing a package that interfaces with the shared library, we must define
preprocessor symbols to specify if a type is implemented:

@example
#define HAVE_LONG_LONG_INT              1
#define HAVE_UNSIGNED_LONG_LONG         1
#define HAVE_LONG_DOUBLE                1
@end example

@noindent
when using the @gnu{} Autotools, we can put the following code in @file{configure.ac}:

@example
AC_TYPE_LONG_LONG_INT
AC_TYPE_UNSIGNED_LONG_LONG_INT
AC_TYPE_LONG_DOUBLE
@end example

@c page
@node shared library version
@appendixsec Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmux_bash_pointers_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node shared library typedefs
@appendixsec Type definitions


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{float}, type stem
@cindex @code{double}, type stem
@cindex @code{ldouble}, type stem
@cindex @code{complex}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem


The following type definitions just alias the corresponding standard C language type; the type name
is composed from a ``stem'': a single word representing the name of the type.  Such uniform names
are useful when using preprocessor macros to generate code.

@macro MmuxDefineCAliasTypedef{STEM,TYPE}
@deftp {Typedef} mmux_libc_\STEM\_t
Type definition aliasing the standard C language type @code{\TYPE\}.
@end deftp

@end macro


@MmuxDefineCAliasTypedef{pointer,void *}

@MmuxDefineCAliasTypedef{schar,signed char}
@MmuxDefineCAliasTypedef{uchar,unsigned char}
@MmuxDefineCAliasTypedef{sshort,signed short int}
@MmuxDefineCAliasTypedef{ushort,unsigned short int}
@MmuxDefineCAliasTypedef{sint,signed int}
@MmuxDefineCAliasTypedef{uint,unsigned int}
@MmuxDefineCAliasTypedef{slong,signed long}
@MmuxDefineCAliasTypedef{ulong,unsigned long}
@MmuxDefineCAliasTypedef{sllong,signed long long}
@MmuxDefineCAliasTypedef{ullong,unsigned long long}
@MmuxDefineCAliasTypedef{float,float}
@MmuxDefineCAliasTypedef{double,double}
@MmuxDefineCAliasTypedef{ldouble,long double}
@MmuxDefineCAliasTypedef{complex,double complex}

@MmuxDefineCAliasTypedef{sint8,int8_t}
@MmuxDefineCAliasTypedef{uint8,uint8_t}
@MmuxDefineCAliasTypedef{sint16,int16_t}
@MmuxDefineCAliasTypedef{uint16,uint16_t}
@MmuxDefineCAliasTypedef{sint32,int32_t}
@MmuxDefineCAliasTypedef{uint32,uint32_t}
@MmuxDefineCAliasTypedef{sint64,int64_t}
@MmuxDefineCAliasTypedef{uint64,uint64_t}

@MmuxDefineCAliasTypedef{ssize,ssize_t}
@MmuxDefineCAliasTypedef{usize,size_t}
@MmuxDefineCAliasTypedef{sintmax, intmax_t}
@MmuxDefineCAliasTypedef{uintmax, uintmax_t}
@MmuxDefineCAliasTypedef{sintptr, intptr_t}
@MmuxDefineCAliasTypedef{uintptr, uintptr_t}
@MmuxDefineCAliasTypedef{mode, mode_t}
@MmuxDefineCAliasTypedef{off, off_t}
@MmuxDefineCAliasTypedef{pid, pid_t}
@MmuxDefineCAliasTypedef{uid, uid_t}
@MmuxDefineCAliasTypedef{gid, gid_t}
@MmuxDefineCAliasTypedef{wchar, wchar_t}
@MmuxDefineCAliasTypedef{wint, wint_t}

@c page
@node shared library sizeof
@appendixsec Type size measured in bytes


@macro MmuxDefineCFunctionSizeof{STEM}
@deftypefun int mmux_bash_pointers_sizeof_\STEM\ (void)
Return a positive integer representing the size in bytes of the C language standard type
@objtype{mmux_libc_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSizeof{pointer}

@MmuxDefineCFunctionSizeof{schar}
@MmuxDefineCFunctionSizeof{uchar}
@MmuxDefineCFunctionSizeof{sshort}
@MmuxDefineCFunctionSizeof{ushort}
@MmuxDefineCFunctionSizeof{sint}
@MmuxDefineCFunctionSizeof{uint}
@MmuxDefineCFunctionSizeof{slong}
@MmuxDefineCFunctionSizeof{ulong}
@MmuxDefineCFunctionSizeof{sllong}
@MmuxDefineCFunctionSizeof{ullong}
@MmuxDefineCFunctionSizeof{float}
@MmuxDefineCFunctionSizeof{double}
@MmuxDefineCFunctionSizeof{ldouble}
@MmuxDefineCFunctionSizeof{complex}

@MmuxDefineCFunctionSizeof{sint8}
@MmuxDefineCFunctionSizeof{uint8}
@MmuxDefineCFunctionSizeof{sint16}
@MmuxDefineCFunctionSizeof{uint16}
@MmuxDefineCFunctionSizeof{sint32}
@MmuxDefineCFunctionSizeof{uint32}
@MmuxDefineCFunctionSizeof{sint64}
@MmuxDefineCFunctionSizeof{uint64}

@MmuxDefineCFunctionSizeof{ssize}
@MmuxDefineCFunctionSizeof{usize}
@MmuxDefineCFunctionSizeof{sintmax}
@MmuxDefineCFunctionSizeof{uintmax}
@MmuxDefineCFunctionSizeof{sintptr}
@MmuxDefineCFunctionSizeof{uintptr}
@MmuxDefineCFunctionSizeof{mode}
@MmuxDefineCFunctionSizeof{off}
@MmuxDefineCFunctionSizeof{pid}
@MmuxDefineCFunctionSizeof{uid}
@MmuxDefineCFunctionSizeof{gid}
@MmuxDefineCFunctionSizeof{wchar}
@MmuxDefineCFunctionSizeof{wint}

@c page
@node shared library predicates
@appendixsec Type predicates for string representations


@macro MmuxDefineCFunctionPredicate{STEM}
@deftypefun bool mmux_bash_pointers_string_\STEM\_p (char const * @var{str})
Return @ctrue{} if @var{str} references the string representation, in @asciiz{} format, of a
value of type @objtype{mmux_libc_\STEM\_t}; otherwise return @cfalse{}.
@end deftypefun

@end macro


@MmuxDefineCFunctionPredicate{pointer}

@MmuxDefineCFunctionPredicate{schar}
@MmuxDefineCFunctionPredicate{uchar}
@MmuxDefineCFunctionPredicate{sshort}
@MmuxDefineCFunctionPredicate{ushort}
@MmuxDefineCFunctionPredicate{sint}
@MmuxDefineCFunctionPredicate{uint}
@MmuxDefineCFunctionPredicate{slong}
@MmuxDefineCFunctionPredicate{ulong}
@MmuxDefineCFunctionPredicate{sllong}
@MmuxDefineCFunctionPredicate{ullong}
@MmuxDefineCFunctionPredicate{float}
@MmuxDefineCFunctionPredicate{double}
@MmuxDefineCFunctionPredicate{ldouble}
@MmuxDefineCFunctionPredicate{complex}

@MmuxDefineCFunctionPredicate{sint8}
@MmuxDefineCFunctionPredicate{uint8}
@MmuxDefineCFunctionPredicate{sint16}
@MmuxDefineCFunctionPredicate{uint16}
@MmuxDefineCFunctionPredicate{sint32}
@MmuxDefineCFunctionPredicate{uint32}
@MmuxDefineCFunctionPredicate{sint64}
@MmuxDefineCFunctionPredicate{uint64}

@MmuxDefineCFunctionPredicate{ssize}
@MmuxDefineCFunctionPredicate{usize}
@MmuxDefineCFunctionPredicate{sintmax}
@MmuxDefineCFunctionPredicate{uintmax}
@MmuxDefineCFunctionPredicate{sintptr}
@MmuxDefineCFunctionPredicate{uintptr}
@MmuxDefineCFunctionPredicate{mode}
@MmuxDefineCFunctionPredicate{off}
@MmuxDefineCFunctionPredicate{pid}
@MmuxDefineCFunctionPredicate{uid}
@MmuxDefineCFunctionPredicate{gid}
@MmuxDefineCFunctionPredicate{wchar}
@MmuxDefineCFunctionPredicate{wint}

@c page
@node shared library maximum
@appendixsec Type representations of maximum values


@macro MmuxDefineCFunctionMaximum{STEM}
@deftypefun mmux_clib_\STEM\_t mmux_bash_pointers_maximum_\STEM\ (void)
@deftypefunx int mmux_bash_pointers_sprint_maximum_\STEM\ (char * @var{STR}, size_t @var{LEN})
The first function returns the maximum value representable by the range of values of the type
@objtype{mmux_clib_\STEM\_t}.

The second function writes in the buffer referenced by @var{STR} a string representation, in
@asciiz{} format, of the maximum value representable by the range of values of the type
@objtype{mmux_clib_\STEM\_t}; the buffer can contain at most @var{LEN} characters, terminating--zero
included.  When successful it returns @code{EXECUTION_SUCCESS}; otherwise it returns
@code{EXECUTION_FAILURE}.
@end deftypefun

@end macro


@MmuxDefineCFunctionMaximum{pointer}

@MmuxDefineCFunctionMaximum{schar}
@MmuxDefineCFunctionMaximum{uchar}
@MmuxDefineCFunctionMaximum{sshort}
@MmuxDefineCFunctionMaximum{ushort}
@MmuxDefineCFunctionMaximum{sint}
@MmuxDefineCFunctionMaximum{uint}
@MmuxDefineCFunctionMaximum{slong}
@MmuxDefineCFunctionMaximum{ulong}
@MmuxDefineCFunctionMaximum{sllong}
@MmuxDefineCFunctionMaximum{ullong}
@MmuxDefineCFunctionMaximum{float}
@MmuxDefineCFunctionMaximum{double}
@MmuxDefineCFunctionMaximum{ldouble}
@MmuxDefineCFunctionMaximum{complex}

@MmuxDefineCFunctionMaximum{sint8}
@MmuxDefineCFunctionMaximum{uint8}
@MmuxDefineCFunctionMaximum{sint16}
@MmuxDefineCFunctionMaximum{uint16}
@MmuxDefineCFunctionMaximum{sint32}
@MmuxDefineCFunctionMaximum{uint32}
@MmuxDefineCFunctionMaximum{sint64}
@MmuxDefineCFunctionMaximum{uint64}

@MmuxDefineCFunctionMaximum{ssize}
@MmuxDefineCFunctionMaximum{usize}
@MmuxDefineCFunctionMaximum{sintmax}
@MmuxDefineCFunctionMaximum{uintmax}
@MmuxDefineCFunctionMaximum{sintptr}
@MmuxDefineCFunctionMaximum{uintptr}
@MmuxDefineCFunctionMaximum{mode}
@MmuxDefineCFunctionMaximum{off}
@MmuxDefineCFunctionMaximum{pid}
@MmuxDefineCFunctionMaximum{uid}
@MmuxDefineCFunctionMaximum{gid}
@MmuxDefineCFunctionMaximum{wchar}
@MmuxDefineCFunctionMaximum{wint}

@c page
@node shared library minimum
@appendixsec Type representations of minimum values


@macro MmuxDefineCFunctionMinimum{STEM}
@deftypefun mmux_clib_\STEM\_t mmux_bash_pointers_minimum_\STEM\ (void)
@deftypefunx int mmux_bash_pointers_sprint_minimum_\STEM\ (char * @var{STR}, size_t @var{LEN})
The first function returns the minimum value representable by the range of values of the type
@objtype{mmux_clib_\STEM\_t}.

The second function writes in the buffer referenced by @var{STR} a string representation, in
@asciiz{} format, of the minimum value representable by the range of values of the type
@objtype{mmux_clib_\STEM\_t}; the buffer can contain at most @var{LEN} characters, terminating--zero
included.  When successful it returns @code{EXECUTION_SUCCESS}; otherwise it returns
@code{EXECUTION_FAILURE}.
@end deftypefun

@end macro


@MmuxDefineCFunctionMinimum{pointer}

@MmuxDefineCFunctionMinimum{schar}
@MmuxDefineCFunctionMinimum{uchar}
@MmuxDefineCFunctionMinimum{sshort}
@MmuxDefineCFunctionMinimum{ushort}
@MmuxDefineCFunctionMinimum{sint}
@MmuxDefineCFunctionMinimum{uint}
@MmuxDefineCFunctionMinimum{slong}
@MmuxDefineCFunctionMinimum{ulong}
@MmuxDefineCFunctionMinimum{sllong}
@MmuxDefineCFunctionMinimum{ullong}
@MmuxDefineCFunctionMinimum{float}
@MmuxDefineCFunctionMinimum{double}
@MmuxDefineCFunctionMinimum{ldouble}
@MmuxDefineCFunctionMinimum{complex}

@MmuxDefineCFunctionMinimum{sint8}
@MmuxDefineCFunctionMinimum{uint8}
@MmuxDefineCFunctionMinimum{sint16}
@MmuxDefineCFunctionMinimum{uint16}
@MmuxDefineCFunctionMinimum{sint32}
@MmuxDefineCFunctionMinimum{uint32}
@MmuxDefineCFunctionMinimum{sint64}
@MmuxDefineCFunctionMinimum{uint64}

@MmuxDefineCFunctionMinimum{ssize}
@MmuxDefineCFunctionMinimum{usize}
@MmuxDefineCFunctionMinimum{sintmax}
@MmuxDefineCFunctionMinimum{uintmax}
@MmuxDefineCFunctionMinimum{sintptr}
@MmuxDefineCFunctionMinimum{uintptr}
@MmuxDefineCFunctionMinimum{mode}
@MmuxDefineCFunctionMinimum{off}
@MmuxDefineCFunctionMinimum{pid}
@MmuxDefineCFunctionMinimum{uid}
@MmuxDefineCFunctionMinimum{gid}
@MmuxDefineCFunctionMinimum{wchar}
@MmuxDefineCFunctionMinimum{wint}

@c page
@node shared library parsers
@appendixsec Parsing string representations of C language types


Type parsers convert string representations to C language values; to parse a @code{mmuc_libc_sint_t}
representation we do:

@example
char const *            arg = "123";
mmux_libc_sint_t        value;
int                     rv;

rv = mmux_bash_pointers_parse_sint(&value, arg, "my-builtin");
@end example


@macro MmuxDefineCFunctionParser{STEM,TYPE}
@deftypefun int mmux_bash_pointers_parse_\STEM\ (mmux_libc_\STEM\_t * @var{PTR}, char const * @var{STR}, char const * @var{CALLER_NAME})
Parse a string which is meant to be the representation of a C language type @code{\TYPE\}; when
successful store the result in the variable referenced by @var{PTR}, then return
@code{EXECUTION_SUCCESS}; otherwise leave @var{PTR} untouched and return @code{EXECUTION_FAILURE}.

In case of failure: if @var{CALLER_NAME} is not @cnull{}, print on @stderr{} a message describing
the parsing error; @var{CALLER_NAME} must reference an @asciiz{} string representing the entity that
requested the parsing operation, for example: the name of a builtin.
@end deftypefun

@end macro


@MmuxDefineCFunctionParser{pointer,void *}

@MmuxDefineCFunctionParser{schar,signed char}
@MmuxDefineCFunctionParser{uchar,unsigned char}
@MmuxDefineCFunctionParser{sshort,signed short int}
@MmuxDefineCFunctionParser{ushort,unsigned short int}
@MmuxDefineCFunctionParser{sint,signed int}
@MmuxDefineCFunctionParser{uint,unsigned int}
@MmuxDefineCFunctionParser{slong,signed long}
@MmuxDefineCFunctionParser{ulong,unsigned long}
@MmuxDefineCFunctionParser{sllong,signed long long}
@MmuxDefineCFunctionParser{ullong,unsigned long long}
@MmuxDefineCFunctionParser{float,float}
@MmuxDefineCFunctionParser{double,double}
@MmuxDefineCFunctionParser{ldouble,long double}
@MmuxDefineCFunctionParser{complex,double complex}

@MmuxDefineCFunctionParser{sint8,int8_t}
@MmuxDefineCFunctionParser{uint8,uint8_t}
@MmuxDefineCFunctionParser{sint16,int16_t}
@MmuxDefineCFunctionParser{uint16,uint16_t}
@MmuxDefineCFunctionParser{sint32,int32_t}
@MmuxDefineCFunctionParser{uint32,uint32_t}
@MmuxDefineCFunctionParser{sint64,int64_t}
@MmuxDefineCFunctionParser{uint64,uint64_t}

@MmuxDefineCFunctionParser{ssize,ssize_t}
@MmuxDefineCFunctionParser{usize,size_t}
@MmuxDefineCFunctionParser{sintmax, intmax_t}
@MmuxDefineCFunctionParser{uintmax, uintmax_t}
@MmuxDefineCFunctionParser{sintptr, intptr_t}
@MmuxDefineCFunctionParser{uintptr, uintptr_t}
@MmuxDefineCFunctionParser{mode, mode_t}
@MmuxDefineCFunctionParser{off, off_t}
@MmuxDefineCFunctionParser{pid, pid_t}
@MmuxDefineCFunctionParser{uid, uid_t}
@MmuxDefineCFunctionParser{gid, gid_t}
@MmuxDefineCFunctionParser{wchar, wchar_t}
@MmuxDefineCFunctionParser{wint, wint_t}

@c page
@node shared library sprinters
@appendixsec Printing string representations of C language types


Type string printers convert binary representations of standard C language values to string
representations; to print a @objtype{mmux_libc_sint_t} string representation we do:

@example
mmux_libc_sint_t        value = 123;

#undef  LEN
#define LEN     256     /* enough? */
char    str[LEN];
int     rv;

rv = mmux_bash_pointers_sprint_sint(str, LEN, value);
@end example


@macro MmuxDefineCFunctionSprinter{STEM,TYPE}
@deftypefun int mmux_bash_pointers_sprint_\STEM\ (char * @var{STRPTR}, size_t @var{LEN}, \TYPE\ @var{VALUE})
Generate a string representation of @var{VALUE} and store it, in @asciiz{} format, in the string
referenced by @var{STRPTR}, which can hold at most @var{LEN} bytes (terminating zero included).
When successful return @code{EXECUTION_SUCCESS}; otherwise leave @var{STRPTR} untouched and return
@code{EXECUTION_FAILURE}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSprinter{pointer,void *}

@MmuxDefineCFunctionSprinter{schar,signed char}
@MmuxDefineCFunctionSprinter{uchar,unsigned char}
@MmuxDefineCFunctionSprinter{sshort,signed short int}
@MmuxDefineCFunctionSprinter{ushort,unsigned short int}
@MmuxDefineCFunctionSprinter{sint,signed int}
@MmuxDefineCFunctionSprinter{uint,unsigned int}
@MmuxDefineCFunctionSprinter{slong,signed long}
@MmuxDefineCFunctionSprinter{ulong,unsigned long}
@MmuxDefineCFunctionSprinter{sllong,signed long long}
@MmuxDefineCFunctionSprinter{ullong,unsigned long long}
@MmuxDefineCFunctionSprinter{float,float}
@MmuxDefineCFunctionSprinter{double,double}
@MmuxDefineCFunctionSprinter{ldouble,long double}
@MmuxDefineCFunctionSprinter{complex,double complex}

@MmuxDefineCFunctionSprinter{sint8,int8_t}
@MmuxDefineCFunctionSprinter{uint8,uint8_t}
@MmuxDefineCFunctionSprinter{sint16,int16_t}
@MmuxDefineCFunctionSprinter{uint16,uint16_t}
@MmuxDefineCFunctionSprinter{sint32,int32_t}
@MmuxDefineCFunctionSprinter{uint32,uint32_t}
@MmuxDefineCFunctionSprinter{sint64,int64_t}
@MmuxDefineCFunctionSprinter{uint64,uint64_t}

@MmuxDefineCFunctionSprinter{ssize,ssize_t}
@MmuxDefineCFunctionSprinter{usize,size_t}
@MmuxDefineCFunctionSprinter{sintmax, intmax_t}
@MmuxDefineCFunctionSprinter{uintmax, uintmax_t}
@MmuxDefineCFunctionSprinter{sintptr, intptr_t}
@MmuxDefineCFunctionSprinter{uintptr, uintptr_t}
@MmuxDefineCFunctionSprinter{mode, mode_t}
@MmuxDefineCFunctionSprinter{off, off_t}
@MmuxDefineCFunctionSprinter{pid, pid_t}
@MmuxDefineCFunctionSprinter{uid, uid_t}
@MmuxDefineCFunctionSprinter{gid, gid_t}
@MmuxDefineCFunctionSprinter{wchar, wchar_t}
@MmuxDefineCFunctionSprinter{wint, wint_t}

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mbfl{} is available online:

@center @url{http://github.com/marcomaggi/mbfl/}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

