/*
  Part of: MMUX Bash Pointers
  Contents: parsers from strings to internal values
  Date: Sep 11, 2024

  Abstract

	This module implements parsers from strings to internal values.

  Copyright (C) 2024 Marco Maggi <mrc.mgg@gmail.com>

  This program is free  software: you can redistribute it and/or  modify it under the
  terms of the  GNU Lesser General Public  License as published by  the Free Software
  Foundation, either version 3 of the License, or (at your option) any later version.

  This program  is distributed in the  hope that it  will be useful, but  WITHOUT ANY
  WARRANTY; without  even the implied  warranty of  MERCHANTABILITY or FITNESS  FOR A
  PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License along with
  this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/** --------------------------------------------------------------------
 ** Headers.
 ** ----------------------------------------------------------------- */

#include "mmux-bash-pointers-internals.h"

/* This regular expression is used to parse this package's standard format of complex
   double numbers.  */
regex_t mmux_bash_pointers_complex_rex;


/** --------------------------------------------------------------------
 ** Type parsers.
 ** ----------------------------------------------------------------- */

m4_define([[[MMUX_BASH_POINTERS_DEFINE_PARSER]]],[[[
int
mmux_bash_pointers_parse_$1 (mmux_libc_[[[$1]]]_t * p_data, char const * s_arg, char const * caller_name)
{
#if ($3)
  int	rv;

  /* NOTE I  know that to convert  integers there are functions  like "strtol()", but
     let's not be picky.  (Marco Maggi; Sep 9, 2024) */
  rv = sscanf(s_arg, $2, p_data);
  if ((EOF != rv) && (1 == rv)) {
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"$1\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
#else
  fprintf(stderr, "MMUX Bash Pointers: error: parsing function \"%s\" not implemented because underlying C language type not available.\n",
	  __func__);
  return EXECUTION_FAILURE;
#endif
}
]]])

MMUX_BASH_POINTERS_DEFINE_PARSER([[[pointer]]],		[[["%p"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[schar]]],		[[["%hhd"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[uchar]]],		[[["%hhu"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[sshort]]],		[[["%hd"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[ushort]]],		[[["%hu"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[sint]]],		[[["%d"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[uint]]],		[[["%u"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[slong]]],		[[["%ld"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[ulong]]],		[[["%lu"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[sllong]]],		[[["%lld"]]],	[[[HAVE_LONG_LONG_INT]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[ullong]]],		[[["%llu"]]],	[[[HAVE_UNSIGNED_LONG_LONG_INT]]])

MMUX_BASH_POINTERS_DEFINE_PARSER([[[float]]],		[[["%f"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[double]]],		[[["%lf"]]],	[[[1]]])
MMUX_BASH_POINTERS_DEFINE_PARSER([[[ldouble]]],		[[["%Lf"]]],	[[[HAVE_LONG_DOUBLE]]])


/** --------------------------------------------------------------------
 ** Type parsers: int8.
 ** ----------------------------------------------------------------- */

int
mmux_bash_pointers_parse_sint8 (int8_t * p_data, char const * s_arg, char const * caller_name)
{
  int	data;
  int	rv;

  rv = mmux_bash_pointers_parse_sint(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if ((INT8_MIN <= data) && (data <= INT8_MAX)) {
    *p_data = (int8_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"int8_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
}
int
mmux_bash_pointers_parse_uint8 (uint8_t * p_data, char const * s_arg, char const * caller_name)
{
  unsigned	data;
  int		rv;

  rv = mmux_bash_pointers_parse_uint(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if (data <= UINT8_MAX) {
    *p_data = (uint8_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"uint8_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
}


/** --------------------------------------------------------------------
 ** Type parsers: int16.
 ** ----------------------------------------------------------------- */

int
mmux_bash_pointers_parse_sint16 (int16_t * p_data, char const * s_arg, char const * caller_name)
{
  int	data;
  int	rv;

  rv = mmux_bash_pointers_parse_sint(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if ((INT16_MIN <= data) && (data <= INT16_MAX)) {
    *p_data = (int16_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"int16_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
}
int
mmux_bash_pointers_parse_uint16 (uint16_t * p_data, char const * s_arg, char const * caller_name)
{
  unsigned	data;
  int		rv;

  rv = mmux_bash_pointers_parse_uint(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if (data <= UINT16_MAX) {
    *p_data = (uint16_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"uint16_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
}


/** --------------------------------------------------------------------
 ** Type parsers: int32.
 ** ----------------------------------------------------------------- */

int
mmux_bash_pointers_parse_sint32 (int32_t  * p_data, char const * s_arg, char const * caller_name)
{
  long 	data;
  int	rv;

  rv = mmux_bash_pointers_parse_slong(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if ((INT32_MIN <= data) && (data <= INT32_MAX)) {
    *p_data = (int32_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"int32_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
}
int
mmux_bash_pointers_parse_uint32  (uint32_t * p_data, char const * s_arg, char const * caller_name)
{
  unsigned long	data;
  int		rv;

  rv = mmux_bash_pointers_parse_ulong(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if (data <= UINT32_MAX) {
    *p_data = (uint32_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"uint32_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
}


/** --------------------------------------------------------------------
 ** Type parsers: int64.
 ** ----------------------------------------------------------------- */

int
mmux_bash_pointers_parse_sint64  (int64_t  * p_data, char const * s_arg, char const * caller_name)
{
#if ((defined HAVE_LONG_LONG_INT) && (1 == HAVE_LONG_LONG_INT))
  long long 	data;
  int		rv;

  rv = mmux_bash_pointers_parse_sllong(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if ((INT64_MIN <= data) && (data <= INT64_MAX)) {
    *p_data = (int64_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"int64_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
#else
  fprintf(stderr, "MMUX Bash Pointers: error: parser \"%s\" not implemented because underlying C language type not available.\n",
	  __func__);
  return EXECUTION_FAILURE;
#endif
}
int
mmux_bash_pointers_parse_uint64  (uint64_t * p_data, char const * s_arg, char const * caller_name)
{
#if ((defined HAVE_UNSIGNED_LONG_LONG_INT) && (1 == HAVE_UNSIGNED_LONG_LONG_INT))
  unsigned long	long	data;
  int			rv;

  rv = mmux_bash_pointers_parse_ullong(&data, s_arg, caller_name);
  if (EXECUTION_FAILURE == rv) {
    return rv;
  }
  if (data <= UINT64_MAX) {
    *p_data = (uint64_t)data;
    return EXECUTION_SUCCESS;
  } else {
    if (caller_name) {
      fprintf(stderr, "%s: error: invalid argument, expected \"uint64_t\": \"%s\"\n", caller_name, s_arg);
    }
    return EXECUTION_FAILURE;
  }
  return rv;
#else
  fprintf(stderr, "MMUX Bash Pointers: error: parser \"%s\" not implemented because underlying C language type not available.\n",
	  __func__);
  return EXECUTION_FAILURE;
#endif
}


/** --------------------------------------------------------------------
 ** Parsing complex numbers in double format.
 ** ----------------------------------------------------------------- */

static int parse_complex_parentheses_format (double complex * p_value, const char * s_arg, const char * caller_name);

int
mmux_bash_pointers_parse_complex (double complex * p_value, const char * s_arg, const char * caller_name)
{
  int	len = strlen(s_arg);

  if (len > 2048) {
    fprintf(stderr, "%s: error: invalid argument, string too long (max 2048 chars): \"%s\"\n", caller_name, s_arg);
    return EXECUTION_FAILURE;
  } else {
    int		rv;

    rv = parse_complex_parentheses_format(p_value, s_arg, caller_name);
    if (EXECUTION_SUCCESS == rv) {
      return rv;
    } else {
      double	op_re;

      rv = mmux_bash_pointers_parse_double(&op_re, s_arg, caller_name);
      if (EXECUTION_SUCCESS == rv) {
	*p_value = op_re + 0.0 * ((double complex)_Complex_I);
	return EXECUTION_SUCCESS;
      } else {
	if (caller_name) {
	  fprintf(stderr, "%s: error: invalid argument, expected complex number: \"%s\"\n", caller_name, s_arg);
	}
	return EXECUTION_FAILURE;
      }
    }
  }
}

int
parse_complex_parentheses_format (double complex * p_value, const char * s_arg, const char * caller_name)
/* Try to parse a complex number in the format: (1.2)+i*(3.4)

   First use  a regular  expression to  extract the real  and imaginary  parts.  Then
   parse the real part and the imaginary part separately. */
{
  double	op_re, op_im;
  int		rv;
  char		s_arg_re[1024];
  char		s_arg_im[1024];
  size_t	nmatch = 3;
  regmatch_t	match[3];

  rv = regexec(&mmux_bash_pointers_complex_rex, s_arg, nmatch, &(match[0]), 0);
  if (rv) {
    if (0) {
      char	error_message[1024];

      regerror(rv, &mmux_bash_pointers_complex_rex, error_message, 1024);
      fprintf(stderr, "%s: error: invalid argument, expected complex number (%s): \"%s\"\n", caller_name, error_message, s_arg);
    }
    return EXECUTION_FAILURE;
  }

  /* Extract the first matching parentetical subexpression, which represents the real
     part. */
  {
    int	i, imax = match[1].rm_eo - match[1].rm_so;

    for (i=0; i < imax; ++i) {
      s_arg_re[i] = s_arg[match[1].rm_so + i];
    }
    s_arg_re[imax] = '\0';
  }

  /* Extract  the second  matching parentetical  subexpression, which  represents the
     imaginary part. */
  {
    int	i, imax = match[2].rm_eo - match[2].rm_so;

    for (i=0; i < imax; ++i) {
      s_arg_im[i] = s_arg[match[2].rm_so + i];
    }
    s_arg_im[imax] = '\0';
  }

  if (0) {
    fprintf(stderr, "%s: scanned re='%s' im='%s'\n", __func__, s_arg_re, s_arg_im);
  }

  /* Parse the real part. */
  {
    rv = mmux_bash_pointers_parse_double(&op_re, s_arg_re, caller_name);
    if (EXECUTION_FAILURE == rv) { return rv; }
  }

  /* Parse the imaginary part. */
  {
    rv = mmux_bash_pointers_parse_double(&op_im, s_arg_im, caller_name);
    if (EXECUTION_FAILURE == rv) { return rv; }
  }

  /* Assemble the complex number. */
  {
    *p_value = op_re + op_im * ((double complex)_Complex_I);
    return EXECUTION_SUCCESS;
  }
}


/** --------------------------------------------------------------------
 ** Other C language and Unix type parsers.
 ** ----------------------------------------------------------------- */

m4_define([[[MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER]]],[[[
int
mmux_bash_pointers_parse_$1 (mmux_libc_[[[$1]]]_t * p_value, char const * s, char const * caller_name)
{
  return $2(p_value, s, caller_name);
}
]]])

MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[ssize]]],		[[[@MMUX_TYPE_PARSE_SSIZE@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[usize]]],		[[[@MMUX_TYPE_PARSE_USIZE@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[sintmax]]],		[[[@MMUX_TYPE_PARSE_SINTMAX@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[uintmax]]],		[[[@MMUX_TYPE_PARSE_UINTMAX@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[sintptr]]],		[[[@MMUX_TYPE_PARSE_SINTPTR@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[uintptr]]],		[[[@MMUX_TYPE_PARSE_UINTPTR@]]])

MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[ptrdiff]]],		[[[@MMUX_TYPE_PARSE_PTRDIFF@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[mode]]],		[[[@MMUX_TYPE_PARSE_MODE@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[off]]],		[[[@MMUX_TYPE_PARSE_OFF@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[pid]]],		[[[@MMUX_TYPE_PARSE_PID@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[uid]]],		[[[@MMUX_TYPE_PARSE_UID@]]])
MMUX_BASH_POINTERS_DEFINE_SUBTYPE_PARSER([[[gid]]],		[[[@MMUX_TYPE_PARSE_GID@]]])

/* end of file */
