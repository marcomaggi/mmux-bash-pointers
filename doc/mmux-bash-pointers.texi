\input texinfo.tex
@c %**start of header
@setfilename mmux-bash-pointers.info
@settitle MMUX Bash Pointers
@c %**end of header

@include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX Bash Pointers

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX Bash Pointers

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-bash-pointers

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_BASH_POINTERS
@set PackagePkgconfigModule             mmux-bash-pointers
@set PackageLibsVar                     @env{MMUX_BASH_POINTERS_LIBS}
@set PackageCflagsVar                   @env{MMUX_BASH_POINTERS_CFLAGS}
@c This is the stem of the library in "libmmux-bash-pointers.so".
@set PackageLibstem                     mmux-bash-pointers
@set PackageApiPrefixLower              mmux_bash_pointers_
@set PackageApiPrefixUpper              MMUX_BASH_POINTERS_

@set PackageHeader                      mmux-bash-pointers.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mbfl{}
@acronym{MBFL}
@end macro
@end ifinfo
@ifnotinfo
@macro mbfl{}
@acronym{mbfl}
@end macro
@end ifnotinfo

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@macro MmuxBuiltin{NAME}
@code{\NAME\}
@end macro

@macro RR{VARNAME}
$@{\VARNAME\:?@}
@end macro

@macro WW{VARNAME}
"$@{\VARNAME\:?@}"
@end macro

@macro QQ{VARNAME}
"$@{\VARNAME\@}"
@end macro

@macro SS{ARRYNAME,KEY}
'\ARRYNAME\[\KEY\]'
@end macro

@macro cfuncpage{FUNCNAME}
@ref{\FUNCNAME\,\FUNCNAME\,\FUNCNAME\,*manpages*}
@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a package implementing loadable
builtins for the @gnu{} Bash shell; to do so it installs a C11 language shared library and shell
scripts which are meant to be sourced in a @gnu{} Bash session or script.

This package makes raw memory pointers available to the shell; it also interfaces some basic
functions from the C language @posix{} standard library.  The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-bash-pointers: (mmux-bash-pointers).  Additional GNU Bash builtins.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* descriptor::                  Package descriptors.
* constants::                   Values of system constants.
* cctypes::                     Interface to supported C language data types.
* memory::                      Raw memory operations.
* strings::                     @asciiz{} strings.
* fds::                         Core file descriptor operations.
* fs::                          File system interface.
* persona::                     Persona operations.
* errors::                      Handling errors.
* misc::                        Miscellaneous features.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* shared library::              Using the shared library.
* packages::                    Package handling library.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a package implementing loadable
builtins for the @gnu{} Bash shell; to do so it installs a C11 language shared library and shell
scripts which are meant to be sourced in a @gnu{} Bash session or script.

This package makes raw memory pointers available to the shell:

@example
source libmmux-bash-packages.bash
source libmmux-bash-pointers.bash

declare PTR VALUE

mmux_libc_malloc PTR 1024
@{
  mmux_sint_pointer_set $PTR 0 123
  mmux_sint_pointer_ref VALUE $PTR 0
@}
mmux_libc_free $PTR
$VALUE  @result{} 123
@end example

@menu
* overview install::            Installed files.
* overview usage::              How to use the shell libraries.
* overview decimal::            Support for the @objtype{_DecimalN} types.
* overview stems::              Specifying C language types with their stem.
* overview conventions::        Conventions in coding and documentation
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview install
@section Installed files


@value{PACKAGE} installs shell scripts, ``shell libraries'', under @code{$datavar/bash}; for
example:

@example
/usr/local/share/bash/libmmux-bash-packages.bash
/usr/local/share/bash/libmmux-bash-pointers.bash
@end example

@noindent
to use the builtins, we have to load the shell library using Bash's builtin @code{source}.  A shared
library, actually implementing the builtins, is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/libmmux-bash-pointers.so
@end example

@noindent
the shared library is automatically loaded by the shell library.

C language header files are also installed under @code{$includedir}, for example:

@example
/usr/local/include/libmmux-bash-pointers.h
/usr/local/include/libmmux-bash-pointers-config.h
@end example

@noindent
we can write code that links to the shared library to reuse some of its facilities.

@c page
@node overview usage
@section How to use the shell libraries


The package @value{PACKAGE} adheres to the requirements of the @mmux{} Bash Packages Infrastructure,
@ref{packages, @mmux{} Bash Packages Infrastructure}.

To use the shell libraries we have to first load @file{libmmux-bash-packages.bash} and then to load
@file{libmmux-bash-pointers.bash}.  If we have configured the environment to let @code{source} find
the libraries in their installation directory, we do:

@example
source libmmux-bash-packages.bash
source libmmux-bash-pointers.bash
@end example

@noindent
otherwise we can specify the full installation pathname:

@example
source /usr/local/share/bash/libmmux-bash-packages.bash
source /usr/local/share/bash/libmmux-bash-pointers.bash
@end example

@noindent
nothing else is required for basic operations.

@gnu{} Bash expects shared libraries implementing loadable builtins to be installed in one of the
usual places, so that the builtin @code{enable} can find them.  If needed, on Unix systems: we can
configure the search path using the system environment variable @env{LD_LIBRARY_PATH}.

@c page
@node overview decimal
@section Support for the @objtype{_DecimalN} types


Support for the @objtype{_DecimalN} types is enabled if availability of such types is detected at
package--configuration time.  This package relies on the availability of the external package
@code{libdfp}.

@c page
@node overview stems
@section Specifying C language types with their stem


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{float}, type stem
@cindex @code{double}, type stem
@cindex @code{ldouble}, type stem

@cindex @code{float32}, type stem
@cindex @code{float64}, type stem
@cindex @code{float128}, type stem

@cindex @code{float32x}, type stem
@cindex @code{float64x}, type stem
@cindex @code{float128x}, type stem

@cindex @code{decimal32}, type stem
@cindex @code{decimal64}, type stem
@cindex @code{decimal128}, type stem

@cindex @code{complexf}, type stem
@cindex @code{complexd}, type stem
@cindex @code{complexld}, type stem

@cindex @code{complexf32}, type stem
@cindex @code{complexf64}, type stem
@cindex @code{complexf128}, type stem

@cindex @code{complexf32x}, type stem
@cindex @code{complexf64x}, type stem
@cindex @code{complexf128x}, type stem

@cindex @code{complexd32}, type stem
@cindex @code{complexd64}, type stem
@cindex @code{complexd128}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem


The following word definitions just alias the corresponding C language type; such uniform names are
useful when using preprocessor macros to generate code.

If @value{PACKAGE} supports a type: it blindly implements all the possible operations for it, even
when it looks like an operation does not make much sense.  A type is a type.

@macro MmuxDefineTypeStem{STEM,TYPE}
@deftp {Type Stem} \STEM\
Single--word specification of a C language type supported by this package.  It is an alias for the C
language type @code{\TYPE\}.
@end deftp

@end macro


@MmuxDefineTypeStem{pointer,void *}

@MmuxDefineTypeStem{schar,signed char}
@MmuxDefineTypeStem{uchar,unsigned char}
@MmuxDefineTypeStem{sshort,signed short int}
@MmuxDefineTypeStem{ushort,unsigned short int}
@MmuxDefineTypeStem{sint,signed int}
@MmuxDefineTypeStem{uint,unsigned int}
@MmuxDefineTypeStem{slong,signed long}
@MmuxDefineTypeStem{ulong,unsigned long}
@MmuxDefineTypeStem{sllong,signed long long}
@MmuxDefineTypeStem{ullong,unsigned long long}
@MmuxDefineTypeStem{float,float}
@MmuxDefineTypeStem{double,double}
@MmuxDefineTypeStem{ldouble,long double}

@MmuxDefineTypeStem{float32, _Float32}
@MmuxDefineTypeStem{float64, _Float64}
@MmuxDefineTypeStem{float128, _Float128}

@MmuxDefineTypeStem{float32x, _Float32x}
@MmuxDefineTypeStem{float64x, _Float64x}
@MmuxDefineTypeStem{float128x, _Float128x}

@MmuxDefineTypeStem{decimal32, _Decimal32}
@MmuxDefineTypeStem{decimal64, _Decimal64}
@MmuxDefineTypeStem{decimal128, _Decimal128}

@MmuxDefineTypeStem{complexf,float complex}
@MmuxDefineTypeStem{complexd,double complex}
@MmuxDefineTypeStem{complexld,long double complex}

@MmuxDefineTypeStem{complexf32, _Float32 complex}
@MmuxDefineTypeStem{complexf64, _Float64 complex}
@MmuxDefineTypeStem{complexf128, _Float128 complex}

@MmuxDefineTypeStem{complexf32x, _Float32 complex}
@MmuxDefineTypeStem{complexf64x, _Float64x complex}
@MmuxDefineTypeStem{complexf128x, _Float128x complex}

@deftp {Type Stem} complexd32
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{_Decimal32} values as real and imaginary parts.
@end deftp


@deftp {Type Stem} complexd64
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{_Decimal64} values as real and imaginary parts.
@end deftp


@deftp {Type Stem} complexd128
Single--word specification of a C language type supported by this package.  It is an alias for a
non--standard C language type implementing complex floating--point numbers having
@objtype{_Decimal128} values as real and imaginary parts.
@end deftp

@MmuxDefineTypeStem{sint8,int8_t}
@MmuxDefineTypeStem{uint8,uint8_t}
@MmuxDefineTypeStem{sint16,int16_t}
@MmuxDefineTypeStem{uint16,uint16_t}
@MmuxDefineTypeStem{sint32,int32_t}
@MmuxDefineTypeStem{uint32,uint32_t}
@MmuxDefineTypeStem{sint64,int64_t}
@MmuxDefineTypeStem{uint64,uint64_t}

@MmuxDefineTypeStem{ssize,ssize_t}
@MmuxDefineTypeStem{usize,size_t}
@MmuxDefineTypeStem{sintmax, intmax_t}
@MmuxDefineTypeStem{uintmax, uintmax_t}
@MmuxDefineTypeStem{sintptr, intptr_t}
@MmuxDefineTypeStem{uintptr, uintptr_t}
@MmuxDefineTypeStem{mode, mode_t}
@MmuxDefineTypeStem{off, off_t}
@MmuxDefineTypeStem{pid, pid_t}
@MmuxDefineTypeStem{uid, uid_t}
@MmuxDefineTypeStem{gid, gid_t}
@MmuxDefineTypeStem{wchar, wchar_t}
@MmuxDefineTypeStem{wint, wint_t}

@c page
@node overview conventions
@section Conventions in coding and documentation


Unless otherwise specified: the loadable builtins provided by @value{PACKAGE} return only two
values: true or false.  Unless otherwise specified: these values are reserved to signal the
successful execution of the builtin itself; the return value is false only if an error occurred
while executing the builtin.

When a builtin is successful: its return value is true; otherwise its return value is false and the
shell variable @env{ERRNO} is set to the string representation of an exact integer, itself
representing an @code{errno} error code.

Some builtins return true of false to indicate the result of evaluating predicate; in this case it
is impossible to distinguish an error from the predicate condition being false; this behaviour is
analogous to that of Bash's @command{test} builtin.

The following naming conventions for builtin and function arguments are used in this documentation:

@table @var
@item POINTER
@cindex @var{POINTER}, builtin and function argument
The argument is a string representation of a @objtype{void *} value.

@item SCHAR
@cindex @var{SCHAR}, builtin and function argument
The argument is a string representation of a @objtype{mmux_schar_t} value.

@item UCHAR
@cindex @var{UCHAR}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uchar_t} value.

@item SSHORT
@cindex @var{SSHORT}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sshort_t} value.

@item USHORT
@cindex @var{USHORT}, builtin and function argument
The argument is a string representation of a @objtype{mmux_ushort_t} value.

@item SINT
@cindex @var{SINT}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sint_t} value.

@item UINT
@cindex @var{UINT}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uint_t} value.

@item SLONG
@cindex @var{SLONG}, builtin and function argument
The argument is a string representation of a @objtype{mmux_slong_t} value.

@item ULONG
@cindex @var{ULONG}, builtin and function argument
The argument is a string representation of a @objtype{mmux_ulong_t} value.

@item SLLONG
@cindex @var{SLLONG}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sllong_t} value.

@item ULLONG
@cindex @var{ULLONG}, builtin and function argument
The argument is a string representation of a @objtype{mmux_ullong_t} value.

@item FLOAT
@cindex @var{FLOAT}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float_t} value.

@item DOUBLE
@cindex @var{DOUBLE}, builtin and function argument
The argument is a string representation of a @objtype{mmux_double_t} value.

@item LDOUBLE
@cindex @var{LDOUBLE}, builtin and function argument
The argument is a string representation of a @objtype{mmux_ldouble_t} value.

@item FLOAT32
@cindex @var{FLOAT32}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float32_t} value.

@item FLOAT64
@cindex @var{FLOAT64}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float64_t} value.

@item FLOAT128
@cindex @var{FLOAT128}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float128_t} value.

@item FLOAT32X
@cindex @var{FLOAT32X}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float32x_t} value.

@item FLOAT64X
@cindex @var{FLOAT64X}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float64x_t} value.

@item FLOAT128X
@cindex @var{FLOAT128X}, builtin and function argument
The argument is a string representation of a @objtype{mmux_float128x_t} value.

@item DECIMAL32
@cindex @var{DECIMAL32}, builtin and function argument
The argument is a string representation of a @objtype{mmux_decimal32_t} value.

@item DECIMAL64
@cindex @var{DECIMAL64}, builtin and function argument
The argument is a string representation of a @objtype{mmux_decimal64_t} value.

@item DECIMAL128
@cindex @var{DECIMAL128}, builtin and function argument
The argument is a string representation of a @objtype{mmux_decimal128_t} value.

@item COMPLEXF
@cindex @var{COMPLEXF}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf_t} value.

@item COMPLEXD
@cindex @var{COMPLEXD}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexd_t} value.

@item COMPLEXLD
@cindex @var{COMPLEXLD}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexld_t} value.

@item COMPLEXF32
@cindex @var{COMPLEXF32}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf32_t} value.

@item COMPLEXF64
@cindex @var{COMPLEXF64}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf64_t} value.

@item COMPLEXF128
@cindex @var{COMPLEXF128}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf128_t} value.

@item COMPLEXF32X
@cindex @var{COMPLEXF32X}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf32x_t} value.

@item COMPLEXF64X
@cindex @var{COMPLEXF64X}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf64x_t} value.

@item COMPLEXF128X
@cindex @var{COMPLEXF128X}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexf128x_t} value.

@item COMPLEXD32
@cindex @var{COMPLEXD32}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexd32_t} value.

@item COMPLEXD64
@cindex @var{COMPLEXD64}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexd64_t} value.

@item complexd128
@cindex @var{complexd128}, builtin and function argument
The argument is a string representation of a @objtype{mmux_complexd128_t} value.

@item SINT8
@cindex @var{SINT8}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sint8_t} value.

@item UINT8
@cindex @var{UINT8}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uint8_t} value.

@item SINT16
@cindex @var{SINT16}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sint16_t} value.

@item UINT16
@cindex @var{UINT16}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uint16_t} value.

@item SINT32
@cindex @var{SINT32}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sint32_t} value.

@item UINT32
@cindex @var{UINT32}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uint32_t} value.

@item SINT64
@cindex @var{SINT64}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sint64_t} value.

@item UINT64
@cindex @var{UINT64}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uint64_t} value.

@item SSIZE
@cindex @var{SSIZE}, builtin and function argument
The argument is a string representation of a @objtype{mmux_ssize_t} value.

@item USIZE
@cindex @var{USIZE}, builtin and function argument
The argument is a string representation of a @objtype{mmux_usize_t} value.

@item SINTMAX
@cindex @var{SINTMAX}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sintmax_t} value.

@item UINTMAX
@cindex @var{UINTMAX}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uintmax_t} value.

@item SINTPTR
@cindex @var{SINTPTR}, builtin and function argument
The argument is a string representation of a @objtype{mmux_sintptr_t} value.

@item UINTPTR
@cindex @var{UINTPTR}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uintptr_t} value.

@item MODE
@cindex @var{MODE}, builtin and function argument
The argument is a string representation of a @objtype{mmux_mode_t} value.

@item OFF
@cindex @var{OFF}, builtin and function argument
The argument is a string representation of a @objtype{mmux_off_t} value.

@item PID
@cindex @var{PID}, builtin and function argument
The argument is a string representation of a @objtype{mmux_pid_t} value.

@item UID
@cindex @var{UID}, builtin and function argument
The argument is a string representation of a @objtype{mmux_uid_t} value.

@item GID
@cindex @var{GID}, builtin and function argument
The argument is a string representation of a @objtype{mmux_gid_t} value.

@item WCHAR
@cindex @var{WCHAR}, builtin and function argument
The argument is a string representation of a @objtype{mmux_wchar_t} value.

@item WINT
@cindex @var{WINT}, builtin and function argument
The argument is a string representation of a @objtype{mmux_wint_t} value.
@end table

Additional argument specifications:

@table @var
@item ASCIIZ_POINTER
@cindex @var{ASCIIZ_POINTER}, builtin and function argument
The argument is a string representation of a @objtype{char *} value, referencing a block of memory
containing a string in @asciiz{} format.

@item STR
@itemx STRING
@cindex @var{STR}, builtin and function argument
@cindex @var{STRING}, builtin and function argument
The argument is a Bash string.

@item STRVAR
@cindex @var{STRVAR}, builtin and function argument
The argument is a Bash string representing the name of a shell variable.  When successful: the
builtin or function will bind a string to the variable.

@item PTRVAR
@cindex @var{PTRVAR}, builtin and function argument
The argument is a Bash string representing the name of a shell variable.  When successful: the
builtin or function will bind to the variable a string representation of a pointer value.
@end table

@c page

@include overview-linking.texi

@c page
@node descriptor
@chapter Package descriptors


@cindex Package descriptor for @value{PACKAGE}


@value{PACKAGE} adheres to the requirements of the @mmux{} Bash Packages Infrastructure,
@ref{packages, @mmux{} Bash Packages Infrastructure}.  As such the library
@file{libmmux-bash-pointers.bash} defines a package descriptor holding basic informations about the
exported @api{}.

The @api{} follows version numbering as established by the @gnu{} Autotools.  For an explanation of
interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface, Libtool's
versioning system, libtool, Shared library support for @gnu{}}.


@defvr {Associative Shell Array} MMUX_BASH_POINTERS_PACKAGE
A descriptor representing informations about the package.

For details on the defined keys @ref{packages descriptor, Package descriptor}.
@end defvr

@c page
@node constants
@chapter Values of system constants


If a C language constant referenced by one of the following variables is undefined: the
corresponding Bash variable is undefined; we can test this condition with @code{test -v}; to test if
the underlying platform implements the constant @code{O_EXEC}, we can do:

@example
if test -v mmux_libc_O_EXEC
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarSystemConstant{NAME}
@defvar mmux_libc_\NAME\
Global variable holding the value of the C language constant @code{\NAME\}.
@end defvar

@end macro

@MmuxDefineGlobalVarSystemConstant{AT_EMPTY_PATH}
@MmuxDefineGlobalVarSystemConstant{AT_FDCWD}
@MmuxDefineGlobalVarSystemConstant{AT_REMOVEDIR}
@MmuxDefineGlobalVarSystemConstant{AT_SYMLINK_FOLLOW}
@MmuxDefineGlobalVarSystemConstant{EOF}
@MmuxDefineGlobalVarSystemConstant{F_DUPFD}
@MmuxDefineGlobalVarSystemConstant{F_GETFD}
@MmuxDefineGlobalVarSystemConstant{F_GETFL}
@MmuxDefineGlobalVarSystemConstant{F_GETLK}
@MmuxDefineGlobalVarSystemConstant{F_GETOWN}
@MmuxDefineGlobalVarSystemConstant{F_OK}
@MmuxDefineGlobalVarSystemConstant{F_RDLCK}
@MmuxDefineGlobalVarSystemConstant{F_SETFD}
@MmuxDefineGlobalVarSystemConstant{F_SETFL}
@MmuxDefineGlobalVarSystemConstant{F_SETLK}
@MmuxDefineGlobalVarSystemConstant{F_SETLKW}
@MmuxDefineGlobalVarSystemConstant{F_SETOWN}
@MmuxDefineGlobalVarSystemConstant{F_UNLCK}
@MmuxDefineGlobalVarSystemConstant{F_WRLCK}
@MmuxDefineGlobalVarSystemConstant{MAXSYMLINKS}
@MmuxDefineGlobalVarSystemConstant{O_ACCMODE}
@MmuxDefineGlobalVarSystemConstant{O_APPEND}
@MmuxDefineGlobalVarSystemConstant{O_ASYNC}
@MmuxDefineGlobalVarSystemConstant{O_CLOEXEC}
@MmuxDefineGlobalVarSystemConstant{O_CREAT}
@MmuxDefineGlobalVarSystemConstant{O_DIRECT}
@MmuxDefineGlobalVarSystemConstant{O_DIRECTORY}
@MmuxDefineGlobalVarSystemConstant{O_EXCL}
@MmuxDefineGlobalVarSystemConstant{O_EXEC}
@MmuxDefineGlobalVarSystemConstant{O_EXLOCK}
@MmuxDefineGlobalVarSystemConstant{O_FSYNC}
@MmuxDefineGlobalVarSystemConstant{O_IGNORE_CTTY}
@MmuxDefineGlobalVarSystemConstant{O_LARGEFILE}
@MmuxDefineGlobalVarSystemConstant{O_NDELAY}
@MmuxDefineGlobalVarSystemConstant{O_NOATIME}
@MmuxDefineGlobalVarSystemConstant{O_NOCTTY}
@MmuxDefineGlobalVarSystemConstant{O_NOFOLLOW}
@MmuxDefineGlobalVarSystemConstant{O_NOLINK}
@MmuxDefineGlobalVarSystemConstant{O_NONBLOCK}
@MmuxDefineGlobalVarSystemConstant{O_NOTRANS}
@MmuxDefineGlobalVarSystemConstant{O_RDONLY}
@MmuxDefineGlobalVarSystemConstant{O_RDWR}
@MmuxDefineGlobalVarSystemConstant{O_READ}
@MmuxDefineGlobalVarSystemConstant{O_SHLOCK}
@MmuxDefineGlobalVarSystemConstant{O_SYNC}
@MmuxDefineGlobalVarSystemConstant{O_TRUNC}
@MmuxDefineGlobalVarSystemConstant{O_WRITE}
@MmuxDefineGlobalVarSystemConstant{O_WRONLY}
@MmuxDefineGlobalVarSystemConstant{R_OK}
@MmuxDefineGlobalVarSystemConstant{RENAME_EXCHANGE}
@MmuxDefineGlobalVarSystemConstant{RENAME_NOREPLACE}
@MmuxDefineGlobalVarSystemConstant{RENAME_WITHEOUT}
@MmuxDefineGlobalVarSystemConstant{SEEK_CUR}
@MmuxDefineGlobalVarSystemConstant{SEEK_DATA}
@MmuxDefineGlobalVarSystemConstant{SEEK_END}
@MmuxDefineGlobalVarSystemConstant{SEEK_HOLE}
@MmuxDefineGlobalVarSystemConstant{SEEK_SET}
@MmuxDefineGlobalVarSystemConstant{S_IRGRP}
@MmuxDefineGlobalVarSystemConstant{S_IROTH}
@MmuxDefineGlobalVarSystemConstant{S_IRUSR}
@MmuxDefineGlobalVarSystemConstant{S_IRWXG}
@MmuxDefineGlobalVarSystemConstant{S_IRWXO}
@MmuxDefineGlobalVarSystemConstant{S_IRWXU}
@MmuxDefineGlobalVarSystemConstant{S_ISGID}
@MmuxDefineGlobalVarSystemConstant{S_ISUID}
@MmuxDefineGlobalVarSystemConstant{S_ISVTX}
@MmuxDefineGlobalVarSystemConstant{S_IWGRP}
@MmuxDefineGlobalVarSystemConstant{S_IWOTH}
@MmuxDefineGlobalVarSystemConstant{S_IWUSR}
@MmuxDefineGlobalVarSystemConstant{S_IXGRP}
@MmuxDefineGlobalVarSystemConstant{S_IXOTH}
@MmuxDefineGlobalVarSystemConstant{S_IXUSR}
@MmuxDefineGlobalVarSystemConstant{W_OK}
@MmuxDefineGlobalVarSystemConstant{X_OK}

@c page
@node cctypes
@chapter Interface to supported data types


@menu
* cctypes sizeof::              C language type sizes.
* cctypes limits::              C language type maximum and minimum values.
* cctypes constants::           Builtins returning constant values.
* cctypes complex::             Basic complex number builtins.
* cctypes predicates::          Type predicates.
* cctypes comparison::          Comparison builtins.
* cctypes arithmetics::         Arithmetics operation builtins.
* cctypes mathematics::         Mathematics operation builtins.
* cctypes bitwise::             Bitwise operation builtins.
* cctypes formats::             Input and output formats.
@end menu

@c page
@node cctypes sizeof
@section C language type sizes


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined; we can test this condition with @code{test -v}; to test if the
underlying platform implements the type @code{signed long long int}, we can do:

@example
if test -v mmux_sllong_SIZEOF
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarSizeof{STEM}
@defvar mmux_\STEM\_SIZEOF
Global variable holding the size, measured in bytes, of the C language type with stem @code{\STEM\}.
@end defvar

@end macro

@MmuxDefineGlobalVarSizeof{pointer}

@MmuxDefineGlobalVarSizeof{schar}
@MmuxDefineGlobalVarSizeof{uchar}
@MmuxDefineGlobalVarSizeof{sshort}
@MmuxDefineGlobalVarSizeof{ushort}
@MmuxDefineGlobalVarSizeof{sint}
@MmuxDefineGlobalVarSizeof{uint}
@MmuxDefineGlobalVarSizeof{slong}
@MmuxDefineGlobalVarSizeof{ulong}
@MmuxDefineGlobalVarSizeof{sllong}
@MmuxDefineGlobalVarSizeof{ullong}
@MmuxDefineGlobalVarSizeof{float}
@MmuxDefineGlobalVarSizeof{double}
@MmuxDefineGlobalVarSizeof{ldouble}

@MmuxDefineGlobalVarSizeof{float32}
@MmuxDefineGlobalVarSizeof{float64}
@MmuxDefineGlobalVarSizeof{float128}

@MmuxDefineGlobalVarSizeof{float32x}
@MmuxDefineGlobalVarSizeof{float64x}
@MmuxDefineGlobalVarSizeof{float128x}

@MmuxDefineGlobalVarSizeof{decimal32}
@MmuxDefineGlobalVarSizeof{decimal64}
@MmuxDefineGlobalVarSizeof{decimal128}

@MmuxDefineGlobalVarSizeof{complexf}
@MmuxDefineGlobalVarSizeof{complexd}
@MmuxDefineGlobalVarSizeof{complexld}

@MmuxDefineGlobalVarSizeof{complexf32}
@MmuxDefineGlobalVarSizeof{complexf64}
@MmuxDefineGlobalVarSizeof{complexf128}

@MmuxDefineGlobalVarSizeof{complexf32x}
@MmuxDefineGlobalVarSizeof{complexf64x}
@MmuxDefineGlobalVarSizeof{complexf128x}

@MmuxDefineGlobalVarSizeof{complexd32}
@MmuxDefineGlobalVarSizeof{complexd64}
@MmuxDefineGlobalVarSizeof{complexd128}

@MmuxDefineGlobalVarSizeof{sint8}
@MmuxDefineGlobalVarSizeof{uint8}
@MmuxDefineGlobalVarSizeof{sint16}
@MmuxDefineGlobalVarSizeof{uint16}
@MmuxDefineGlobalVarSizeof{sint32}
@MmuxDefineGlobalVarSizeof{uint32}
@MmuxDefineGlobalVarSizeof{sint64}
@MmuxDefineGlobalVarSizeof{uint64}

@MmuxDefineGlobalVarSizeof{ssize}
@MmuxDefineGlobalVarSizeof{usize}
@MmuxDefineGlobalVarSizeof{sintmax}
@MmuxDefineGlobalVarSizeof{uintmax}
@MmuxDefineGlobalVarSizeof{sintptr}
@MmuxDefineGlobalVarSizeof{uintptr}
@MmuxDefineGlobalVarSizeof{ptrdiff}
@MmuxDefineGlobalVarSizeof{mode}
@MmuxDefineGlobalVarSizeof{off}
@MmuxDefineGlobalVarSizeof{pid}
@MmuxDefineGlobalVarSizeof{uid}
@MmuxDefineGlobalVarSizeof{gid}
@MmuxDefineGlobalVarSizeof{wchar}
@MmuxDefineGlobalVarSizeof{wint}

@c page
@node cctypes limits
@section C language type maximum and minimum values


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined.  Notice that the floating--point complex C language types have neither
maximum nor minimum limits.

Some of the following variables hold the minimum value representable by a C language real number
type; this is true even for floating--point numbers: the value is the minimum negative representable
value.  This is different from the standard C language constants like @code{FLT_MIN},
@code{DBL_MIN}, @code{LDBL_MIN}, which represent some sort of minimum representable positive value.

For the unsigned number types: the minimum value is zero.

@c ------------------------------------------------------------------------

@macro MmuxDefineGlobalVarLimits{STEM,TYPE}
@defvar mmux_\STEM\_MAX
@defvarx mmux_\STEM\_MIN
Global variables holding the maximum and minimum values of the C language type @objtype{mmux_\STEM\_t}.
@end defvar

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineGlobalVarLimits{pointer}

@MmuxDefineGlobalVarLimits{schar}
@MmuxDefineGlobalVarLimits{uchar}
@MmuxDefineGlobalVarLimits{sshort}
@MmuxDefineGlobalVarLimits{ushort}
@MmuxDefineGlobalVarLimits{sint}
@MmuxDefineGlobalVarLimits{uint}
@MmuxDefineGlobalVarLimits{slong}
@MmuxDefineGlobalVarLimits{ulong}
@MmuxDefineGlobalVarLimits{sllong}
@MmuxDefineGlobalVarLimits{ullong}

@MmuxDefineGlobalVarLimits{float}
@MmuxDefineGlobalVarLimits{double}
@MmuxDefineGlobalVarLimits{ldouble}

@MmuxDefineGlobalVarLimits{float32}
@MmuxDefineGlobalVarLimits{float64}
@MmuxDefineGlobalVarLimits{float128}

@MmuxDefineGlobalVarLimits{float32x}
@MmuxDefineGlobalVarLimits{float64x}
@MmuxDefineGlobalVarLimits{float128x}

@MmuxDefineGlobalVarLimits{decimal32}
@MmuxDefineGlobalVarLimits{decimal64}
@MmuxDefineGlobalVarLimits{decimal128}

@MmuxDefineGlobalVarLimits{sint8}
@MmuxDefineGlobalVarLimits{uint8}
@MmuxDefineGlobalVarLimits{sint16}
@MmuxDefineGlobalVarLimits{uint16}
@MmuxDefineGlobalVarLimits{sint32}
@MmuxDefineGlobalVarLimits{uint32}
@MmuxDefineGlobalVarLimits{sint64}
@MmuxDefineGlobalVarLimits{uint64}

@MmuxDefineGlobalVarLimits{ssize}
@MmuxDefineGlobalVarLimits{usize}
@MmuxDefineGlobalVarLimits{sintmax}
@MmuxDefineGlobalVarLimits{uintmax}
@MmuxDefineGlobalVarLimits{sintptr}
@MmuxDefineGlobalVarLimits{uintptr}
@MmuxDefineGlobalVarLimits{ptrdiff}
@MmuxDefineGlobalVarLimits{mode}
@MmuxDefineGlobalVarLimits{off}
@MmuxDefineGlobalVarLimits{pid}
@MmuxDefineGlobalVarLimits{uid}
@MmuxDefineGlobalVarLimits{gid}
@MmuxDefineGlobalVarLimits{wchar}
@MmuxDefineGlobalVarLimits{wint}

@c page
@node cctypes constants
@section Builtins returning constant values


@macro MmuxDefineConstantBuiltin{STEM,FUNCSTEM,EXPR}
@deffn Builtin mmux_\STEM\_constant_\FUNCSTEM\ @var{ROPVAR}
Store in the shell variable @var{ROPVAR} a constant value corresponding to @math{\EXPR\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineConstantBuiltins{STEM}
@MmuxDefineConstantBuiltin{\STEM\,E,e}
@MmuxDefineConstantBuiltin{\STEM\,LOG2E,log_2(e)}
@MmuxDefineConstantBuiltin{\STEM\,LOG10E,log_10(e)}
@MmuxDefineConstantBuiltin{\STEM\,LN2,ln(2)}
@MmuxDefineConstantBuiltin{\STEM\,LN10,ln(10)}
@MmuxDefineConstantBuiltin{\STEM\,PI,pi}
@MmuxDefineConstantBuiltin{\STEM\,PI_2,pi/2}
@MmuxDefineConstantBuiltin{\STEM\,PI_4,pi/4}
@MmuxDefineConstantBuiltin{\STEM\,1_PI,1/pi}
@MmuxDefineConstantBuiltin{\STEM\,2_PI,2/pi}
@MmuxDefineConstantBuiltin{\STEM\,2_SQRTPI,2/sqrt(pi)}
@MmuxDefineConstantBuiltin{\STEM\,SQRT2,sqrt(2)}
@MmuxDefineConstantBuiltin{\STEM\,SQRT1_2,sqrt(1/2)}
@end macro

@c ------------------------------------------------------------------------

@MmuxDefineConstantBuiltins{float}
@MmuxDefineConstantBuiltins{double}
@MmuxDefineConstantBuiltins{ldouble}

@MmuxDefineConstantBuiltins{float32}
@MmuxDefineConstantBuiltins{float64}
@MmuxDefineConstantBuiltins{float128}

@MmuxDefineConstantBuiltins{float32x}
@MmuxDefineConstantBuiltins{float64x}
@MmuxDefineConstantBuiltins{float128x}

@MmuxDefineConstantBuiltins{decimal32}
@MmuxDefineConstantBuiltins{decimal64}
@MmuxDefineConstantBuiltins{decimal128}

@c page
@node cctypes complex
@section Basic complex number builtins


@menu
* cctypes complex make::        Constructing complex numbers.
* cctypes complex parts::       Extracting the real and imaginary parts.
* cctypes complex arg::         Computing the argument value.
* cctypes complex conj::        Computing the complex conjugate value.
@end menu

@c page
@node cctypes complex make
@subsection Constructing complex numbers


To construct a complex number from its real and imaginary parts, we do:

@example
declare ROP

mmux_complexd_make_rectangular ROP '1.2' '3.4'
"$ROP"  @result{} (1.2)+i* types(3.4)
@end example



@macro MmuxDefineComplexMakeRectangularBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_make_rectangular @var{ROPVAR} @var{REP} @var{IMP}
Construct a complex number, of type @objtype{\CPLXSTEM\}, from the real and imaginary parts
@var{REP} and @var{IMP}, of type @objtype{\REALSTEM\}.  Store a string representation of the result
in the shell variable @var{ROPVAR}.
@end deffn

@end macro

@MmuxDefineComplexMakeRectangularBuiltin{complexf, float}
@MmuxDefineComplexMakeRectangularBuiltin{complexd, double}
@MmuxDefineComplexMakeRectangularBuiltin{complexld, ldouble}

@MmuxDefineComplexMakeRectangularBuiltin{complexf32, float32}
@MmuxDefineComplexMakeRectangularBuiltin{complexf64, float64}
@MmuxDefineComplexMakeRectangularBuiltin{complexf128, float128}

@MmuxDefineComplexMakeRectangularBuiltin{complexf32x, float32x}
@MmuxDefineComplexMakeRectangularBuiltin{complexf64x, float64x}
@MmuxDefineComplexMakeRectangularBuiltin{complexf128x, float128x}

@MmuxDefineComplexMakeRectangularBuiltin{complexd32, decimal32}
@MmuxDefineComplexMakeRectangularBuiltin{complexd64, decimal64}
@MmuxDefineComplexMakeRectangularBuiltin{complexd128, decimal128}

@c page
@node cctypes complex parts
@subsection Extracting the real and imaginary parts


To extract the real and imaginary parts of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' REP IMP

mmux_complexd_real_part REP "$Z"
mmux_complexd_real_part IMP "$Z"
"$REP"  @result{} 1.2
"$IMP"  @result{} 3.4
@end example


@macro MmuxDefineComplexRealImagPartBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_real_part @var{REPVAR} @var{OP}
@deffnx Builtin mmux_\CPLXSTEM\_imag_part @var{IMPVAR} @var{OP}
Extract the real or imaginary parts, which will be of type @objtype{\REALSTEM\}, from the complex
number @var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell
variable @var{REPVAR} or @var{IMPVAR}.
@end deffn

@end macro

@MmuxDefineComplexRealImagPartBuiltin{complexf, float}
@MmuxDefineComplexRealImagPartBuiltin{complexd, double}
@MmuxDefineComplexRealImagPartBuiltin{complexld, ldouble}

@MmuxDefineComplexRealImagPartBuiltin{complexf32, float32}
@MmuxDefineComplexRealImagPartBuiltin{complexf64, float64}
@MmuxDefineComplexRealImagPartBuiltin{complexf128, float128}

@MmuxDefineComplexRealImagPartBuiltin{complexf32x, float32x}
@MmuxDefineComplexRealImagPartBuiltin{complexf64x, float64x}
@MmuxDefineComplexRealImagPartBuiltin{complexf128x, float128x}

@MmuxDefineComplexRealImagPartBuiltin{complexd32, decimal32}
@MmuxDefineComplexRealImagPartBuiltin{complexd64, decimal64}
@MmuxDefineComplexRealImagPartBuiltin{complexd128, decimal128}

@c page
@node cctypes complex arg
@subsection Computing the argument value


To compute the argument value of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' A

mmux_complexd_arg A "$Z"
"$A"    @result{} 1.231503712340852
@end example


@macro MmuxDefineComplexArgBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_arg @var{ARGVAR} @var{OP}
Extract the argument value, which will be of type @objtype{\REALSTEM\}, from the complex number
@var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell variable
@var{ARGVAR}.
@end deffn

@end macro

@MmuxDefineComplexArgBuiltin{complexf, float}
@MmuxDefineComplexArgBuiltin{complexd, double}
@MmuxDefineComplexArgBuiltin{complexld, ldouble}

@MmuxDefineComplexArgBuiltin{complexf32, float32}
@MmuxDefineComplexArgBuiltin{complexf64, float64}
@MmuxDefineComplexArgBuiltin{complexf128, float128}

@MmuxDefineComplexArgBuiltin{complexf32x, float32x}
@MmuxDefineComplexArgBuiltin{complexf64x, float64x}
@MmuxDefineComplexArgBuiltin{complexf128x, float128x}

@MmuxDefineComplexArgBuiltin{complexd32, decimal32}
@MmuxDefineComplexArgBuiltin{complexd64, decimal64}
@MmuxDefineComplexArgBuiltin{complexd128, decimal128}

@c page
@node cctypes complex conj
@subsection Computing the complex conjugate value


To compute the complex conjugate value of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' W

mmux_complexd_conj W "$Z"
"$W"    @result{} (1.2)+i* types(-3.4)
@end example


@macro MmuxDefineComplexConjBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_conj @var{CONJVAR} @var{OP}
Compute the complex conjugate value, which will be of type @objtype{\CPLXSTEM\}, from the complex
number @var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell
variable @var{CONJVAR}.
@end deffn

@end macro

@MmuxDefineComplexConjBuiltin{complexf, float}
@MmuxDefineComplexConjBuiltin{complexd, double}
@MmuxDefineComplexConjBuiltin{complexld, ldouble}

@MmuxDefineComplexConjBuiltin{complexf32, float32}
@MmuxDefineComplexConjBuiltin{complexf64, float64}
@MmuxDefineComplexConjBuiltin{complexf128, float128}

@MmuxDefineComplexConjBuiltin{complexf32x, float32x}
@MmuxDefineComplexConjBuiltin{complexf64x, float64x}
@MmuxDefineComplexConjBuiltin{complexf128x, float128x}

@MmuxDefineComplexConjBuiltin{complexd32, decimal32}
@MmuxDefineComplexConjBuiltin{complexd64, decimal64}
@MmuxDefineComplexConjBuiltin{complexd128, decimal128}

@c page
@node cctypes predicates
@section Type predicates


@menu
* cctypes predicates stringrep::      String representation predicates.
* cctypes predicates zero::           Zero number predicates.
* cctypes predicates positive::       Positive number predicates.
* cctypes predicates negative::       Negative number predicates.
* cctypes predicates non-positive::   Non-positive number predicates.
* cctypes predicates non-negative::   Non-negative number predicates.
* cctypes predicates nan::            Not-a-number predicates.
* cctypes predicates infinite::       Infinite number predicates.
@end menu

@c page
@node cctypes predicates stringrep
@subsection String representation predicates


@macro MmuxDefineTypePredicateStringrepBuiltin{STEM}
@deffn Builtin mmux_string_is_\STEM\ @var{STRING_REP}
Return true if @var{STRING_REP} is a valid string representation for the C language type; otherwise
return false.
@end deffn

@end macro

@MmuxDefineTypePredicateStringrepBuiltin{pointer}

@MmuxDefineTypePredicateStringrepBuiltin{schar}
@MmuxDefineTypePredicateStringrepBuiltin{uchar}
@MmuxDefineTypePredicateStringrepBuiltin{sshort}
@MmuxDefineTypePredicateStringrepBuiltin{ushort}
@MmuxDefineTypePredicateStringrepBuiltin{sint}
@MmuxDefineTypePredicateStringrepBuiltin{uint}
@MmuxDefineTypePredicateStringrepBuiltin{slong}
@MmuxDefineTypePredicateStringrepBuiltin{ulong}
@MmuxDefineTypePredicateStringrepBuiltin{sllong}
@MmuxDefineTypePredicateStringrepBuiltin{ullong}
@MmuxDefineTypePredicateStringrepBuiltin{float}
@MmuxDefineTypePredicateStringrepBuiltin{double}
@MmuxDefineTypePredicateStringrepBuiltin{ldouble}

@MmuxDefineTypePredicateStringrepBuiltin{float32}
@MmuxDefineTypePredicateStringrepBuiltin{float64}
@MmuxDefineTypePredicateStringrepBuiltin{float128}

@MmuxDefineTypePredicateStringrepBuiltin{float32x}
@MmuxDefineTypePredicateStringrepBuiltin{float64x}
@MmuxDefineTypePredicateStringrepBuiltin{float128x}

@MmuxDefineTypePredicateStringrepBuiltin{decimal32}
@MmuxDefineTypePredicateStringrepBuiltin{decimal64}
@MmuxDefineTypePredicateStringrepBuiltin{decimal128}

@MmuxDefineTypePredicateStringrepBuiltin{complexf}
@MmuxDefineTypePredicateStringrepBuiltin{complexd}
@MmuxDefineTypePredicateStringrepBuiltin{complexld}

@MmuxDefineTypePredicateStringrepBuiltin{complexf32}
@MmuxDefineTypePredicateStringrepBuiltin{complexf64}
@MmuxDefineTypePredicateStringrepBuiltin{complexf128}

@MmuxDefineTypePredicateStringrepBuiltin{complexf32x}
@MmuxDefineTypePredicateStringrepBuiltin{complexf64x}
@MmuxDefineTypePredicateStringrepBuiltin{complexf128x}

@MmuxDefineTypePredicateStringrepBuiltin{complexd32}
@MmuxDefineTypePredicateStringrepBuiltin{complexd64}
@MmuxDefineTypePredicateStringrepBuiltin{complexd128}

@MmuxDefineTypePredicateStringrepBuiltin{sint8}
@MmuxDefineTypePredicateStringrepBuiltin{uint8}
@MmuxDefineTypePredicateStringrepBuiltin{sint16}
@MmuxDefineTypePredicateStringrepBuiltin{uint16}
@MmuxDefineTypePredicateStringrepBuiltin{sint32}
@MmuxDefineTypePredicateStringrepBuiltin{uint32}
@MmuxDefineTypePredicateStringrepBuiltin{sint64}
@MmuxDefineTypePredicateStringrepBuiltin{uint64}

@MmuxDefineTypePredicateStringrepBuiltin{ssize}
@MmuxDefineTypePredicateStringrepBuiltin{usize}
@MmuxDefineTypePredicateStringrepBuiltin{sintmax}
@MmuxDefineTypePredicateStringrepBuiltin{uintmax}
@MmuxDefineTypePredicateStringrepBuiltin{sintptr}
@MmuxDefineTypePredicateStringrepBuiltin{uintptr}
@MmuxDefineTypePredicateStringrepBuiltin{mode}
@MmuxDefineTypePredicateStringrepBuiltin{off}
@MmuxDefineTypePredicateStringrepBuiltin{pid}
@MmuxDefineTypePredicateStringrepBuiltin{uid}
@MmuxDefineTypePredicateStringrepBuiltin{gid}
@MmuxDefineTypePredicateStringrepBuiltin{wchar}
@MmuxDefineTypePredicateStringrepBuiltin{wint}

@c page
@node cctypes predicates zero
@subsection Zero number predicates


@macro MmuxDefineTypePredicateZeroBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_zero @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
zero number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateZeroBuiltin{pointer}

@MmuxDefineTypePredicateZeroBuiltin{schar}
@MmuxDefineTypePredicateZeroBuiltin{uchar}
@MmuxDefineTypePredicateZeroBuiltin{sshort}
@MmuxDefineTypePredicateZeroBuiltin{ushort}
@MmuxDefineTypePredicateZeroBuiltin{sint}
@MmuxDefineTypePredicateZeroBuiltin{uint}
@MmuxDefineTypePredicateZeroBuiltin{slong}
@MmuxDefineTypePredicateZeroBuiltin{ulong}
@MmuxDefineTypePredicateZeroBuiltin{sllong}
@MmuxDefineTypePredicateZeroBuiltin{ullong}
@MmuxDefineTypePredicateZeroBuiltin{float}
@MmuxDefineTypePredicateZeroBuiltin{double}
@MmuxDefineTypePredicateZeroBuiltin{ldouble}

@MmuxDefineTypePredicateZeroBuiltin{float32}
@MmuxDefineTypePredicateZeroBuiltin{float64}
@MmuxDefineTypePredicateZeroBuiltin{float128}

@MmuxDefineTypePredicateZeroBuiltin{float32x}
@MmuxDefineTypePredicateZeroBuiltin{float64x}
@MmuxDefineTypePredicateZeroBuiltin{float128x}

@MmuxDefineTypePredicateZeroBuiltin{decimal32}
@MmuxDefineTypePredicateZeroBuiltin{decimal64}
@MmuxDefineTypePredicateZeroBuiltin{decimal128}

@MmuxDefineTypePredicateZeroBuiltin{complexf}
@MmuxDefineTypePredicateZeroBuiltin{complexd}
@MmuxDefineTypePredicateZeroBuiltin{complexld}

@MmuxDefineTypePredicateZeroBuiltin{complexf32}
@MmuxDefineTypePredicateZeroBuiltin{complexf64}
@MmuxDefineTypePredicateZeroBuiltin{complexf128}

@MmuxDefineTypePredicateZeroBuiltin{complexf32x}
@MmuxDefineTypePredicateZeroBuiltin{complexf64x}
@MmuxDefineTypePredicateZeroBuiltin{complexf128x}

@MmuxDefineTypePredicateZeroBuiltin{complexd32}
@MmuxDefineTypePredicateZeroBuiltin{complexd64}
@MmuxDefineTypePredicateZeroBuiltin{complexd128}

@MmuxDefineTypePredicateZeroBuiltin{sint8}
@MmuxDefineTypePredicateZeroBuiltin{uint8}
@MmuxDefineTypePredicateZeroBuiltin{sint16}
@MmuxDefineTypePredicateZeroBuiltin{uint16}
@MmuxDefineTypePredicateZeroBuiltin{sint32}
@MmuxDefineTypePredicateZeroBuiltin{uint32}
@MmuxDefineTypePredicateZeroBuiltin{sint64}
@MmuxDefineTypePredicateZeroBuiltin{uint64}

@MmuxDefineTypePredicateZeroBuiltin{ssize}
@MmuxDefineTypePredicateZeroBuiltin{usize}
@MmuxDefineTypePredicateZeroBuiltin{sintmax}
@MmuxDefineTypePredicateZeroBuiltin{uintmax}
@MmuxDefineTypePredicateZeroBuiltin{sintptr}
@MmuxDefineTypePredicateZeroBuiltin{uintptr}
@MmuxDefineTypePredicateZeroBuiltin{mode}
@MmuxDefineTypePredicateZeroBuiltin{off}
@MmuxDefineTypePredicateZeroBuiltin{pid}
@MmuxDefineTypePredicateZeroBuiltin{uid}
@MmuxDefineTypePredicateZeroBuiltin{gid}
@MmuxDefineTypePredicateZeroBuiltin{wchar}
@MmuxDefineTypePredicateZeroBuiltin{wint}

@c page
@node cctypes predicates positive
@subsection Positive number predicates


@macro MmuxDefineTypePredicatePositiveBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_positive @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
positive number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicatePositiveBuiltin{pointer}

@MmuxDefineTypePredicatePositiveBuiltin{schar}
@MmuxDefineTypePredicatePositiveBuiltin{uchar}
@MmuxDefineTypePredicatePositiveBuiltin{sshort}
@MmuxDefineTypePredicatePositiveBuiltin{ushort}
@MmuxDefineTypePredicatePositiveBuiltin{sint}
@MmuxDefineTypePredicatePositiveBuiltin{uint}
@MmuxDefineTypePredicatePositiveBuiltin{slong}
@MmuxDefineTypePredicatePositiveBuiltin{ulong}
@MmuxDefineTypePredicatePositiveBuiltin{sllong}
@MmuxDefineTypePredicatePositiveBuiltin{ullong}

@MmuxDefineTypePredicatePositiveBuiltin{float}
@MmuxDefineTypePredicatePositiveBuiltin{double}
@MmuxDefineTypePredicatePositiveBuiltin{ldouble}

@MmuxDefineTypePredicatePositiveBuiltin{float32}
@MmuxDefineTypePredicatePositiveBuiltin{float64}
@MmuxDefineTypePredicatePositiveBuiltin{float128}

@MmuxDefineTypePredicatePositiveBuiltin{float32x}
@MmuxDefineTypePredicatePositiveBuiltin{float64x}
@MmuxDefineTypePredicatePositiveBuiltin{float128x}

@MmuxDefineTypePredicatePositiveBuiltin{decimal32}
@MmuxDefineTypePredicatePositiveBuiltin{decimal64}
@MmuxDefineTypePredicatePositiveBuiltin{decimal128}

@MmuxDefineTypePredicatePositiveBuiltin{sint8}
@MmuxDefineTypePredicatePositiveBuiltin{uint8}
@MmuxDefineTypePredicatePositiveBuiltin{sint16}
@MmuxDefineTypePredicatePositiveBuiltin{uint16}
@MmuxDefineTypePredicatePositiveBuiltin{sint32}
@MmuxDefineTypePredicatePositiveBuiltin{uint32}
@MmuxDefineTypePredicatePositiveBuiltin{sint64}
@MmuxDefineTypePredicatePositiveBuiltin{uint64}

@MmuxDefineTypePredicatePositiveBuiltin{ssize}
@MmuxDefineTypePredicatePositiveBuiltin{usize}
@MmuxDefineTypePredicatePositiveBuiltin{sintmax}
@MmuxDefineTypePredicatePositiveBuiltin{uintmax}
@MmuxDefineTypePredicatePositiveBuiltin{sintptr}
@MmuxDefineTypePredicatePositiveBuiltin{uintptr}
@MmuxDefineTypePredicatePositiveBuiltin{mode}
@MmuxDefineTypePredicatePositiveBuiltin{off}
@MmuxDefineTypePredicatePositiveBuiltin{pid}
@MmuxDefineTypePredicatePositiveBuiltin{uid}
@MmuxDefineTypePredicatePositiveBuiltin{gid}
@MmuxDefineTypePredicatePositiveBuiltin{wchar}
@MmuxDefineTypePredicatePositiveBuiltin{wint}

@c page
@node cctypes predicates negative
@subsection Negative number predicates


@macro MmuxDefineTypePredicateNegativeBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_negative @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
negative number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNegativeBuiltin{pointer}

@MmuxDefineTypePredicateNegativeBuiltin{schar}
@MmuxDefineTypePredicateNegativeBuiltin{uchar}
@MmuxDefineTypePredicateNegativeBuiltin{sshort}
@MmuxDefineTypePredicateNegativeBuiltin{ushort}
@MmuxDefineTypePredicateNegativeBuiltin{sint}
@MmuxDefineTypePredicateNegativeBuiltin{uint}
@MmuxDefineTypePredicateNegativeBuiltin{slong}
@MmuxDefineTypePredicateNegativeBuiltin{ulong}
@MmuxDefineTypePredicateNegativeBuiltin{sllong}
@MmuxDefineTypePredicateNegativeBuiltin{ullong}

@MmuxDefineTypePredicateNegativeBuiltin{float}
@MmuxDefineTypePredicateNegativeBuiltin{double}
@MmuxDefineTypePredicateNegativeBuiltin{ldouble}

@MmuxDefineTypePredicateNegativeBuiltin{float32}
@MmuxDefineTypePredicateNegativeBuiltin{float64}
@MmuxDefineTypePredicateNegativeBuiltin{float128}

@MmuxDefineTypePredicateNegativeBuiltin{float32x}
@MmuxDefineTypePredicateNegativeBuiltin{float64x}
@MmuxDefineTypePredicateNegativeBuiltin{float128x}

@MmuxDefineTypePredicateNegativeBuiltin{float32}
@MmuxDefineTypePredicateNegativeBuiltin{float64}
@MmuxDefineTypePredicateNegativeBuiltin{float128}

@MmuxDefineTypePredicateNegativeBuiltin{float32x}
@MmuxDefineTypePredicateNegativeBuiltin{float64x}
@MmuxDefineTypePredicateNegativeBuiltin{float128x}

@MmuxDefineTypePredicateNegativeBuiltin{decimal32}
@MmuxDefineTypePredicateNegativeBuiltin{decimal64}
@MmuxDefineTypePredicateNegativeBuiltin{decimal128}

@MmuxDefineTypePredicateNegativeBuiltin{sint8}
@MmuxDefineTypePredicateNegativeBuiltin{uint8}
@MmuxDefineTypePredicateNegativeBuiltin{sint16}
@MmuxDefineTypePredicateNegativeBuiltin{uint16}
@MmuxDefineTypePredicateNegativeBuiltin{sint32}
@MmuxDefineTypePredicateNegativeBuiltin{uint32}
@MmuxDefineTypePredicateNegativeBuiltin{sint64}
@MmuxDefineTypePredicateNegativeBuiltin{uint64}

@MmuxDefineTypePredicateNegativeBuiltin{ssize}
@MmuxDefineTypePredicateNegativeBuiltin{usize}
@MmuxDefineTypePredicateNegativeBuiltin{sintmax}
@MmuxDefineTypePredicateNegativeBuiltin{uintmax}
@MmuxDefineTypePredicateNegativeBuiltin{sintptr}
@MmuxDefineTypePredicateNegativeBuiltin{uintptr}
@MmuxDefineTypePredicateNegativeBuiltin{mode}
@MmuxDefineTypePredicateNegativeBuiltin{off}
@MmuxDefineTypePredicateNegativeBuiltin{pid}
@MmuxDefineTypePredicateNegativeBuiltin{uid}
@MmuxDefineTypePredicateNegativeBuiltin{gid}
@MmuxDefineTypePredicateNegativeBuiltin{wchar}
@MmuxDefineTypePredicateNegativeBuiltin{wint}

@c page
@node cctypes predicates non-positive
@subsection Non--positive number predicates


@macro MmuxDefineTypePredicateNonPositiveBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_non_positive @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
non--positive number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNonPositiveBuiltin{pointer}

@MmuxDefineTypePredicateNonPositiveBuiltin{schar}
@MmuxDefineTypePredicateNonPositiveBuiltin{uchar}
@MmuxDefineTypePredicateNonPositiveBuiltin{sshort}
@MmuxDefineTypePredicateNonPositiveBuiltin{ushort}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint}
@MmuxDefineTypePredicateNonPositiveBuiltin{slong}
@MmuxDefineTypePredicateNonPositiveBuiltin{ulong}
@MmuxDefineTypePredicateNonPositiveBuiltin{sllong}
@MmuxDefineTypePredicateNonPositiveBuiltin{ullong}
@MmuxDefineTypePredicateNonPositiveBuiltin{float}
@MmuxDefineTypePredicateNonPositiveBuiltin{double}
@MmuxDefineTypePredicateNonPositiveBuiltin{ldouble}

@MmuxDefineTypePredicateNonPositiveBuiltin{float32}
@MmuxDefineTypePredicateNonPositiveBuiltin{float64}
@MmuxDefineTypePredicateNonPositiveBuiltin{float128}

@MmuxDefineTypePredicateNonPositiveBuiltin{float32x}
@MmuxDefineTypePredicateNonPositiveBuiltin{float64x}
@MmuxDefineTypePredicateNonPositiveBuiltin{float128x}

@MmuxDefineTypePredicateNonPositiveBuiltin{decimal32}
@MmuxDefineTypePredicateNonPositiveBuiltin{decimal64}
@MmuxDefineTypePredicateNonPositiveBuiltin{decimal128}

@MmuxDefineTypePredicateNonPositiveBuiltin{sint8}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint8}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint16}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint16}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint32}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint32}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint64}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint64}

@MmuxDefineTypePredicateNonPositiveBuiltin{ssize}
@MmuxDefineTypePredicateNonPositiveBuiltin{usize}
@MmuxDefineTypePredicateNonPositiveBuiltin{sintmax}
@MmuxDefineTypePredicateNonPositiveBuiltin{uintmax}
@MmuxDefineTypePredicateNonPositiveBuiltin{sintptr}
@MmuxDefineTypePredicateNonPositiveBuiltin{uintptr}
@MmuxDefineTypePredicateNonPositiveBuiltin{mode}
@MmuxDefineTypePredicateNonPositiveBuiltin{off}
@MmuxDefineTypePredicateNonPositiveBuiltin{pid}
@MmuxDefineTypePredicateNonPositiveBuiltin{uid}
@MmuxDefineTypePredicateNonPositiveBuiltin{gid}
@MmuxDefineTypePredicateNonPositiveBuiltin{wchar}
@MmuxDefineTypePredicateNonPositiveBuiltin{wint}

@c page
@node cctypes predicates non-negative
@subsection Non--negative number predicates


@macro MmuxDefineTypePredicateNonNegativeBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_non_negative @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
non--negative number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNonNegativeBuiltin{pointer}

@MmuxDefineTypePredicateNonNegativeBuiltin{schar}
@MmuxDefineTypePredicateNonNegativeBuiltin{uchar}
@MmuxDefineTypePredicateNonNegativeBuiltin{sshort}
@MmuxDefineTypePredicateNonNegativeBuiltin{ushort}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint}
@MmuxDefineTypePredicateNonNegativeBuiltin{slong}
@MmuxDefineTypePredicateNonNegativeBuiltin{ulong}
@MmuxDefineTypePredicateNonNegativeBuiltin{sllong}
@MmuxDefineTypePredicateNonNegativeBuiltin{ullong}
@MmuxDefineTypePredicateNonNegativeBuiltin{float}
@MmuxDefineTypePredicateNonNegativeBuiltin{double}
@MmuxDefineTypePredicateNonNegativeBuiltin{ldouble}

@MmuxDefineTypePredicateNonNegativeBuiltin{float32}
@MmuxDefineTypePredicateNonNegativeBuiltin{float64}
@MmuxDefineTypePredicateNonNegativeBuiltin{float128}

@MmuxDefineTypePredicateNonNegativeBuiltin{float32x}
@MmuxDefineTypePredicateNonNegativeBuiltin{float64x}
@MmuxDefineTypePredicateNonNegativeBuiltin{float128x}

@MmuxDefineTypePredicateNonNegativeBuiltin{decimal32}
@MmuxDefineTypePredicateNonNegativeBuiltin{decimal64}
@MmuxDefineTypePredicateNonNegativeBuiltin{decimal128}

@MmuxDefineTypePredicateNonNegativeBuiltin{sint8}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint8}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint16}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint16}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint32}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint32}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint64}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint64}

@MmuxDefineTypePredicateNonNegativeBuiltin{ssize}
@MmuxDefineTypePredicateNonNegativeBuiltin{usize}
@MmuxDefineTypePredicateNonNegativeBuiltin{sintmax}
@MmuxDefineTypePredicateNonNegativeBuiltin{uintmax}
@MmuxDefineTypePredicateNonNegativeBuiltin{sintptr}
@MmuxDefineTypePredicateNonNegativeBuiltin{uintptr}
@MmuxDefineTypePredicateNonNegativeBuiltin{mode}
@MmuxDefineTypePredicateNonNegativeBuiltin{off}
@MmuxDefineTypePredicateNonNegativeBuiltin{pid}
@MmuxDefineTypePredicateNonNegativeBuiltin{uid}
@MmuxDefineTypePredicateNonNegativeBuiltin{gid}
@MmuxDefineTypePredicateNonNegativeBuiltin{wchar}
@MmuxDefineTypePredicateNonNegativeBuiltin{wint}

@c page
@node cctypes predicates nan
@subsection Not--a--number predicates


@macro MmuxDefineTypePredicateNanBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_nan @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
not--a--number value; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNanBuiltin{pointer}

@MmuxDefineTypePredicateNanBuiltin{schar}
@MmuxDefineTypePredicateNanBuiltin{uchar}
@MmuxDefineTypePredicateNanBuiltin{sshort}
@MmuxDefineTypePredicateNanBuiltin{ushort}
@MmuxDefineTypePredicateNanBuiltin{sint}
@MmuxDefineTypePredicateNanBuiltin{uint}
@MmuxDefineTypePredicateNanBuiltin{slong}
@MmuxDefineTypePredicateNanBuiltin{ulong}
@MmuxDefineTypePredicateNanBuiltin{sllong}
@MmuxDefineTypePredicateNanBuiltin{ullong}
@MmuxDefineTypePredicateNanBuiltin{float}
@MmuxDefineTypePredicateNanBuiltin{double}
@MmuxDefineTypePredicateNanBuiltin{ldouble}

@MmuxDefineTypePredicateNanBuiltin{float32}
@MmuxDefineTypePredicateNanBuiltin{float64}
@MmuxDefineTypePredicateNanBuiltin{float128}

@MmuxDefineTypePredicateNanBuiltin{float32x}
@MmuxDefineTypePredicateNanBuiltin{float64x}
@MmuxDefineTypePredicateNanBuiltin{float128x}

@MmuxDefineTypePredicateNanBuiltin{decimal32}
@MmuxDefineTypePredicateNanBuiltin{decimal64}
@MmuxDefineTypePredicateNanBuiltin{decimal128}

@MmuxDefineTypePredicateNanBuiltin{complexf}
@MmuxDefineTypePredicateNanBuiltin{complexd}
@MmuxDefineTypePredicateNanBuiltin{complexld}

@MmuxDefineTypePredicateNanBuiltin{complexf32}
@MmuxDefineTypePredicateNanBuiltin{complexf64}
@MmuxDefineTypePredicateNanBuiltin{complexf128}

@MmuxDefineTypePredicateNanBuiltin{complexf32x}
@MmuxDefineTypePredicateNanBuiltin{complexf64x}
@MmuxDefineTypePredicateNanBuiltin{complexf128x}

@MmuxDefineTypePredicateNanBuiltin{complexd32}
@MmuxDefineTypePredicateNanBuiltin{complexd64}
@MmuxDefineTypePredicateNanBuiltin{complexd128}

@MmuxDefineTypePredicateNanBuiltin{sint8}
@MmuxDefineTypePredicateNanBuiltin{uint8}
@MmuxDefineTypePredicateNanBuiltin{sint16}
@MmuxDefineTypePredicateNanBuiltin{uint16}
@MmuxDefineTypePredicateNanBuiltin{sint32}
@MmuxDefineTypePredicateNanBuiltin{uint32}
@MmuxDefineTypePredicateNanBuiltin{sint64}
@MmuxDefineTypePredicateNanBuiltin{uint64}

@MmuxDefineTypePredicateNanBuiltin{ssize}
@MmuxDefineTypePredicateNanBuiltin{usize}
@MmuxDefineTypePredicateNanBuiltin{sintmax}
@MmuxDefineTypePredicateNanBuiltin{uintmax}
@MmuxDefineTypePredicateNanBuiltin{sintptr}
@MmuxDefineTypePredicateNanBuiltin{uintptr}
@MmuxDefineTypePredicateNanBuiltin{mode}
@MmuxDefineTypePredicateNanBuiltin{off}
@MmuxDefineTypePredicateNanBuiltin{pid}
@MmuxDefineTypePredicateNanBuiltin{uid}
@MmuxDefineTypePredicateNanBuiltin{gid}
@MmuxDefineTypePredicateNanBuiltin{wchar}
@MmuxDefineTypePredicateNanBuiltin{wint}

@c page
@node cctypes predicates infinite
@subsection Infinite number predicates


@macro MmuxDefineTypePredicateInfiniteBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_infinite @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents
an infinite number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateInfiniteBuiltin{pointer}

@MmuxDefineTypePredicateInfiniteBuiltin{schar}
@MmuxDefineTypePredicateInfiniteBuiltin{uchar}
@MmuxDefineTypePredicateInfiniteBuiltin{sshort}
@MmuxDefineTypePredicateInfiniteBuiltin{ushort}
@MmuxDefineTypePredicateInfiniteBuiltin{sint}
@MmuxDefineTypePredicateInfiniteBuiltin{uint}
@MmuxDefineTypePredicateInfiniteBuiltin{slong}
@MmuxDefineTypePredicateInfiniteBuiltin{ulong}
@MmuxDefineTypePredicateInfiniteBuiltin{sllong}
@MmuxDefineTypePredicateInfiniteBuiltin{ullong}
@MmuxDefineTypePredicateInfiniteBuiltin{float}
@MmuxDefineTypePredicateInfiniteBuiltin{double}
@MmuxDefineTypePredicateInfiniteBuiltin{ldouble}

@MmuxDefineTypePredicateInfiniteBuiltin{float32}
@MmuxDefineTypePredicateInfiniteBuiltin{float64}
@MmuxDefineTypePredicateInfiniteBuiltin{float128}

@MmuxDefineTypePredicateInfiniteBuiltin{float32x}
@MmuxDefineTypePredicateInfiniteBuiltin{float64x}
@MmuxDefineTypePredicateInfiniteBuiltin{float128x}

@MmuxDefineTypePredicateInfiniteBuiltin{decimal32}
@MmuxDefineTypePredicateInfiniteBuiltin{decimal64}
@MmuxDefineTypePredicateInfiniteBuiltin{decimal128}

@MmuxDefineTypePredicateInfiniteBuiltin{complexf}
@MmuxDefineTypePredicateInfiniteBuiltin{complexd}
@MmuxDefineTypePredicateInfiniteBuiltin{complexld}

@MmuxDefineTypePredicateInfiniteBuiltin{complexf32}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf64}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf128}

@MmuxDefineTypePredicateInfiniteBuiltin{complexf32x}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf64x}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf128x}

@MmuxDefineTypePredicateInfiniteBuiltin{complexd32}
@MmuxDefineTypePredicateInfiniteBuiltin{complexd64}
@MmuxDefineTypePredicateInfiniteBuiltin{complexd128}

@MmuxDefineTypePredicateInfiniteBuiltin{sint8}
@MmuxDefineTypePredicateInfiniteBuiltin{uint8}
@MmuxDefineTypePredicateInfiniteBuiltin{sint16}
@MmuxDefineTypePredicateInfiniteBuiltin{uint16}
@MmuxDefineTypePredicateInfiniteBuiltin{sint32}
@MmuxDefineTypePredicateInfiniteBuiltin{uint32}
@MmuxDefineTypePredicateInfiniteBuiltin{sint64}
@MmuxDefineTypePredicateInfiniteBuiltin{uint64}

@MmuxDefineTypePredicateInfiniteBuiltin{ssize}
@MmuxDefineTypePredicateInfiniteBuiltin{usize}
@MmuxDefineTypePredicateInfiniteBuiltin{sintmax}
@MmuxDefineTypePredicateInfiniteBuiltin{uintmax}
@MmuxDefineTypePredicateInfiniteBuiltin{sintptr}
@MmuxDefineTypePredicateInfiniteBuiltin{uintptr}
@MmuxDefineTypePredicateInfiniteBuiltin{mode}
@MmuxDefineTypePredicateInfiniteBuiltin{off}
@MmuxDefineTypePredicateInfiniteBuiltin{pid}
@MmuxDefineTypePredicateInfiniteBuiltin{uid}
@MmuxDefineTypePredicateInfiniteBuiltin{gid}
@MmuxDefineTypePredicateInfiniteBuiltin{wchar}
@MmuxDefineTypePredicateInfiniteBuiltin{wint}

@c page
@node cctypes comparison
@section Comparison builtins


@menu
* cctypes comparison exact::          Exact comparison builtins.
* cctypes comparison approximate::    Approximate comparison builtins.
* cctypes comparison minmax::         Minimum and maximum selection.
@end menu

@c page
@node cctypes comparison exact
@subsection Exact comparison builtins


@gnu{} Bash already implements comparison operations for integer values, and such implementation
might be preferable to the builtins implemented by @value{PACKAGE}.  Anyway, for completeness, the
comparison operations are implemented for every supported data type.

@itemize
@item
The @samp{equal} builtins return true if all the operands (of which only @varo{OP} is mandatory) are
equal:

@example
@varo{OP} == @var{OP} == @dots{}
@end example

@item
The @samp{greater} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} > @var{OP} > @dots{}
@end example

@item
The @samp{less} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} < @var{OP} < @dots{}
@end example

@item
The @samp{greater_equal} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} >= @var{OP} >= @dots{}
@end example

@item
The @samp{less_equal} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} <= @var{OP} <= @dots{}
@end example
@end itemize


@macro MmuxDefineTypeComparisonExactBuiltin{STEM}
@deffn Builtin mmux_\STEM\_equal @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_greater @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_less @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_greater_equal @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_less_equal @varo{OP} @var{OP} @dots{}
Perform the comparison operations between values of type @objtype{\STEM\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeComparisonExactComplexBuiltin{STEM}
@deffn Builtin mmux_\STEM\_equal @varo{OP} @var{OP} @dots{}
Perform the comparison operations between values of type @objtype{\STEM\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineTypeComparisonExactBuiltin{pointer}

@MmuxDefineTypeComparisonExactBuiltin{schar}
@MmuxDefineTypeComparisonExactBuiltin{uchar}
@MmuxDefineTypeComparisonExactBuiltin{sshort}
@MmuxDefineTypeComparisonExactBuiltin{ushort}
@MmuxDefineTypeComparisonExactBuiltin{sint}
@MmuxDefineTypeComparisonExactBuiltin{uint}
@MmuxDefineTypeComparisonExactBuiltin{slong}
@MmuxDefineTypeComparisonExactBuiltin{ulong}
@MmuxDefineTypeComparisonExactBuiltin{sllong}
@MmuxDefineTypeComparisonExactBuiltin{ullong}
@MmuxDefineTypeComparisonExactBuiltin{float}
@MmuxDefineTypeComparisonExactBuiltin{double}
@MmuxDefineTypeComparisonExactBuiltin{ldouble}

@MmuxDefineTypeComparisonExactBuiltin{float32}
@MmuxDefineTypeComparisonExactBuiltin{float64}
@MmuxDefineTypeComparisonExactBuiltin{float128}

@MmuxDefineTypeComparisonExactBuiltin{float32x}
@MmuxDefineTypeComparisonExactBuiltin{float64x}
@MmuxDefineTypeComparisonExactBuiltin{float128x}

@MmuxDefineTypeComparisonExactBuiltin{decimal32}
@MmuxDefineTypeComparisonExactBuiltin{decimal64}
@MmuxDefineTypeComparisonExactBuiltin{decimal128}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexf}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexd}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexld}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexf32}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf64}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf128}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexf32x}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf64x}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf128x}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexd32}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexd64}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexd128}

@MmuxDefineTypeComparisonExactBuiltin{sint8}
@MmuxDefineTypeComparisonExactBuiltin{uint8}
@MmuxDefineTypeComparisonExactBuiltin{sint16}
@MmuxDefineTypeComparisonExactBuiltin{uint16}
@MmuxDefineTypeComparisonExactBuiltin{sint32}
@MmuxDefineTypeComparisonExactBuiltin{uint32}
@MmuxDefineTypeComparisonExactBuiltin{sint64}
@MmuxDefineTypeComparisonExactBuiltin{uint64}

@MmuxDefineTypeComparisonExactBuiltin{ssize}
@MmuxDefineTypeComparisonExactBuiltin{usize}
@MmuxDefineTypeComparisonExactBuiltin{sintmax}
@MmuxDefineTypeComparisonExactBuiltin{uintmax}
@MmuxDefineTypeComparisonExactBuiltin{sintptr}
@MmuxDefineTypeComparisonExactBuiltin{uintptr}
@MmuxDefineTypeComparisonExactBuiltin{mode}
@MmuxDefineTypeComparisonExactBuiltin{off}
@MmuxDefineTypeComparisonExactBuiltin{pid}
@MmuxDefineTypeComparisonExactBuiltin{uid}
@MmuxDefineTypeComparisonExactBuiltin{gid}
@MmuxDefineTypeComparisonExactBuiltin{wchar}
@MmuxDefineTypeComparisonExactBuiltin{wint}

@c page
@node cctypes comparison approximate
@subsection Approximate comparison builtins


@menu
* cctypes comparison approximate absmargin::  Absolute margin criterion.
* cctypes comparison approximate relepsilon:: Relative epsilon criterion.
@end menu

@c page
@node cctypes comparison approximate absmargin
@subsubsection Absolute margin criterion


To compare two floating--point numbers with the criterion of the absolute margin, we do:

@example
function doit () @{
    declare -r ABSOLUTE_MARGIN_FLOAT='0.1'

    mmux_float_equal_absmargin '1.0' '1.02'       @result{} 0
    mmux_float_equal_absmargin '1.0' '1.3'        @result{} 1
@}
@end example


@deffn Builtin mmux_float_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_double_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_ldouble_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexld_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal128_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd128_equal_absmargin @varo{OP} @var{OP} @dots{}
Perform the comparison operations between operands of the named type; when the comparison predicate
is satisfied: return true; otherwise return false.

The argument @varo{OP} is the only mandatory one; when only this argument is present: the return
value is true.

When multiple operands are present: @varo{OP} is compared with all the other operands in turn.  When
comparing real numbers, the predicate is:

@example
abs(@varo{OP} - @var{OP}) <= abs(@var{MARGIN})
@end example

@noindent
when comparing complex numbers, the predicate is:

@example
abs(@varo{OP_RE} - @var{OP_RE}) <= abs(@var{MARGIN_RE}) &&
abs(@varo{OP_IM} - @var{OP_IM}) <= abs(@var{MARGIN_IM})
@end example

@noindent
where: @var{MARGIN} is the value read from the shell variable @env{ABSOLUTE_MARGIN_STEM};
@code{STEM} is the stem of the numerical type; @varo{OP_RE}, @var{OP_RE}, @var{MARGIN_RE} are the
real parts; @varo{OP_IM}, @var{OP_IM}, @var{MARGIN_IM} are the imaginary parts.
@end deffn


@defvar ABSOLUTE_MARGIN_FLOAT
@defvarx ABSOLUTE_MARGIN_DOUBLE
@defvarx ABSOLUTE_MARGIN_LDOUBLE
@defvarx ABSOLUTE_MARGIN_COMPLEXF
@defvarx ABSOLUTE_MARGIN_COMPLEXD
@defvarx ABSOLUTE_MARGIN_COMPLEXLD
@defvarx ABSOLUTE_MARGIN_FLOAT32
@defvarx ABSOLUTE_MARGIN_FLOAT64
@defvarx ABSOLUTE_MARGIN_FLOAT128
@defvarx ABSOLUTE_MARGIN_FLOAT32X
@defvarx ABSOLUTE_MARGIN_FLOAT64X
@defvarx ABSOLUTE_MARGIN_FLOAT128X
@defvarx ABSOLUTE_MARGIN_DECIMAL32
@defvarx ABSOLUTE_MARGIN_DECIMAL64
@defvarx ABSOLUTE_MARGIN_DECIMAL128
@defvarx ABSOLUTE_MARGIN_COMPLEXF32
@defvarx ABSOLUTE_MARGIN_COMPLEXF64
@defvarx ABSOLUTE_MARGIN_COMPLEXF128
@defvarx ABSOLUTE_MARGIN_COMPLEXF32X
@defvarx ABSOLUTE_MARGIN_COMPLEXF64X
@defvarx ABSOLUTE_MARGIN_COMPLEXF128X
@defvarx ABSOLUTE_MARGIN_COMPLEXD32
@defvarx ABSOLUTE_MARGIN_COMPLEXD64
@defvarx ABSOLUTE_MARGIN_COMPLEXD128
Shell variables used to select the margin for the equality with absolute margin builtins.  Each
variable is used to select a margin for the named numerical type.

For real numbers: the variable holds a real number being the margin.

For complex numbers: the variable holds a complex number; its real part is the margin for comparison
of real parts; its imaginary part is the margin for comparison of imaginary parts.

When a shell variable is not set: the default margin for real numbers is @samp{1e-6}; the default
margin for complex numbers is @samp{(1e-6)+i*(1e-6)}.
@end defvar

@c page
@node cctypes comparison approximate relepsilon
@subsubsection Relative epsilon criterion


To compare two floating--point numbers with the criterion of the relative epsilon, we do:

@example
function doit () @{
    declare -r RELATIVE_EPSILON_FLOAT='0.1'

    mmux_float_equal_relepsilon '1.0' '1.02'       @result{} 0
    mmux_float_equal_relepsilon '1.0' '1.3'        @result{} 1
@}
@end example


@deffn Builtin mmux_float_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_double_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_ldouble_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexld_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal128_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd128_equal_relepsilon @varo{OP} @var{OP} @dots{}
Perform the comparison operations between operands of the named type; when the comparison predicate
is satisfied: return true; otherwise return false.

The argument @varo{OP} is the only mandatory one; when only this argument is present: the return
value is true.

When multiple operands are present: @varo{OP} is compared with all the other operands in turn.  When
comparing real numbers, the predicate is:

@example
abs(@varo{OP} - @var{OP}) <= (@var{EPSILON} * max(abs(@varo{OP}), abs(@var{OP})))
@end example

@noindent
when comparing complex numbers, the predicate is:

@example
abs(@varo{OP_RE} - @var{OP_RE}) <= (@var{EPSILON_RE} * max(abs(@varo{OP_RE}), abs(@var{OP_RE}))) &&
abs(@varo{OP_IM} - @var{OP_IM}) <= (@var{EPSILON_IM} * max(abs(@varo{OP_IM}), abs(@var{OP_IM})))
@end example

@noindent
where: @var{EPSILON} is the value read from the shell variable @env{RELATIVE_EPSILON_STEM};
@code{STEM} is the stem of the numerical type; @varo{OP_RE}, @var{OP_RE}, @var{EPSILON_RE} are the
real parts; @varo{OP_IM}, @var{OP_IM}, @var{EPSILON_IM} are the imaginary parts.
@end deffn


@defvar RELATIVE_EPSILON_FLOAT
@defvarx RELATIVE_EPSILON_DOUBLE
@defvarx RELATIVE_EPSILON_LDOUBLE
@defvarx RELATIVE_EPSILON_COMPLEXF
@defvarx RELATIVE_EPSILON_COMPLEXD
@defvarx RELATIVE_EPSILON_COMPLEXLD
@defvarx RELATIVE_EPSILON_FLOAT32
@defvarx RELATIVE_EPSILON_FLOAT64
@defvarx RELATIVE_EPSILON_FLOAT128
@defvarx RELATIVE_EPSILON_FLOAT32X
@defvarx RELATIVE_EPSILON_FLOAT64X
@defvarx RELATIVE_EPSILON_FLOAT128X
@defvarx RELATIVE_EPSILON_DECIMAL32
@defvarx RELATIVE_EPSILON_DECIMAL64
@defvarx RELATIVE_EPSILON_DECIMAL128
@defvarx RELATIVE_EPSILON_COMPLEXF32
@defvarx RELATIVE_EPSILON_COMPLEXF64
@defvarx RELATIVE_EPSILON_COMPLEXF128
@defvarx RELATIVE_EPSILON_COMPLEXF32X
@defvarx RELATIVE_EPSILON_COMPLEXF64X
@defvarx RELATIVE_EPSILON_COMPLEXF128X
@defvarx RELATIVE_EPSILON_COMPLEXD32
@defvarx RELATIVE_EPSILON_COMPLEXD64
@defvarx RELATIVE_EPSILON_COMPLEXD128
Shell variables used to select the epsilon for the equality with relative epsilon.  Each variable is
used to select an epsilon for the named numerical type.

For real numbers: the variable holds a real number being the epsilon.

For complex numbers: the variable holds a complex number; its real part is the epsilon for
comparison of real parts; its imaginary part is the epsilon for comparison of imaginary parts.

When a shell variable is not set: the default epsilon for real numbers is @samp{1e-6}; the default
epsilon for complex numbers is @samp{(1e-6)+i*(1e-6)}.
@end defvar

@c page
@node cctypes comparison minmax
@subsection Minimum and maximum selection


For all the following bultins:

@itemize
@item
Only @varo{OP} is mandatory among the @var{OP} arguments.  When only @varo{OP} is present: it is the
selected maximum or minimum.

@item
The minimum and maximum selection is performed by comparing each @var{OP} argument with @varo{OP};
when they are equal @varo{OP} is selected.
@end itemize


@macro MmuxDefineTypeMinMaxBuiltins{STEM}
@deffn Builtin mmux_\STEM\_min @var{ROPVAR} @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_max @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Select the maximum or minimum among the operands, store the result in @var{ROPVAR}.
@end deffn

@end macro

@MmuxDefineTypeMinMaxBuiltins{schar}
@MmuxDefineTypeMinMaxBuiltins{uchar}
@MmuxDefineTypeMinMaxBuiltins{sshort}
@MmuxDefineTypeMinMaxBuiltins{ushort}
@MmuxDefineTypeMinMaxBuiltins{sint}
@MmuxDefineTypeMinMaxBuiltins{uint}
@MmuxDefineTypeMinMaxBuiltins{slong}
@MmuxDefineTypeMinMaxBuiltins{ulong}
@MmuxDefineTypeMinMaxBuiltins{sllong}
@MmuxDefineTypeMinMaxBuiltins{ullong}
@MmuxDefineTypeMinMaxBuiltins{float}
@MmuxDefineTypeMinMaxBuiltins{double}
@MmuxDefineTypeMinMaxBuiltins{ldouble}

@MmuxDefineTypeMinMaxBuiltins{float32}
@MmuxDefineTypeMinMaxBuiltins{float64}
@MmuxDefineTypeMinMaxBuiltins{float128}

@MmuxDefineTypeMinMaxBuiltins{float32x}
@MmuxDefineTypeMinMaxBuiltins{float64x}
@MmuxDefineTypeMinMaxBuiltins{float128x}

@MmuxDefineTypeMinMaxBuiltins{decimal32}
@MmuxDefineTypeMinMaxBuiltins{decimal64}
@MmuxDefineTypeMinMaxBuiltins{decimal128}

@MmuxDefineTypeMinMaxBuiltins{sint8}
@MmuxDefineTypeMinMaxBuiltins{uint8}
@MmuxDefineTypeMinMaxBuiltins{sint16}
@MmuxDefineTypeMinMaxBuiltins{uint16}
@MmuxDefineTypeMinMaxBuiltins{sint32}
@MmuxDefineTypeMinMaxBuiltins{uint32}
@MmuxDefineTypeMinMaxBuiltins{sint64}
@MmuxDefineTypeMinMaxBuiltins{uint64}

@MmuxDefineTypeMinMaxBuiltins{ssize}
@MmuxDefineTypeMinMaxBuiltins{usize}
@MmuxDefineTypeMinMaxBuiltins{sintmax}
@MmuxDefineTypeMinMaxBuiltins{uintmax}
@MmuxDefineTypeMinMaxBuiltins{sintptr}
@MmuxDefineTypeMinMaxBuiltins{uintptr}
@MmuxDefineTypeMinMaxBuiltins{mode}
@MmuxDefineTypeMinMaxBuiltins{off}
@MmuxDefineTypeMinMaxBuiltins{pid}
@MmuxDefineTypeMinMaxBuiltins{uid}
@MmuxDefineTypeMinMaxBuiltins{gid}
@MmuxDefineTypeMinMaxBuiltins{wchar}
@MmuxDefineTypeMinMaxBuiltins{wint}

@c page
@node cctypes arithmetics
@section Arithmetics operation builtins


@gnu{} Bash already implements arithmetics operations for integer values, and such implementation
might be preferable to the builtins implemented by @value{PACKAGE}.  Anyway, for completeness, the
bitwise operations are implemented for every supported data type.

@menu
* cctypes arithmetics addition::        Addition builtins.
* cctypes arithmetics subtraction::     Subtraction builtins.
* cctypes arithmetics multiplication::  Multiplication builtins.
* cctypes arithmetics division::        Division builtins.
* cctypes arithmetics remainder::       Remainder builtins.
* cctypes arithmetics negation::        Negation builtins.
* cctypes arithmetics inversion::       Inversion builtins.
* cctypes arithmetics incrdecr::        Increment and decrement builtins.
* cctypes arithmetics abs::             Absolute value.
@end menu

@c page
@node cctypes arithmetics addition
@subsection Addition builtins


@deffn Builtin mmux_pointer_add @var{PTRVAR} @var{PTR} @var{DELTA}
Perform the addition between @var{PTR} and @var{DELTA}, then store a string representation of the
result in the variable @var{PTRVAR}; when successful: return true, otherwise return false and set
the shell variable @code{ERRNO} to the string representation of an exact integer, itself
representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer.

The argument @var{DELTA} must be the string representation of an exact number, in the range of the C
language type @objtype{ptrdiff_t}.
@end deffn


For the following builtins, the addition operation is as follows:

@example
@var{ROP} = @varo{OP} + @var{OP} + @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the addition between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeAdditionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_add @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the addition between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeAdditionBuiltin{schar}
@MmuxDefineTypeAdditionBuiltin{uchar}
@MmuxDefineTypeAdditionBuiltin{sshort}
@MmuxDefineTypeAdditionBuiltin{ushort}
@MmuxDefineTypeAdditionBuiltin{sint}
@MmuxDefineTypeAdditionBuiltin{uint}
@MmuxDefineTypeAdditionBuiltin{slong}
@MmuxDefineTypeAdditionBuiltin{ulong}
@MmuxDefineTypeAdditionBuiltin{sllong}
@MmuxDefineTypeAdditionBuiltin{ullong}
@MmuxDefineTypeAdditionBuiltin{float}
@MmuxDefineTypeAdditionBuiltin{double}
@MmuxDefineTypeAdditionBuiltin{ldouble}

@MmuxDefineTypeAdditionBuiltin{float32}
@MmuxDefineTypeAdditionBuiltin{float64}
@MmuxDefineTypeAdditionBuiltin{float128}

@MmuxDefineTypeAdditionBuiltin{float32x}
@MmuxDefineTypeAdditionBuiltin{float64x}
@MmuxDefineTypeAdditionBuiltin{float128x}

@MmuxDefineTypeAdditionBuiltin{decimal32}
@MmuxDefineTypeAdditionBuiltin{decimal64}
@MmuxDefineTypeAdditionBuiltin{decimal128}

@MmuxDefineTypeAdditionBuiltin{complexf}
@MmuxDefineTypeAdditionBuiltin{complexd}
@MmuxDefineTypeAdditionBuiltin{complexld}

@MmuxDefineTypeAdditionBuiltin{complexf32}
@MmuxDefineTypeAdditionBuiltin{complexf64}
@MmuxDefineTypeAdditionBuiltin{complexf128}

@MmuxDefineTypeAdditionBuiltin{complexf32x}
@MmuxDefineTypeAdditionBuiltin{complexf64x}
@MmuxDefineTypeAdditionBuiltin{complexf128x}

@MmuxDefineTypeAdditionBuiltin{complexd32}
@MmuxDefineTypeAdditionBuiltin{complexd64}
@MmuxDefineTypeAdditionBuiltin{complexd128}

@MmuxDefineTypeAdditionBuiltin{sint8}
@MmuxDefineTypeAdditionBuiltin{uint8}
@MmuxDefineTypeAdditionBuiltin{sint16}
@MmuxDefineTypeAdditionBuiltin{uint16}
@MmuxDefineTypeAdditionBuiltin{sint32}
@MmuxDefineTypeAdditionBuiltin{uint32}
@MmuxDefineTypeAdditionBuiltin{sint64}
@MmuxDefineTypeAdditionBuiltin{uint64}

@MmuxDefineTypeAdditionBuiltin{ssize}
@MmuxDefineTypeAdditionBuiltin{usize}
@MmuxDefineTypeAdditionBuiltin{sintmax}
@MmuxDefineTypeAdditionBuiltin{uintmax}
@MmuxDefineTypeAdditionBuiltin{sintptr}
@MmuxDefineTypeAdditionBuiltin{uintptr}
@MmuxDefineTypeAdditionBuiltin{mode}
@MmuxDefineTypeAdditionBuiltin{off}
@MmuxDefineTypeAdditionBuiltin{pid}
@MmuxDefineTypeAdditionBuiltin{uid}
@MmuxDefineTypeAdditionBuiltin{gid}
@MmuxDefineTypeAdditionBuiltin{wchar}
@MmuxDefineTypeAdditionBuiltin{wint}

@c page
@node cctypes arithmetics subtraction
@subsection Subtraction builtins


@deffn Builtin mmux_pointer_diff @var{PTRDIFF_VAR} @vari{PTR} @varii{PTR}
Compute the difference between the pointer values @code{@vari{PTR} - @varii{PTR}}, interpreting them
as pointers to @objtype{mmux_uint8_t}, then bind the result to the shell variable @var{PTRDIFF_VAR}.
@end deffn


For the following builtins, the subtraction operation is as follows:

@example
@var{ROP} = @varo{OP} - @var{OP} - @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the subtraction between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeSubtractionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_sub @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the subtraction between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeSubtractionBuiltin{schar}
@MmuxDefineTypeSubtractionBuiltin{uchar}
@MmuxDefineTypeSubtractionBuiltin{sshort}
@MmuxDefineTypeSubtractionBuiltin{ushort}
@MmuxDefineTypeSubtractionBuiltin{sint}
@MmuxDefineTypeSubtractionBuiltin{uint}
@MmuxDefineTypeSubtractionBuiltin{slong}
@MmuxDefineTypeSubtractionBuiltin{ulong}
@MmuxDefineTypeSubtractionBuiltin{sllong}
@MmuxDefineTypeSubtractionBuiltin{ullong}
@MmuxDefineTypeSubtractionBuiltin{float}
@MmuxDefineTypeSubtractionBuiltin{double}
@MmuxDefineTypeSubtractionBuiltin{ldouble}

@MmuxDefineTypeSubtractionBuiltin{float32}
@MmuxDefineTypeSubtractionBuiltin{float64}
@MmuxDefineTypeSubtractionBuiltin{float128}

@MmuxDefineTypeSubtractionBuiltin{float32x}
@MmuxDefineTypeSubtractionBuiltin{float64x}
@MmuxDefineTypeSubtractionBuiltin{float128x}

@MmuxDefineTypeSubtractionBuiltin{decimal32}
@MmuxDefineTypeSubtractionBuiltin{decimal64}
@MmuxDefineTypeSubtractionBuiltin{decimal128}

@MmuxDefineTypeSubtractionBuiltin{complexf}
@MmuxDefineTypeSubtractionBuiltin{complexd}
@MmuxDefineTypeSubtractionBuiltin{complexld}

@MmuxDefineTypeSubtractionBuiltin{complexf32}
@MmuxDefineTypeSubtractionBuiltin{complexf64}
@MmuxDefineTypeSubtractionBuiltin{complexf128}

@MmuxDefineTypeSubtractionBuiltin{complexd32}
@MmuxDefineTypeSubtractionBuiltin{complexd64}
@MmuxDefineTypeSubtractionBuiltin{complexd128}

@MmuxDefineTypeSubtractionBuiltin{sint8}
@MmuxDefineTypeSubtractionBuiltin{uint8}
@MmuxDefineTypeSubtractionBuiltin{sint16}
@MmuxDefineTypeSubtractionBuiltin{uint16}
@MmuxDefineTypeSubtractionBuiltin{sint32}
@MmuxDefineTypeSubtractionBuiltin{uint32}
@MmuxDefineTypeSubtractionBuiltin{sint64}
@MmuxDefineTypeSubtractionBuiltin{uint64}

@MmuxDefineTypeSubtractionBuiltin{ssize}
@MmuxDefineTypeSubtractionBuiltin{usize}
@MmuxDefineTypeSubtractionBuiltin{sintmax}
@MmuxDefineTypeSubtractionBuiltin{uintmax}
@MmuxDefineTypeSubtractionBuiltin{sintptr}
@MmuxDefineTypeSubtractionBuiltin{uintptr}
@MmuxDefineTypeSubtractionBuiltin{mode}
@MmuxDefineTypeSubtractionBuiltin{off}
@MmuxDefineTypeSubtractionBuiltin{pid}
@MmuxDefineTypeSubtractionBuiltin{uid}
@MmuxDefineTypeSubtractionBuiltin{gid}
@MmuxDefineTypeSubtractionBuiltin{wchar}
@MmuxDefineTypeSubtractionBuiltin{wint}

@c page
@node cctypes arithmetics multiplication
@subsection Multiplication builtins


For the following builtins, the multiplication operation is as follows:

@example
@var{ROP} = @varo{OP} * types @var{OP} * types @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the multiplication between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeMultiplicationBuiltin{STEM}
@deffn Builtin mmux_\STEM\_mul @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the multiplication between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeMultiplicationBuiltin{schar}
@MmuxDefineTypeMultiplicationBuiltin{uchar}
@MmuxDefineTypeMultiplicationBuiltin{sshort}
@MmuxDefineTypeMultiplicationBuiltin{ushort}
@MmuxDefineTypeMultiplicationBuiltin{sint}
@MmuxDefineTypeMultiplicationBuiltin{uint}
@MmuxDefineTypeMultiplicationBuiltin{slong}
@MmuxDefineTypeMultiplicationBuiltin{ulong}
@MmuxDefineTypeMultiplicationBuiltin{sllong}
@MmuxDefineTypeMultiplicationBuiltin{ullong}
@MmuxDefineTypeMultiplicationBuiltin{float}
@MmuxDefineTypeMultiplicationBuiltin{double}
@MmuxDefineTypeMultiplicationBuiltin{ldouble}

@MmuxDefineTypeMultiplicationBuiltin{float32}
@MmuxDefineTypeMultiplicationBuiltin{float64}
@MmuxDefineTypeMultiplicationBuiltin{float128}

@MmuxDefineTypeMultiplicationBuiltin{float32x}
@MmuxDefineTypeMultiplicationBuiltin{float64x}
@MmuxDefineTypeMultiplicationBuiltin{float128x}

@MmuxDefineTypeMultiplicationBuiltin{decimal32}
@MmuxDefineTypeMultiplicationBuiltin{decimal64}
@MmuxDefineTypeMultiplicationBuiltin{decimal128}

@MmuxDefineTypeMultiplicationBuiltin{complexf}
@MmuxDefineTypeMultiplicationBuiltin{complexd}
@MmuxDefineTypeMultiplicationBuiltin{complexld}

@MmuxDefineTypeMultiplicationBuiltin{complexf32}
@MmuxDefineTypeMultiplicationBuiltin{complexf64}
@MmuxDefineTypeMultiplicationBuiltin{complexf128}

@MmuxDefineTypeMultiplicationBuiltin{complexd32}
@MmuxDefineTypeMultiplicationBuiltin{complexd64}
@MmuxDefineTypeMultiplicationBuiltin{complexd128}

@MmuxDefineTypeMultiplicationBuiltin{sint8}
@MmuxDefineTypeMultiplicationBuiltin{uint8}
@MmuxDefineTypeMultiplicationBuiltin{sint16}
@MmuxDefineTypeMultiplicationBuiltin{uint16}
@MmuxDefineTypeMultiplicationBuiltin{sint32}
@MmuxDefineTypeMultiplicationBuiltin{uint32}
@MmuxDefineTypeMultiplicationBuiltin{sint64}
@MmuxDefineTypeMultiplicationBuiltin{uint64}

@MmuxDefineTypeMultiplicationBuiltin{ssize}
@MmuxDefineTypeMultiplicationBuiltin{usize}
@MmuxDefineTypeMultiplicationBuiltin{sintmax}
@MmuxDefineTypeMultiplicationBuiltin{uintmax}
@MmuxDefineTypeMultiplicationBuiltin{sintptr}
@MmuxDefineTypeMultiplicationBuiltin{uintptr}
@MmuxDefineTypeMultiplicationBuiltin{mode}
@MmuxDefineTypeMultiplicationBuiltin{off}
@MmuxDefineTypeMultiplicationBuiltin{pid}
@MmuxDefineTypeMultiplicationBuiltin{uid}
@MmuxDefineTypeMultiplicationBuiltin{gid}
@MmuxDefineTypeMultiplicationBuiltin{wchar}
@MmuxDefineTypeMultiplicationBuiltin{wint}

@c page
@node cctypes arithmetics division
@subsection Division builtins


For the following builtins, the division operation is as follows:

@example
@var{ROP} = @varo{OP} * types @var{OP} * types @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the division between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeDivisionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_div @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the division between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeDivisionBuiltin{schar}
@MmuxDefineTypeDivisionBuiltin{uchar}
@MmuxDefineTypeDivisionBuiltin{sshort}
@MmuxDefineTypeDivisionBuiltin{ushort}
@MmuxDefineTypeDivisionBuiltin{sint}
@MmuxDefineTypeDivisionBuiltin{uint}
@MmuxDefineTypeDivisionBuiltin{slong}
@MmuxDefineTypeDivisionBuiltin{ulong}
@MmuxDefineTypeDivisionBuiltin{sllong}
@MmuxDefineTypeDivisionBuiltin{ullong}
@MmuxDefineTypeDivisionBuiltin{float}
@MmuxDefineTypeDivisionBuiltin{double}
@MmuxDefineTypeDivisionBuiltin{ldouble}

@MmuxDefineTypeDivisionBuiltin{float32}
@MmuxDefineTypeDivisionBuiltin{float64}
@MmuxDefineTypeDivisionBuiltin{float128}

@MmuxDefineTypeDivisionBuiltin{float32x}
@MmuxDefineTypeDivisionBuiltin{float64x}
@MmuxDefineTypeDivisionBuiltin{float128x}

@MmuxDefineTypeDivisionBuiltin{decimal32}
@MmuxDefineTypeDivisionBuiltin{decimal64}
@MmuxDefineTypeDivisionBuiltin{decimal128}

@MmuxDefineTypeDivisionBuiltin{complexf}
@MmuxDefineTypeDivisionBuiltin{complexd}
@MmuxDefineTypeDivisionBuiltin{complexld}

@MmuxDefineTypeDivisionBuiltin{complexf32}
@MmuxDefineTypeDivisionBuiltin{complexf64}
@MmuxDefineTypeDivisionBuiltin{complexf128}

@MmuxDefineTypeDivisionBuiltin{complexd32}
@MmuxDefineTypeDivisionBuiltin{complexd64}
@MmuxDefineTypeDivisionBuiltin{complexd128}

@MmuxDefineTypeDivisionBuiltin{sint8}
@MmuxDefineTypeDivisionBuiltin{uint8}
@MmuxDefineTypeDivisionBuiltin{sint16}
@MmuxDefineTypeDivisionBuiltin{uint16}
@MmuxDefineTypeDivisionBuiltin{sint32}
@MmuxDefineTypeDivisionBuiltin{uint32}
@MmuxDefineTypeDivisionBuiltin{sint64}
@MmuxDefineTypeDivisionBuiltin{uint64}

@MmuxDefineTypeDivisionBuiltin{ssize}
@MmuxDefineTypeDivisionBuiltin{usize}
@MmuxDefineTypeDivisionBuiltin{sintmax}
@MmuxDefineTypeDivisionBuiltin{uintmax}
@MmuxDefineTypeDivisionBuiltin{sintptr}
@MmuxDefineTypeDivisionBuiltin{uintptr}
@MmuxDefineTypeDivisionBuiltin{mode}
@MmuxDefineTypeDivisionBuiltin{off}
@MmuxDefineTypeDivisionBuiltin{pid}
@MmuxDefineTypeDivisionBuiltin{uid}
@MmuxDefineTypeDivisionBuiltin{gid}
@MmuxDefineTypeDivisionBuiltin{wchar}
@MmuxDefineTypeDivisionBuiltin{wint}

@c page
@node cctypes arithmetics remainder
@subsection Remainder builtins


For the following builtins, the remainder operation is as follows:

@example
@var{ROP} = @vari{OP} % @varii{OP}
@end example

All the builtins perform the remainder between the operands @var{OP}, then store a string
representation of the result in the variable @var{ROPVAR}; when successful: return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.


@macro MmuxDefineTypeRemainderBuiltin{STEM}
@deffn Builtin mmux_\STEM\_mod @var{ROPVAR} @vari{OP} @varii{OP}
Perform the remainder between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeRemainderBuiltin{schar}
@MmuxDefineTypeRemainderBuiltin{uchar}
@MmuxDefineTypeRemainderBuiltin{sshort}
@MmuxDefineTypeRemainderBuiltin{ushort}
@MmuxDefineTypeRemainderBuiltin{sint}
@MmuxDefineTypeRemainderBuiltin{uint}
@MmuxDefineTypeRemainderBuiltin{slong}
@MmuxDefineTypeRemainderBuiltin{ulong}
@MmuxDefineTypeRemainderBuiltin{sllong}
@MmuxDefineTypeRemainderBuiltin{ullong}

@MmuxDefineTypeRemainderBuiltin{sint8}
@MmuxDefineTypeRemainderBuiltin{uint8}
@MmuxDefineTypeRemainderBuiltin{sint16}
@MmuxDefineTypeRemainderBuiltin{uint16}
@MmuxDefineTypeRemainderBuiltin{sint32}
@MmuxDefineTypeRemainderBuiltin{uint32}
@MmuxDefineTypeRemainderBuiltin{sint64}
@MmuxDefineTypeRemainderBuiltin{uint64}

@MmuxDefineTypeRemainderBuiltin{ssize}
@MmuxDefineTypeRemainderBuiltin{usize}
@MmuxDefineTypeRemainderBuiltin{sintmax}
@MmuxDefineTypeRemainderBuiltin{uintmax}
@MmuxDefineTypeRemainderBuiltin{sintptr}
@MmuxDefineTypeRemainderBuiltin{uintptr}
@MmuxDefineTypeRemainderBuiltin{mode}
@MmuxDefineTypeRemainderBuiltin{off}
@MmuxDefineTypeRemainderBuiltin{pid}
@MmuxDefineTypeRemainderBuiltin{uid}
@MmuxDefineTypeRemainderBuiltin{gid}
@MmuxDefineTypeRemainderBuiltin{wchar}
@MmuxDefineTypeRemainderBuiltin{wint}

@c page
@node cctypes arithmetics negation
@subsection Negation builtins


For the following builtins, the negation operation is as follows:

@example
@var{ROP} = - @var{OP}
@end example

All the builtins perform the negation of the operand @var{OP}, then store a string representation of
the result in the variable @var{ROPVAR}; when successful: return true, otherwise return false and
set the shell variable @code{ERRNO} to the string representation of an exact integer, itself
representing an @code{errno} error code.

The argument @var{OP} must be a string representation of a value of the specific builtin type.

@strong{NOTE} The builtins are implemented also for unsigned integers, for which the operation is
undefined; this will be fixed in the future, probably@dots{}


@macro MmuxDefineTypeNegationBuiltin{STEM}
@deffn Builtin mmux_\STEM\_neg @var{ROPVAR} @var{OP}
Perform the negation of a value of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeNegationBuiltin{schar}
@MmuxDefineTypeNegationBuiltin{uchar}
@MmuxDefineTypeNegationBuiltin{sshort}
@MmuxDefineTypeNegationBuiltin{ushort}
@MmuxDefineTypeNegationBuiltin{sint}
@MmuxDefineTypeNegationBuiltin{uint}
@MmuxDefineTypeNegationBuiltin{slong}
@MmuxDefineTypeNegationBuiltin{ulong}
@MmuxDefineTypeNegationBuiltin{sllong}
@MmuxDefineTypeNegationBuiltin{ullong}
@MmuxDefineTypeNegationBuiltin{float}
@MmuxDefineTypeNegationBuiltin{double}
@MmuxDefineTypeNegationBuiltin{ldouble}

@MmuxDefineTypeNegationBuiltin{float32}
@MmuxDefineTypeNegationBuiltin{float64}
@MmuxDefineTypeNegationBuiltin{float128}

@MmuxDefineTypeNegationBuiltin{float32x}
@MmuxDefineTypeNegationBuiltin{float64x}
@MmuxDefineTypeNegationBuiltin{float128x}

@MmuxDefineTypeNegationBuiltin{decimal32}
@MmuxDefineTypeNegationBuiltin{decimal64}
@MmuxDefineTypeNegationBuiltin{decimal128}

@MmuxDefineTypeNegationBuiltin{complexf}
@MmuxDefineTypeNegationBuiltin{complexd}
@MmuxDefineTypeNegationBuiltin{complexld}

@MmuxDefineTypeNegationBuiltin{complexf32}
@MmuxDefineTypeNegationBuiltin{complexf64}
@MmuxDefineTypeNegationBuiltin{complexf128}

@MmuxDefineTypeNegationBuiltin{complexd32}
@MmuxDefineTypeNegationBuiltin{complexd64}
@MmuxDefineTypeNegationBuiltin{complexd128}

@MmuxDefineTypeNegationBuiltin{sint8}
@MmuxDefineTypeNegationBuiltin{uint8}
@MmuxDefineTypeNegationBuiltin{sint16}
@MmuxDefineTypeNegationBuiltin{uint16}
@MmuxDefineTypeNegationBuiltin{sint32}
@MmuxDefineTypeNegationBuiltin{uint32}
@MmuxDefineTypeNegationBuiltin{sint64}
@MmuxDefineTypeNegationBuiltin{uint64}

@MmuxDefineTypeNegationBuiltin{ssize}
@MmuxDefineTypeNegationBuiltin{usize}
@MmuxDefineTypeNegationBuiltin{sintmax}
@MmuxDefineTypeNegationBuiltin{uintmax}
@MmuxDefineTypeNegationBuiltin{sintptr}
@MmuxDefineTypeNegationBuiltin{uintptr}
@MmuxDefineTypeNegationBuiltin{mode}
@MmuxDefineTypeNegationBuiltin{off}
@MmuxDefineTypeNegationBuiltin{pid}
@MmuxDefineTypeNegationBuiltin{uid}
@MmuxDefineTypeNegationBuiltin{gid}
@MmuxDefineTypeNegationBuiltin{wchar}
@MmuxDefineTypeNegationBuiltin{wint}

@c page
@node cctypes arithmetics inversion
@subsection Inversion builtins


For the following builtins, the inversion operation is as follows:

@example
@var{ROP} = 1 / @var{OP}
@end example

All the builtins perform the inversion of the operand @var{OP}, then store a string representation of
the result in the variable @var{ROPVAR}; when successful: return true, otherwise return false and
set the shell variable @code{ERRNO} to the string representation of an exact integer, itself
representing an @code{errno} error code.

The argument @var{OP} must be a string representation of a value of the specific builtin type.


@macro MmuxDefineTypeInversionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_inv @var{ROPVAR} @var{OP}
Perform the inversion of a value of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeInversionBuiltin{schar}
@MmuxDefineTypeInversionBuiltin{uchar}
@MmuxDefineTypeInversionBuiltin{sshort}
@MmuxDefineTypeInversionBuiltin{ushort}
@MmuxDefineTypeInversionBuiltin{sint}
@MmuxDefineTypeInversionBuiltin{uint}
@MmuxDefineTypeInversionBuiltin{slong}
@MmuxDefineTypeInversionBuiltin{ulong}
@MmuxDefineTypeInversionBuiltin{sllong}
@MmuxDefineTypeInversionBuiltin{ullong}
@MmuxDefineTypeInversionBuiltin{float}
@MmuxDefineTypeInversionBuiltin{double}
@MmuxDefineTypeInversionBuiltin{ldouble}

@MmuxDefineTypeInversionBuiltin{float32}
@MmuxDefineTypeInversionBuiltin{float64}
@MmuxDefineTypeInversionBuiltin{float128}

@MmuxDefineTypeInversionBuiltin{float32x}
@MmuxDefineTypeInversionBuiltin{float64x}
@MmuxDefineTypeInversionBuiltin{float128x}

@MmuxDefineTypeInversionBuiltin{decimal32}
@MmuxDefineTypeInversionBuiltin{decimal64}
@MmuxDefineTypeInversionBuiltin{decimal128}

@MmuxDefineTypeInversionBuiltin{complexf}
@MmuxDefineTypeInversionBuiltin{complexd}
@MmuxDefineTypeInversionBuiltin{complexld}

@MmuxDefineTypeInversionBuiltin{complexf32}
@MmuxDefineTypeInversionBuiltin{complexf64}
@MmuxDefineTypeInversionBuiltin{complexf128}

@MmuxDefineTypeInversionBuiltin{complexd32}
@MmuxDefineTypeInversionBuiltin{complexd64}
@MmuxDefineTypeInversionBuiltin{complexd128}

@MmuxDefineTypeInversionBuiltin{sint8}
@MmuxDefineTypeInversionBuiltin{uint8}
@MmuxDefineTypeInversionBuiltin{sint16}
@MmuxDefineTypeInversionBuiltin{uint16}
@MmuxDefineTypeInversionBuiltin{sint32}
@MmuxDefineTypeInversionBuiltin{uint32}
@MmuxDefineTypeInversionBuiltin{sint64}
@MmuxDefineTypeInversionBuiltin{uint64}

@MmuxDefineTypeInversionBuiltin{ssize}
@MmuxDefineTypeInversionBuiltin{usize}
@MmuxDefineTypeInversionBuiltin{sintmax}
@MmuxDefineTypeInversionBuiltin{uintmax}
@MmuxDefineTypeInversionBuiltin{sintptr}
@MmuxDefineTypeInversionBuiltin{uintptr}
@MmuxDefineTypeInversionBuiltin{mode}
@MmuxDefineTypeInversionBuiltin{off}
@MmuxDefineTypeInversionBuiltin{pid}
@MmuxDefineTypeInversionBuiltin{uid}
@MmuxDefineTypeInversionBuiltin{gid}
@MmuxDefineTypeInversionBuiltin{wchar}
@MmuxDefineTypeInversionBuiltin{wint}

@c page
@node cctypes arithmetics incrdecr
@subsection Increment and decrement builtins


@macro MmuxDefineTypeIncrdecrBuiltin{STEM}
@deffn Builtin mmux_\STEM\_incr @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_decr @var{ROPVAR} @var{OP}
Increment or decrement @var{OP}, store the result in the shell variable @var{ROPVAR}.
@end deffn

@end macro

@MmuxDefineTypeIncrdecrBuiltin{schar}
@MmuxDefineTypeIncrdecrBuiltin{uchar}
@MmuxDefineTypeIncrdecrBuiltin{sshort}
@MmuxDefineTypeIncrdecrBuiltin{ushort}
@MmuxDefineTypeIncrdecrBuiltin{sint}
@MmuxDefineTypeIncrdecrBuiltin{uint}
@MmuxDefineTypeIncrdecrBuiltin{slong}
@MmuxDefineTypeIncrdecrBuiltin{ulong}
@MmuxDefineTypeIncrdecrBuiltin{sllong}
@MmuxDefineTypeIncrdecrBuiltin{ullong}

@MmuxDefineTypeIncrdecrBuiltin{sint8}
@MmuxDefineTypeIncrdecrBuiltin{uint8}
@MmuxDefineTypeIncrdecrBuiltin{sint16}
@MmuxDefineTypeIncrdecrBuiltin{uint16}
@MmuxDefineTypeIncrdecrBuiltin{sint32}
@MmuxDefineTypeIncrdecrBuiltin{uint32}
@MmuxDefineTypeIncrdecrBuiltin{sint64}
@MmuxDefineTypeIncrdecrBuiltin{uint64}

@MmuxDefineTypeIncrdecrBuiltin{ssize}
@MmuxDefineTypeIncrdecrBuiltin{usize}
@MmuxDefineTypeIncrdecrBuiltin{sintmax}
@MmuxDefineTypeIncrdecrBuiltin{uintmax}
@MmuxDefineTypeIncrdecrBuiltin{sintptr}
@MmuxDefineTypeIncrdecrBuiltin{uintptr}
@MmuxDefineTypeIncrdecrBuiltin{mode}
@MmuxDefineTypeIncrdecrBuiltin{off}
@MmuxDefineTypeIncrdecrBuiltin{pid}
@MmuxDefineTypeIncrdecrBuiltin{uid}
@MmuxDefineTypeIncrdecrBuiltin{gid}
@MmuxDefineTypeIncrdecrBuiltin{wchar}
@MmuxDefineTypeIncrdecrBuiltin{wint}

@c page
@node cctypes arithmetics abs
@subsection Absolute value


To compute the absolute value of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' A

mmux_complexd_abs A "$Z"
"$A"    @result{} 3.605551275463989
@end example

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeAbsBuiltin{STEM}
@deffn Builtin mmux_\STEM\_abs @var{ROPVAR} @var{OP}
Compute the absolute value of @var{OP}, store the result in the shell variable @var{ROPVAR}.
@end deffn

@end macro

@macro MmuxDefineComplexAbsBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_abs @var{ABSVAR} @var{OP}
Extract the absolute value, which will be of type @objtype{\REALSTEM\}, from the complex number
@var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell variable
@var{ABSVAR}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineTypeAbsBuiltin{schar}
@MmuxDefineTypeAbsBuiltin{uchar}
@MmuxDefineTypeAbsBuiltin{sshort}
@MmuxDefineTypeAbsBuiltin{ushort}
@MmuxDefineTypeAbsBuiltin{sint}
@MmuxDefineTypeAbsBuiltin{uint}
@MmuxDefineTypeAbsBuiltin{slong}
@MmuxDefineTypeAbsBuiltin{ulong}
@MmuxDefineTypeAbsBuiltin{sllong}
@MmuxDefineTypeAbsBuiltin{ullong}
@MmuxDefineTypeAbsBuiltin{float}
@MmuxDefineTypeAbsBuiltin{double}
@MmuxDefineTypeAbsBuiltin{ldouble}

@MmuxDefineTypeAbsBuiltin{float32}
@MmuxDefineTypeAbsBuiltin{float64}
@MmuxDefineTypeAbsBuiltin{float128}

@MmuxDefineTypeAbsBuiltin{float32x}
@MmuxDefineTypeAbsBuiltin{float64x}
@MmuxDefineTypeAbsBuiltin{float128x}

@MmuxDefineTypeAbsBuiltin{decimal32}
@MmuxDefineTypeAbsBuiltin{decimal64}
@MmuxDefineTypeAbsBuiltin{decimal128}

@MmuxDefineComplexAbsBuiltin{complexf, float}
@MmuxDefineComplexAbsBuiltin{complexd, double}
@MmuxDefineComplexAbsBuiltin{complexld, ldouble}

@MmuxDefineComplexAbsBuiltin{complexf32, float32}
@MmuxDefineComplexAbsBuiltin{complexf64, float64}
@MmuxDefineComplexAbsBuiltin{complexf128, float128}

@MmuxDefineComplexAbsBuiltin{complexf32x, float32x}
@MmuxDefineComplexAbsBuiltin{complexf64x, float64x}
@MmuxDefineComplexAbsBuiltin{complexf128x, float128x}

@MmuxDefineComplexAbsBuiltin{complexd32, decimal32}
@MmuxDefineComplexAbsBuiltin{complexd64, decimal64}
@MmuxDefineComplexAbsBuiltin{complexd128, decimal128}

@MmuxDefineTypeAbsBuiltin{sint8}
@MmuxDefineTypeAbsBuiltin{uint8}
@MmuxDefineTypeAbsBuiltin{sint16}
@MmuxDefineTypeAbsBuiltin{uint16}
@MmuxDefineTypeAbsBuiltin{sint32}
@MmuxDefineTypeAbsBuiltin{uint32}
@MmuxDefineTypeAbsBuiltin{sint64}
@MmuxDefineTypeAbsBuiltin{uint64}

@MmuxDefineTypeAbsBuiltin{ssize}
@MmuxDefineTypeAbsBuiltin{usize}
@MmuxDefineTypeAbsBuiltin{sintmax}
@MmuxDefineTypeAbsBuiltin{uintmax}
@MmuxDefineTypeAbsBuiltin{sintptr}
@MmuxDefineTypeAbsBuiltin{uintptr}
@MmuxDefineTypeAbsBuiltin{mode}
@MmuxDefineTypeAbsBuiltin{off}
@MmuxDefineTypeAbsBuiltin{pid}
@MmuxDefineTypeAbsBuiltin{uid}
@MmuxDefineTypeAbsBuiltin{gid}
@MmuxDefineTypeAbsBuiltin{wchar}
@MmuxDefineTypeAbsBuiltin{wint}

@c page
@node cctypes mathematics
@section Mathematics operation builtins


All the following builtins compute a value and store its string representation in @var{ROPVAR}.

@macro MmuxDefineMathRealBuiltins{STEM}
@deffn Builtin mmux_\STEM\_sin @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_cos @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_tan @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_asin @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_acos @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_atan @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_atan2 @var{ROPVAR} @vari{OP} @varii{OP}
@deffnx Builtin mmux_\STEM\_sinh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_cosh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_tanh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_asinh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_acosh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_atanh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_exp @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_exp2 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_exp10 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_log @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_log10 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_log2 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_logb @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_pow @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_sqrt @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_cbrt @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_hypot @var{ROPVAR} @vari{OP} @vari{OP}
@deffnx Builtin mmux_\STEM\_expm1 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_log1p @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_erf @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_erfc @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_lgamma @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_tgamma @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_j0 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_j1 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_jn @var{ROPVAR} @var{SINT_N} @var{OP}
@deffnx Builtin mmux_\STEM\_y0 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_y1 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_yn @var{ROPVAR} @var{SINT_N} @var{OP}
Compute the named C function.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineMathComplexBuiltins{STEM}
@deffn Builtin mmux_\STEM\_sin @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_cos @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_tan @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_asin @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_acos @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_atan @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_sinh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_cosh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_tanh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_asinh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_acosh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_atanh @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_exp @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_log @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_log10 @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_pow @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_sqrt @var{ROPVAR} @var{OP}
Compute the named C function.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineMathRealBuiltins{float}
@MmuxDefineMathRealBuiltins{double}
@MmuxDefineMathRealBuiltins{ldouble}

@MmuxDefineMathRealBuiltins{float32}
@MmuxDefineMathRealBuiltins{float64}
@MmuxDefineMathRealBuiltins{float128}

@MmuxDefineMathRealBuiltins{float32x}
@MmuxDefineMathRealBuiltins{float64x}
@MmuxDefineMathRealBuiltins{float128x}

@ignore
@MmuxDefineMathRealBuiltins{decimal32}
@MmuxDefineMathRealBuiltins{decimal64}
@MmuxDefineMathRealBuiltins{decimal128}
@end ignore

@MmuxDefineMathComplexBuiltins{complexf}
@MmuxDefineMathComplexBuiltins{complexd}
@MmuxDefineMathComplexBuiltins{complexld}

@MmuxDefineMathComplexBuiltins{complexf32}
@MmuxDefineMathComplexBuiltins{complexf64}
@MmuxDefineMathComplexBuiltins{complexf128}

@MmuxDefineMathComplexBuiltins{complexf32x}
@MmuxDefineMathComplexBuiltins{complexf64x}
@MmuxDefineMathComplexBuiltins{complexf128x}

@ignore
@MmuxDefineMathComplexBuiltins{complexd32}
@MmuxDefineMathComplexBuiltins{complexd64}
@MmuxDefineMathComplexBuiltins{complexd128}
@end ignore

@c page
@node cctypes bitwise
@section Bitwise operation builtins


@gnu{} Bash already implements bitwise operations for integer values, and such implementation might
be preferable to the builtins implemented by @value{PACKAGE}.  Anyway, for completeness, the bitwise
operations are implemented for every supported data type.

@menu
* cctypes bitwise and::         Bitwise AND operation.
* cctypes bitwise or::          Bitwise OR operation.
* cctypes bitwise xor::         Bitwise XOR operation.
* cctypes bitwise not::         Bitwise NOT operation.
* cctypes bitwise shl::         Bitwise shift--left operation.
* cctypes bitwise shr::         Bitwise shift--right operation.
@end menu

@c page
@node cctypes bitwise and
@subsection Bitwise AND operation


@deffn Builtin mmux_pointer_bitwise_and @var{PTRVAR} @var{PTR} @var{MASK}
Compose a pointer value @var{PTR} with the exact unsigned integer value @var{MASK} using the bitwise
AND operation, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.

The argument @var{MASK} must be the string representation of a number of type @objtype{uintptr_t}.
@end deffn


For the following builtins, the bitwise AND operation is as follows:

@example
@var{ROP} = @varo{OP} & @var{OP} & @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the operation between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.

@macro MmuxDefineTypeBitwiseAndBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_and @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the bitwise AND operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseAndBuiltin{schar}
@MmuxDefineTypeBitwiseAndBuiltin{uchar}
@MmuxDefineTypeBitwiseAndBuiltin{sshort}
@MmuxDefineTypeBitwiseAndBuiltin{ushort}
@MmuxDefineTypeBitwiseAndBuiltin{sint}
@MmuxDefineTypeBitwiseAndBuiltin{uint}
@MmuxDefineTypeBitwiseAndBuiltin{slong}
@MmuxDefineTypeBitwiseAndBuiltin{ulong}
@MmuxDefineTypeBitwiseAndBuiltin{sllong}
@MmuxDefineTypeBitwiseAndBuiltin{ullong}

@MmuxDefineTypeBitwiseAndBuiltin{sint8}
@MmuxDefineTypeBitwiseAndBuiltin{uint8}
@MmuxDefineTypeBitwiseAndBuiltin{sint16}
@MmuxDefineTypeBitwiseAndBuiltin{uint16}
@MmuxDefineTypeBitwiseAndBuiltin{sint32}
@MmuxDefineTypeBitwiseAndBuiltin{uint32}
@MmuxDefineTypeBitwiseAndBuiltin{sint64}
@MmuxDefineTypeBitwiseAndBuiltin{uint64}

@MmuxDefineTypeBitwiseAndBuiltin{ssize}
@MmuxDefineTypeBitwiseAndBuiltin{usize}
@MmuxDefineTypeBitwiseAndBuiltin{sintmax}
@MmuxDefineTypeBitwiseAndBuiltin{uintmax}
@MmuxDefineTypeBitwiseAndBuiltin{sintptr}
@MmuxDefineTypeBitwiseAndBuiltin{uintptr}
@MmuxDefineTypeBitwiseAndBuiltin{mode}
@MmuxDefineTypeBitwiseAndBuiltin{off}
@MmuxDefineTypeBitwiseAndBuiltin{pid}
@MmuxDefineTypeBitwiseAndBuiltin{uid}
@MmuxDefineTypeBitwiseAndBuiltin{gid}
@MmuxDefineTypeBitwiseAndBuiltin{wchar}
@MmuxDefineTypeBitwiseAndBuiltin{wint}

@c page
@node cctypes bitwise or
@subsection Bitwise OR operation


@deffn Builtin mmux_pointer_bitwise_or @var{PTRVAR} @var{PTR} @var{MASK}
Compose a pointer value @var{PTR} with the exact unsigned integer value @var{MASK} using the bitwise
OR operation, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.

The argument @var{MASK} must be the string representation of a number of type @objtype{uintptr_t}.
@end deffn


For the following builtins, the bitwise OR operation is as follows:

@example
@var{ROP} = @varo{OP} | @var{OP} | @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the operation between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.

@macro MmuxDefineTypeBitwiseOrBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_or @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the bitwise OR operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseOrBuiltin{schar}
@MmuxDefineTypeBitwiseOrBuiltin{uchar}
@MmuxDefineTypeBitwiseOrBuiltin{sshort}
@MmuxDefineTypeBitwiseOrBuiltin{ushort}
@MmuxDefineTypeBitwiseOrBuiltin{sint}
@MmuxDefineTypeBitwiseOrBuiltin{uint}
@MmuxDefineTypeBitwiseOrBuiltin{slong}
@MmuxDefineTypeBitwiseOrBuiltin{ulong}
@MmuxDefineTypeBitwiseOrBuiltin{sllong}
@MmuxDefineTypeBitwiseOrBuiltin{ullong}

@MmuxDefineTypeBitwiseOrBuiltin{sint8}
@MmuxDefineTypeBitwiseOrBuiltin{uint8}
@MmuxDefineTypeBitwiseOrBuiltin{sint16}
@MmuxDefineTypeBitwiseOrBuiltin{uint16}
@MmuxDefineTypeBitwiseOrBuiltin{sint32}
@MmuxDefineTypeBitwiseOrBuiltin{uint32}
@MmuxDefineTypeBitwiseOrBuiltin{sint64}
@MmuxDefineTypeBitwiseOrBuiltin{uint64}

@MmuxDefineTypeBitwiseOrBuiltin{ssize}
@MmuxDefineTypeBitwiseOrBuiltin{usize}
@MmuxDefineTypeBitwiseOrBuiltin{sintmax}
@MmuxDefineTypeBitwiseOrBuiltin{uintmax}
@MmuxDefineTypeBitwiseOrBuiltin{sintptr}
@MmuxDefineTypeBitwiseOrBuiltin{uintptr}
@MmuxDefineTypeBitwiseOrBuiltin{mode}
@MmuxDefineTypeBitwiseOrBuiltin{off}
@MmuxDefineTypeBitwiseOrBuiltin{pid}
@MmuxDefineTypeBitwiseOrBuiltin{uid}
@MmuxDefineTypeBitwiseOrBuiltin{gid}
@MmuxDefineTypeBitwiseOrBuiltin{wchar}
@MmuxDefineTypeBitwiseOrBuiltin{wint}

@c page
@node cctypes bitwise xor
@subsection Bitwise XOR operation


@deffn Builtin mmux_pointer_bitwise_xor @var{PTRVAR} @var{PTR} @var{MASK}
Compose a pointer value @var{PTR} with the exact unsigned integer value @var{MASK} using the bitwise
XOR operation, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.

The argument @var{MASK} must be the string representation of a number of type @objtype{uintptr_t}.
@end deffn


For the following builtins, the bitwise XOR operation is as follows:

@example
@var{ROP} = @varo{OP} ^ @var{OP} ^ @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the operation between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.

@macro MmuxDefineTypeBitwiseXorBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_xor @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the bitwise XOR operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseXorBuiltin{schar}
@MmuxDefineTypeBitwiseXorBuiltin{uchar}
@MmuxDefineTypeBitwiseXorBuiltin{sshort}
@MmuxDefineTypeBitwiseXorBuiltin{ushort}
@MmuxDefineTypeBitwiseXorBuiltin{sint}
@MmuxDefineTypeBitwiseXorBuiltin{uint}
@MmuxDefineTypeBitwiseXorBuiltin{slong}
@MmuxDefineTypeBitwiseXorBuiltin{ulong}
@MmuxDefineTypeBitwiseXorBuiltin{sllong}
@MmuxDefineTypeBitwiseXorBuiltin{ullong}

@MmuxDefineTypeBitwiseXorBuiltin{sint8}
@MmuxDefineTypeBitwiseXorBuiltin{uint8}
@MmuxDefineTypeBitwiseXorBuiltin{sint16}
@MmuxDefineTypeBitwiseXorBuiltin{uint16}
@MmuxDefineTypeBitwiseXorBuiltin{sint32}
@MmuxDefineTypeBitwiseXorBuiltin{uint32}
@MmuxDefineTypeBitwiseXorBuiltin{sint64}
@MmuxDefineTypeBitwiseXorBuiltin{uint64}

@MmuxDefineTypeBitwiseXorBuiltin{ssize}
@MmuxDefineTypeBitwiseXorBuiltin{usize}
@MmuxDefineTypeBitwiseXorBuiltin{sintmax}
@MmuxDefineTypeBitwiseXorBuiltin{uintmax}
@MmuxDefineTypeBitwiseXorBuiltin{sintptr}
@MmuxDefineTypeBitwiseXorBuiltin{uintptr}
@MmuxDefineTypeBitwiseXorBuiltin{mode}
@MmuxDefineTypeBitwiseXorBuiltin{off}
@MmuxDefineTypeBitwiseXorBuiltin{pid}
@MmuxDefineTypeBitwiseXorBuiltin{uid}
@MmuxDefineTypeBitwiseXorBuiltin{gid}
@MmuxDefineTypeBitwiseXorBuiltin{wchar}
@MmuxDefineTypeBitwiseXorBuiltin{wint}

@c page
@node cctypes bitwise not
@subsection Bitwise NOT operation


@deffn Builtin mmux_pointer_bitwise_not @var{PTRVAR} @var{PTR}
Perform the bitwise NOT operation on a pointer value @var{PTR}, then store the result in the
variable @var{ROPVAR}; when successful: return true, otherwise return false and set the shell
variable @code{ERRNO} to the string representation of an exact integer, itself representing an
@code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.
@end deffn


For the following builtins, the bitwise NOT operation is as follows:

@example
@var{ROP} = ~ @var{OP}
@end example

@noindent

When successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The argument @var{OP} must be a string representation of a value of the specific builtin type.

@macro MmuxDefineTypeBitwiseNotBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_not @var{ROPVAR} @varo{OP}
Perform the bitwise NOT operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseNotBuiltin{schar}
@MmuxDefineTypeBitwiseNotBuiltin{uchar}
@MmuxDefineTypeBitwiseNotBuiltin{sshort}
@MmuxDefineTypeBitwiseNotBuiltin{ushort}
@MmuxDefineTypeBitwiseNotBuiltin{sint}
@MmuxDefineTypeBitwiseNotBuiltin{uint}
@MmuxDefineTypeBitwiseNotBuiltin{slong}
@MmuxDefineTypeBitwiseNotBuiltin{ulong}
@MmuxDefineTypeBitwiseNotBuiltin{sllong}
@MmuxDefineTypeBitwiseNotBuiltin{ullong}

@MmuxDefineTypeBitwiseNotBuiltin{sint8}
@MmuxDefineTypeBitwiseNotBuiltin{uint8}
@MmuxDefineTypeBitwiseNotBuiltin{sint16}
@MmuxDefineTypeBitwiseNotBuiltin{uint16}
@MmuxDefineTypeBitwiseNotBuiltin{sint32}
@MmuxDefineTypeBitwiseNotBuiltin{uint32}
@MmuxDefineTypeBitwiseNotBuiltin{sint64}
@MmuxDefineTypeBitwiseNotBuiltin{uint64}

@MmuxDefineTypeBitwiseNotBuiltin{ssize}
@MmuxDefineTypeBitwiseNotBuiltin{usize}
@MmuxDefineTypeBitwiseNotBuiltin{sintmax}
@MmuxDefineTypeBitwiseNotBuiltin{uintmax}
@MmuxDefineTypeBitwiseNotBuiltin{sintptr}
@MmuxDefineTypeBitwiseNotBuiltin{uintptr}
@MmuxDefineTypeBitwiseNotBuiltin{mode}
@MmuxDefineTypeBitwiseNotBuiltin{off}
@MmuxDefineTypeBitwiseNotBuiltin{pid}
@MmuxDefineTypeBitwiseNotBuiltin{uid}
@MmuxDefineTypeBitwiseNotBuiltin{gid}
@MmuxDefineTypeBitwiseNotBuiltin{wchar}
@MmuxDefineTypeBitwiseNotBuiltin{wint}

@c page
@node cctypes bitwise shl
@subsection Bitwise shift--left operation


All the following builtins perform the bitwise shift--left operation on a value @var{OP}, shifting
by @var{NBITS}, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{NBITS} must be the string representation of a @objtype{sint}.


@macro MmuxDefineTypeBitwiseShlBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_shl @var{ROPVAR} @var{OP} @var{NBITS}
Perform the bitwise shift--left operation on an operand of type \STEM\.
@end deffn

@end macro

@MmuxDefineTypeBitwiseShlBuiltin{schar}
@MmuxDefineTypeBitwiseShlBuiltin{uchar}
@MmuxDefineTypeBitwiseShlBuiltin{sshort}
@MmuxDefineTypeBitwiseShlBuiltin{ushort}
@MmuxDefineTypeBitwiseShlBuiltin{sint}
@MmuxDefineTypeBitwiseShlBuiltin{uint}
@MmuxDefineTypeBitwiseShlBuiltin{slong}
@MmuxDefineTypeBitwiseShlBuiltin{ulong}
@MmuxDefineTypeBitwiseShlBuiltin{sllong}
@MmuxDefineTypeBitwiseShlBuiltin{ullong}

@MmuxDefineTypeBitwiseShlBuiltin{sint8}
@MmuxDefineTypeBitwiseShlBuiltin{uint8}
@MmuxDefineTypeBitwiseShlBuiltin{sint16}
@MmuxDefineTypeBitwiseShlBuiltin{uint16}
@MmuxDefineTypeBitwiseShlBuiltin{sint32}
@MmuxDefineTypeBitwiseShlBuiltin{uint32}
@MmuxDefineTypeBitwiseShlBuiltin{sint64}
@MmuxDefineTypeBitwiseShlBuiltin{uint64}

@MmuxDefineTypeBitwiseShlBuiltin{ssize}
@MmuxDefineTypeBitwiseShlBuiltin{usize}
@MmuxDefineTypeBitwiseShlBuiltin{sintmax}
@MmuxDefineTypeBitwiseShlBuiltin{uintmax}
@MmuxDefineTypeBitwiseShlBuiltin{sintptr}
@MmuxDefineTypeBitwiseShlBuiltin{uintptr}
@MmuxDefineTypeBitwiseShlBuiltin{mode}
@MmuxDefineTypeBitwiseShlBuiltin{off}
@MmuxDefineTypeBitwiseShlBuiltin{pid}
@MmuxDefineTypeBitwiseShlBuiltin{uid}
@MmuxDefineTypeBitwiseShlBuiltin{gid}
@MmuxDefineTypeBitwiseShlBuiltin{wchar}
@MmuxDefineTypeBitwiseShlBuiltin{wint}

@c page
@node cctypes bitwise shr
@subsection Bitwise shift--right operation


All the following builtins perform the bitwise shift--right operation on a value @var{OP}, shifting
by @var{NBITS}, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{NBITS} must be the string representation of a @objtype{sint}.


@macro MmuxDefineTypeBitwiseShrBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_shr @var{ROPVAR} @var{OP} @var{NBITS}
Perform the bitwise shift--right operation on an operand of type \STEM\.
@end deffn

@end macro

@MmuxDefineTypeBitwiseShrBuiltin{schar}
@MmuxDefineTypeBitwiseShrBuiltin{uchar}
@MmuxDefineTypeBitwiseShrBuiltin{sshort}
@MmuxDefineTypeBitwiseShrBuiltin{ushort}
@MmuxDefineTypeBitwiseShrBuiltin{sint}
@MmuxDefineTypeBitwiseShrBuiltin{uint}
@MmuxDefineTypeBitwiseShrBuiltin{slong}
@MmuxDefineTypeBitwiseShrBuiltin{ulong}
@MmuxDefineTypeBitwiseShrBuiltin{sllong}
@MmuxDefineTypeBitwiseShrBuiltin{ullong}

@MmuxDefineTypeBitwiseShrBuiltin{sint8}
@MmuxDefineTypeBitwiseShrBuiltin{uint8}
@MmuxDefineTypeBitwiseShrBuiltin{sint16}
@MmuxDefineTypeBitwiseShrBuiltin{uint16}
@MmuxDefineTypeBitwiseShrBuiltin{sint32}
@MmuxDefineTypeBitwiseShrBuiltin{uint32}
@MmuxDefineTypeBitwiseShrBuiltin{sint64}
@MmuxDefineTypeBitwiseShrBuiltin{uint64}

@MmuxDefineTypeBitwiseShrBuiltin{ssize}
@MmuxDefineTypeBitwiseShrBuiltin{usize}
@MmuxDefineTypeBitwiseShrBuiltin{sintmax}
@MmuxDefineTypeBitwiseShrBuiltin{uintmax}
@MmuxDefineTypeBitwiseShrBuiltin{sintptr}
@MmuxDefineTypeBitwiseShrBuiltin{uintptr}
@MmuxDefineTypeBitwiseShrBuiltin{mode}
@MmuxDefineTypeBitwiseShrBuiltin{off}
@MmuxDefineTypeBitwiseShrBuiltin{pid}
@MmuxDefineTypeBitwiseShrBuiltin{uid}
@MmuxDefineTypeBitwiseShrBuiltin{gid}
@MmuxDefineTypeBitwiseShrBuiltin{wchar}
@MmuxDefineTypeBitwiseShrBuiltin{wint}

@c page
@node cctypes formats
@section Input and output formats


@menu
* cctypes formats float::       Selecting the printing format for floating--point numbers.
@end menu

@c page
@node cctypes formats float
@subsection Selecting the printing format for floating--point numbers


@cindex Printing format for floating--point numbers
@cindex Formatting floating--point numbers


To select an output format for the result of operations, we do:

@example
declare OLD_FORMAT ROP OP1='123.4' OP2='567.8'

mmux_double_set_format '%g' OLD_FORMAT
@{
    mmux_double_add ROP "$OP1" "$OP2"
@}
mmux_double_set_format "$OLD_FORMAT"

"$ROP"  @result{} 6.912000e+02
@end example

To query the currently selected output format for the result of operations:

@example
declare CURRENT_FORMAT

mmux_double_ref_format CURRENT_FORMAT
"$CURRENT_FORMAT"       @result{} "%A"
@end example

If we just want to reformat a number we do:

@example
declare OP='123.4567890'

mmux_double_reformat OP '%g' "$OP"
"$OP"   @result{} 1.234568e+02
@end example

The string representation of exact integers is an acceptable format for floating--point numbers: we
can use the formatting capabilities implemented for floating--point numbers to format exact
integers.

String representations of complex floating--point numbers are composed using the format selected for
the corresponding real floating--point type.

For the following builtins:

@itemize
@item
The argument @var{OUTPUT_FORMAT} must be a string compatible with the @cfunc{printf} format
selection for floating--point numbers.  Each supported type may have limitations in the available
format.

@item
The optional argument @var{OLD_FORMAT_VAR} must be a shell variable name in which the builtin will
store the old output format, so that: it is possible to temporarily select a new format, then
restore the old one.

@item
The argument @var{CURRENT_FORMAT_VAR} must be a shell variable name in which the builtin will store
the currently selected output format.
@end itemize

@quotation
@strong{NOTE} We should be careful @strong{not} to select a field width of zero; that is, to avoid
formats like @samp{%0e}.
@end quotation


@c ------------------------------------------------------------------------

@macro MmuxRealSelectOutputFormatBuiltin{STEM,DEFAULTFORMAT}
@deffn Builtin mmux_\STEM\_set_format @var{OUTPUT_FORMAT}
@deffnx Builtin mmux_\STEM\_set_format @var{OUTPUT_FORMAT} @var{OLD_FORMAT_VAR}
@deffnx Builtin mmux_\STEM\_ref_format @var{CURRENT_FORMAT_VAR}
@deffnx Builtin mmux_\STEM\_reformat @var{OUTPUTVAR} @var{OUTPUT_FORMAT} @var{INPUT_NUMBER}
Select or retrieve the format for string representations of floating--point numbers of type
@objtype{\STEM\}.  The default format is @samp{\DEFAULTFORMAT\}.
@end deffn

@end macro

@MmuxRealSelectOutputFormatBuiltin{float, %A}
@MmuxRealSelectOutputFormatBuiltin{double, %A}
@MmuxRealSelectOutputFormatBuiltin{ldouble, %A}

@MmuxRealSelectOutputFormatBuiltin{float32, %A}
@MmuxRealSelectOutputFormatBuiltin{float64, %A}
@MmuxRealSelectOutputFormatBuiltin{float128, %A}

@MmuxRealSelectOutputFormatBuiltin{float32x, %A}
@MmuxRealSelectOutputFormatBuiltin{float64x, %A}
@MmuxRealSelectOutputFormatBuiltin{float128x, %A}

@MmuxRealSelectOutputFormatBuiltin{decimal32, %f}
@MmuxRealSelectOutputFormatBuiltin{decimal64, %f}
@MmuxRealSelectOutputFormatBuiltin{decimal128, %f}

@c ------------------------------------------------------------------------

@macro MmuxComplexReformatBuiltin{STEM}
@deffn Builtin mmux_\STEM\_reformat @var{OUTPUTVAR} @var{OUTPUT_FORMAT} @var{INPUT_NUMBER}
Reformat a complex floating--point number of type @objtype{\STEM\}.
@end deffn

@end macro

@MmuxComplexReformatBuiltin{complexf}
@MmuxComplexReformatBuiltin{complexd}
@MmuxComplexReformatBuiltin{complexld}

@MmuxComplexReformatBuiltin{complexf32}
@MmuxComplexReformatBuiltin{complexf64}
@MmuxComplexReformatBuiltin{complexf128}

@MmuxComplexReformatBuiltin{complexf32x}
@MmuxComplexReformatBuiltin{complexf64x}
@MmuxComplexReformatBuiltin{complexf128x}

@MmuxComplexReformatBuiltin{complexf32}
@MmuxComplexReformatBuiltin{complexd64}
@MmuxComplexReformatBuiltin{complexd128}

@c page
@node memory
@chapter Raw memory operations


@menu
* memory alloc::                Standard memory allocation.
* memory operations::           Standard memory operations.
* memory pointers::             Memory block accessors and mutators.
* memory arrays::               Memory arrays accessors and mutators.
* memory conversions::          Converting data to and from memory blocks.
* memory comparison::           Comparing memory blocks.
* memory searching::            Searching in memory blocks.
@end menu

@c page
@node memory alloc
@section Standard memory allocation


Basically, to allocate new memory we should do:

@example
declare PTR

if mmux_libc_malloc PTR 123
then exit 1
fi
@{
  # do something
@}
mmux_libc_free $PTR
@end example

@noindent
we must remember that if we execute code in a subshell: the pointers will not be valid across
shells; so the following will not work:

@example
declare PTR

$(mmux_libc_malloc PTR 123)
mmux_libc_free $PTR
@end example

@noindent
because @func{mmux_libc_malloc} allocates memory in a subshell.

@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_malloc @var{PTRVAR} @var{SIZE}
Allocate a memory block using the standard @cfunc{malloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing the @code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{SIZE} must be the string representation of an exact, positive, integer, itself
representing the requested number of bytes in the newly allocated block; it must fit the C language
type @objtype{size_t}.
@end deffn


@deffn Builtin mmux_libc_calloc @var{PTRVAR} @var{ITEM_COUNT} @var{ITEM_SIZE}
Allocate a memory block using the standard @cfunc{calloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to an exact integer representing the
@code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{ITEM_COUNT} must be the string representation of an exact, positive, integer,
itself representing the number of items the memory block has to contain; it must fit the C language
type @objtype{size_t}.

The argument @var{ITEM_SIZE} must be the string representation of an exact, positive, integer, itself
representing the size of each item the memory block has to contain; it must fit the C language type
@objtype{size_t}.
@end deffn


@deffn Builtin mmux_libc_realloc @var{PTRVAR} @var{OLDPTR} @var{NEWSIZE}
Reallocate a memory block using the standard @cfunc{realloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to an exact integer representing the
@code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{OLDPTR} must be the string representation of the old memory pointer.

The argument @var{SIZE} must be the string representation of an exact, positive, integer, itself
representing the newly requested number of bytes in the newly allocated block; it must fit the C
language type @objtype{size_t}.
@end deffn


@deffn Builtin mmux_libc_free @var{PTR}
Release a previously allocated memory block using the standard @cfunc{free} function; if successful
return true, otherwise return false and set the shell variable @code{ERRNO} to an exact integer
representing the @code{errno} error code.

The argument @var{PTR} must be the string representation of a memory pointer referencing a
previously allocated block.

Notice that this builtin can fail if the argument @var{PTR} is not a valid pointer string
representation; in this case the error code is @samp{EINVAL}.
@end deffn

@c page
@node memory operations
@section Standard memory operations


The following builtins can fail if one of the arguments @var{PTR} is not a valid pointer string
representation; in this case the @code{ERRNO} error code is @samp{EINVAL}.  @ref{overview
conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_memset @var{PTR} @var{BYTE} @var{SIZE}
Interface to the standard C language function @cfunc{memset}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer referencing a previously
allocated memory block.

The argument @var{BYTE} must be the string representation of an exact, positive, integer itself
representing the value to which memory bytes must be set; it must fit an unsigned 8-bit integer.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to set to @var{BYTE}; it must fit the C language type
@objtype{size_t}.

@example
declare PTR SIZE=123

mmux_libc_malloc PTR $SIZE
mmux_libc_memset $PTR 1 $SIZE
@end example
@end deffn


@deffn Builtin mmux_libc_memcpy @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Interface to the standard C language function @cfunc{memcpy}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the destination of the copy operation.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare PTR_FROM PTR_TO SIZE=123

mmux_libc_malloc PTR_FROM $SIZE
mmux_libc_malloc PTR_TO   $SIZE

mmux_libc_memcpy $PTR_TO $PTR_FROM $SIZE
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_mempcpy @var{NEXT_PTR_TO_VAR} @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Like @MmuxBuiltin{mmux_libc_memcpy}, but store in the shell variable @var{NEXT_PTR_TO_VAR} the
string representation of the sum between @var{PTR_TO} and @var{SIZE}.

The underlying C language function @cfunc{mempcpy} is a @gnu{} extension: this builtin is available
only on @gnu{} platforms.
@end deffn


@deffn {Builtin} mmux_libc_memccpy @var{AFTER_PTR_VAR} @var{PTR_TO} @var{PTR_FROM} @var{UINT8_SEPARATOR} @var{USIZE}
Interface to the C language function @cfunc{memccpy}, @cfuncpage{memccpy}.  Copy at most @var{USIZE}
octets from a memory block to another stopping if @var{UINT8_SEPARATOR} is found; the separator
octet is copied.

The argument @var{AFTER_PTR_VAR} must be a shell variable name; when the operation is successful:

@itemize
@item
If an octet matching @var{UINT8_SEPARATOR} was found: the shell variable is set to the pointer, in
the memory block referenced by @var{PTR_TO}, right after @var{UINT8_SEPARATOR}.

@item
Otherwise the shell variable is left untouched.
@end itemize
@end deffn


@deffn Builtin mmux_libc_memmove @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Interface to the standard C language function @cfunc{memmove}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the destination of the copy operation.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy.

@example
declare PTR_FROM PTR_TO SIZE=123

mmux_libc_malloc PTR_FROM $SIZE
mmux_libc_malloc PTR_TO   $SIZE

mmux_libc_memmove $PTR_TO $PTR_FROM $SIZE
@end example
@end deffn

@c page
@node memory pointers
@section Memory block accessors and mutators


If we allocate memory using the standard C library functions, we can poke and peek values in the
memory blocks:

@example
declare PTR VALUE

mmux_libc_malloc PTR 1024
@{
  mmux_double_pointer_set $PTR 0 1.23
  mmux_double_pointer_ref VALUE $PTR 0
@}
mmux_libc_free $PTR
@end example

For all the following builtins, the argument:

@table @var
@item POINTER
must be the string representation of a memory pointer referencing a previously allocated block;

@item OFFSET
must be the string representation of an exact, non--negative integer, compatible with the C language
type @code{size_t}, itself representing an offset from @var{POINTER} @strong{measured in bytes};

@item VALUE
must be the string representation of a number, compatible with a C language type of the specific
mutator: such number is stored by the mutators at @var{OFFSET} from @var{POINTER};

@item VALUEVAR
must be a string representing the name of a shell variable: it is used by the accessors to store the
value extracted at @var{OFFSET} from @var{POINTER}.
@end table

For all the following builtins: if the operation is successful, the return value is true; otherwise
the return value is false and the shell variable @code{ERRNO} is set to the string representation of
an exact integer, itself representing an @code{errno} error code.

@ref{overview conventions, Conventions in coding and documentation}.

@macro MmuxDefineAccessorMutator{STEM}
@deffn {Builtin Mutator} mmux_\STEM\_pointer_set @var{POINTER} @var{OFFSET} @var{VALUE}
@deffnx {Builtin Accessor} mmux_\STEM\_pointer_ref @var{VALUEVAR} @var{POINTER} @var{OFFSET}
Accessor and mutator for memory blocks operating on the C language type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineAccessorMutator{pointer}

@MmuxDefineAccessorMutator{schar}
@MmuxDefineAccessorMutator{uchar}
@MmuxDefineAccessorMutator{sint}
@MmuxDefineAccessorMutator{uint}
@MmuxDefineAccessorMutator{sshort}
@MmuxDefineAccessorMutator{ushort}
@MmuxDefineAccessorMutator{slong}
@MmuxDefineAccessorMutator{ulong}
@MmuxDefineAccessorMutator{sllong}
@MmuxDefineAccessorMutator{ullong}
@MmuxDefineAccessorMutator{float}
@MmuxDefineAccessorMutator{double}
@MmuxDefineAccessorMutator{ldouble}

@MmuxDefineAccessorMutator{float32}
@MmuxDefineAccessorMutator{float64}
@MmuxDefineAccessorMutator{float128}

@MmuxDefineAccessorMutator{float32x}
@MmuxDefineAccessorMutator{float64x}
@MmuxDefineAccessorMutator{float128x}

@MmuxDefineAccessorMutator{decimal32}
@MmuxDefineAccessorMutator{decimal64}
@MmuxDefineAccessorMutator{decimal128}

@MmuxDefineAccessorMutator{complexf}
@MmuxDefineAccessorMutator{complexd}
@MmuxDefineAccessorMutator{complexld}

@MmuxDefineAccessorMutator{complexf32}
@MmuxDefineAccessorMutator{complexf64}
@MmuxDefineAccessorMutator{complexf128}

@MmuxDefineAccessorMutator{complexf32x}
@MmuxDefineAccessorMutator{complexf64x}
@MmuxDefineAccessorMutator{complexf128x}

@MmuxDefineAccessorMutator{complexd32}
@MmuxDefineAccessorMutator{complexd64}
@MmuxDefineAccessorMutator{complexd128}

@MmuxDefineAccessorMutator{sint8}
@MmuxDefineAccessorMutator{uint8}
@MmuxDefineAccessorMutator{sint16}
@MmuxDefineAccessorMutator{uint16}
@MmuxDefineAccessorMutator{sint32}
@MmuxDefineAccessorMutator{uint32}
@MmuxDefineAccessorMutator{sint64}
@MmuxDefineAccessorMutator{uint64}

@MmuxDefineAccessorMutator{ssize}
@MmuxDefineAccessorMutator{usize}
@MmuxDefineAccessorMutator{sintmax}
@MmuxDefineAccessorMutator{uintmax}
@MmuxDefineAccessorMutator{sintptr}
@MmuxDefineAccessorMutator{uintptr}
@MmuxDefineAccessorMutator{mode}
@MmuxDefineAccessorMutator{off}
@MmuxDefineAccessorMutator{pid}
@MmuxDefineAccessorMutator{uid}
@MmuxDefineAccessorMutator{gid}

@c page
@node memory arrays
@section Memory arrays accessors and mutators


If we allocate memory using the standard C library functions, we can poke and peek values in the
memory blocks, handling them as arrays of a specified C type:

@example
declare PTR VALUE

mmux_libc_malloc PTR $(( 55 * mmux_ulong_SIZEOF ))
@{
  mmux_ulong_array_set $PTR 0 1234567890
  mmux_ulong_array_ref VALUE $PTR 0
@}
mmux_libc_free $PTR
@end example

For all the following builtins, the argument:

@table @var
@item ARRAY
must be the string representation of a memory pointer referencing a previously allocated block; the
block is to be interpreted as an array of a specified C type;

@item INDEX
must be the string representation of an exact, non--negative integer, compatible with the C language
type @code{size_t}, itself representing an index in @var{ARRAY};

@item VALUE
must be the string representation of a number, compatible with a C language type of the specific
mutator: it is stored by the mutators at @var{INDEX} in @var{ARRAY};

@item VALUEVAR
must be a string representing the name of a shell variable: it is used by the accessors to store the
value extracted at @var{INDEX} from @var{ARRAY}.
@end table

For all the following builtins: if the operation is successful, the return value is true; otherwise
the return value is false and the shell variable @code{ERRNO} is set to the string representation of
an exact integer, itself representing an @code{errno} error code.

@ref{overview conventions, Conventions in coding and documentation}.

@macro MmuxDefineArrayAccessorMutator{STEM}
@deffn {Builtin Mutator} mmux_\STEM\_array_set @var{ARRAY} @var{INDEX} @var{VALUE}
@deffnx {Builtin Accessor} mmux_\STEM\_array_ref @var{VALUEVAR} @var{ARRAY} @var{INDEX}
Accessor and mutator for memory blocks operating on the C language type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineArrayAccessorMutator{pointer}

@MmuxDefineArrayAccessorMutator{schar}
@MmuxDefineArrayAccessorMutator{uchar}
@MmuxDefineArrayAccessorMutator{sshort}
@MmuxDefineArrayAccessorMutator{ushort}
@MmuxDefineArrayAccessorMutator{sint}
@MmuxDefineArrayAccessorMutator{uint}
@MmuxDefineArrayAccessorMutator{slong}
@MmuxDefineArrayAccessorMutator{ulong}
@MmuxDefineArrayAccessorMutator{sllong}
@MmuxDefineArrayAccessorMutator{ullong}
@MmuxDefineArrayAccessorMutator{float}
@MmuxDefineArrayAccessorMutator{double}
@MmuxDefineArrayAccessorMutator{ldouble}

@MmuxDefineArrayAccessorMutator{float32}
@MmuxDefineArrayAccessorMutator{float64}
@MmuxDefineArrayAccessorMutator{float128}

@MmuxDefineArrayAccessorMutator{float32x}
@MmuxDefineArrayAccessorMutator{float64x}
@MmuxDefineArrayAccessorMutator{float128x}

@MmuxDefineArrayAccessorMutator{decimal32}
@MmuxDefineArrayAccessorMutator{decimal64}
@MmuxDefineArrayAccessorMutator{decimal128}

@MmuxDefineArrayAccessorMutator{complexf}
@MmuxDefineArrayAccessorMutator{complexd}
@MmuxDefineArrayAccessorMutator{complexld}

@MmuxDefineArrayAccessorMutator{complexf32}
@MmuxDefineArrayAccessorMutator{complexf64}
@MmuxDefineArrayAccessorMutator{complexf128}

@MmuxDefineArrayAccessorMutator{complexf32x}
@MmuxDefineArrayAccessorMutator{complexf64x}
@MmuxDefineArrayAccessorMutator{complexf128x}

@MmuxDefineArrayAccessorMutator{complexd32}
@MmuxDefineArrayAccessorMutator{complexd64}
@MmuxDefineArrayAccessorMutator{complexd128}

@MmuxDefineArrayAccessorMutator{sint8}
@MmuxDefineArrayAccessorMutator{uint8}
@MmuxDefineArrayAccessorMutator{sint16}
@MmuxDefineArrayAccessorMutator{uint16}
@MmuxDefineArrayAccessorMutator{sint32}
@MmuxDefineArrayAccessorMutator{uint32}
@MmuxDefineArrayAccessorMutator{sint64}
@MmuxDefineArrayAccessorMutator{uint64}

@MmuxDefineArrayAccessorMutator{ssize}
@MmuxDefineArrayAccessorMutator{usize}
@MmuxDefineArrayAccessorMutator{sintmax}
@MmuxDefineArrayAccessorMutator{uintmax}
@MmuxDefineArrayAccessorMutator{sintptr}
@MmuxDefineArrayAccessorMutator{uintptr}
@MmuxDefineArrayAccessorMutator{mode}
@MmuxDefineArrayAccessorMutator{off}
@MmuxDefineArrayAccessorMutator{pid}
@MmuxDefineArrayAccessorMutator{uid}
@MmuxDefineArrayAccessorMutator{gid}

@c page
@node memory conversions
@section Converting data to and from memory blocks


@menu
* memory conversions arrays::   Converting data to and from index arrays.
@end menu

@c page
@node memory conversions arrays
@subsection Converting data to and from index arrays


@ref{overview conventions, Conventions in coding and documentation}.


@defun mmux_index_array_from_memory @var{ARRY_TO} @var{PTR_FROM} @var{SIZE}
Copy byte by byte data from a memory block into a Bash index array.

The argument @var{ARRY_TO} must be a string representing the name of a Bash index array; this
function stores in this array the bytes from the memory block, starting from index zero.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5

mmux_libc_malloc POINTER @RR{SIZE}
@{
    declare -a ARRY

    mmux_uint8_pointer_set @RR{POINTER} 0 '11'
    mmux_uint8_pointer_set @RR{POINTER} 1 '22'
    mmux_uint8_pointer_set @RR{POINTER} 2 '33'
    mmux_uint8_pointer_set @RR{POINTER} 3 '44'
    mmux_uint8_pointer_set @RR{POINTER} 4 '55'
    mmux_index_array_from_memory ARRY @RR{POINTER} @RR{SIZE}
    $@{ARRY[0]@}        @result{} 11
@}
mmux_libc_free @RR{POINTER}
@end example
@end defun


@defun mmux_index_array_to_memory @var{PTR_TO} @var{ARRY_FROM} @var{SIZE}
Copy byte by byte data from a Bash index array into a memory block.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the target of the copy operation.

The argument @var{ARRY_FROM} must be a string representing the name of a Bash index array; this
function reads from this array the bytes to store in the memory block, starting from index zero.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a ARRY=(11 22 33 44 55)

mmux_libc_malloc POINTER $SIZE
@{
    declare BYTE

    mmux_index_array_to_memory @RR{POINTER} ARRY @RR{SIZE}
    mmux_uint8_pointer_ref BYTE @RR{POINTER} 0
    @RR{BYTE}   @result{} 11
@}
mmux_libc_free @RR{POINTER}
@end example
@end defun

@c page
@node memory comparison
@section Comparing memory blocks


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_memcmp @var{SINTVAR} @vari{PTR} @varii{PTR} @var{USIZE}
Interface to the standard C language function @cfunc{memcmp}; @cfuncpage{memcmp}.  Bind to the shell
variable @var{SINTVAR} the value returned by the function.
@end deffn

@c page
@node memory searching
@section Searching in memory blocks


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_memchr @var{PTRVAR} @var{POINTER} @var{UCHAR} @var{USIZE}
Interface to the standard C language function @cfunc{memchr}; @cfuncpage{memchr}.  Bind to the shell
variable @var{PTRVAR} the value returned by the function.

@example
declare PTR RESULT_PTR
declare -i LEN

mmux_pointer_from_bash_string PTR 'CIAO MAMMA'
@{
    mmux_libc_strlen LEN @RR{PTR}
    mmux_libc_memchr RESULT_PTR @RR{PTR} 65 @RR{LEN}
    ...
@}
mmux_libc_free @RR{PTR}
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_rawmemchr @var{PTRVAR} @var{POINTER} @var{UCHAR}
Interface to the extension C language function @cfunc{rawmemchr}; @cfuncpage{rawmemchr}.  Bind to
the shell variable @var{PTRVAR} the value returned by the function.
@end deffn


@deffn Builtin mmux_libc_memrchr @var{PTRVAR} @var{POINTER} @var{UCHAR} @var{USIZE}
Interface to the standard C language function @cfunc{memrchr}; @cfuncpage{memrchr}.  Bind to the
shell variable @var{PTRVAR} the value returned by the function.
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_memmem @var{PTRVAR} @var{HAYSTACK_PTR} @var{HAYSTACK_LEN} @var{NEEDLE_PTR} @var{NEEDLE_LEN}
Interface to the extension C language function @cfunc{memmem}; @cfuncpage{memmem}.  Bind to the
shell variable @var{PTRVAR} the value returned by the function.
@end deffn

@c page
@node strings
@chapter @asciiz{} strings


@menu
* strings conversion::          Converting @asciiz{} strings to other representations.
* strings inspection::          Inspecting @asciiz{} strings.
* strings duplication::         Duplicating @asciiz{} strings.
* strings concatenation::       Concatenating @asciiz{} strings.
* strings comparison::          Comparing @asciiz{} strings.
* strings collation::           Collation builtins for @asciiz{} strings.
* strings searching::           Searching in @asciiz{} strings.
* strings tokens::              Finding tokens in @asciiz{} strings.
@end menu

@c page
@node strings conversion
@section Converting @asciiz{} strings to other representations


@gnu{} Bash's internal string representation is @asciiz{}; we can only have read--only access to
Bash strings in certain timespans while a builtin is evaluated; Bash itself owns the memory.  To
convert between Bash strings and raw memory strings owned by client code, without error checking, we
do:

@example
declare PTR STR
declare -i LEN

mmux_pointer_from_bash_string PTR 'ciao'
@{
    mmux_libc_strlen LEN @RR{PTR}
    mmux_pointer_to_bash_string STR @RR{PTR} @RR{LEN}
    @WW{STR}    @result{} "ciao"
@}
mmux_libc_free @RR{PTR}
@end example

@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_pointer_from_bash_string @var{PTRVAR} @var{STRING}
Take a Bash string argument @var{STRING}, duplicate it allocating memory with @cfunc{malloc}, then
bind the string representation of the resulting pointer to the shell variable name @var{PTRVAR}.

If an error occurs allocating memory: the return value is false and the shell variable @var{PTRVAR}
is left untouched.
@end deffn


@deffn Builtin mmux_pointer_to_bash_string @var{STRVAR} @var{ASCIIZ_POINTER}
@deffnx Builtin mmux_pointer_to_bash_string @var{STRVAR} @var{ASCIIZ_POINTER} @var{USIZE}
Convert into a Bash string the @var{USIZE} bytes starting at offset zero from @var{ASCIIZ_POINTER}.
If @var{USIZE} is not present: @var{ASCIIZ_POINTER} is meant to reference an @asciiz{} string, which
will be fully duplicated into a Bash string.  The new Bash string is bound to the shell variable
whose name is @var{STRVAR}.

If an error occurs allocating memory: the return value is false and the shell variable @var{PTRVAR}
is left untouched.
@end deffn

@c page
@node strings inspection
@section Inspecting @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strlen @var{USIZEVAR} @var{ASCIIZ_POINTER}
Interface to the standard C language function @cfunc{strlen}.  Compute the length, measured in
bytes, of the @asciiz{} string referenced by @var{ASCIIZ_POINTER} and store it in the shell variable
@var{USIZEVAR}.

@example
declare PTR LEN

mmux_libc_malloc PTR 5
@{
    mmux_schar_pointer_set @RR{PTR} 0 65
    mmux_schar_pointer_set @RR{PTR} 1 66
    mmux_schar_pointer_set @RR{PTR} 2 67
    mmux_schar_pointer_set @RR{PTR} 3 68
    mmux_schar_pointer_set @RR{PTR} 4 0

    mmux_libc_strlen LEN @RR{PTR}
    @RR{LEN}    @result{} 4
@}
mmux_libc_free @RR{PTR}
@end example
@end deffn


@deffn Builtin mmux_libc_strnlen @var{USIZEVAR} @var{ASCIIZ_POINTER} @var{USIZE_MAX}
Interface to the standard C language function @cfunc{strnlen}; @cfuncpage{strnlen}.
@end deffn

@c page
@node strings duplication
@section Duplicating @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strcpy @var{PTR_TO} @var{PTR_FROM}
Interface to the standard C language function @cfunc{strcpy}; @cfuncpage{strcpy}.

@example
declare -r ORIGINAL_STRING='ciao mamma'
declare PTR2 PTR1
declare -i LEN

mmux_pointer_from_bash_string PTR1 @WW{ORIGINAL_STRING}
@{
    mmux_libc_strlen LEN @RR{PTR1}
    mmux_usize_incr  LEN @RR{LEN}

    mmux_libc_malloc PTR2 @RR{LEN}
    @{
        mmux_libc_strcpy @RR{PTR2} @RR{PTR1}
        ...
    @}
    mmux_libc_free @WW{PTR2}
@}
mmux_libc_free @RR{PTR1}
@end example
@end deffn


@deffn Builtin mmux_libc_strncpy @var{PTR_TO} @var{PTR_FROM} @var{SSIZE}
Interface to the standard C language function @cfunc{strncpy}; @cfuncpage{strncpy}.
@end deffn


@deffn Builtin mmux_libc_stpcpy @var{AFTER_PTR_VAR} @var{PTR_TO} @var{PTR_FROM}
Interface to the standard C language function @cfunc{stpcpy}; @cfuncpage{stpcpy}.  Like
@MmuxBuiltin{mmux_libc_strcpy} but, when successful, bind to the shell variable @var{AFTER_PTR_VAR}
the string representation of a pointer to the null character in the memory block referenced by
@var{PTR_TO}.
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_stpncpy @var{AFTER_PTR_VAR} @var{PTR_TO} @var{PTR_FROM} @var{SSIZE}
Interface to the standard C language function @cfunc{stpncpy}; @cfuncpage{stpncpy}.  If we want the
destination buffer to contain the terminating null character: the null character from the source
buffer must be among the first @var{SSIZE} characters.

@example
declare -r ORIGINAL_STRING='ciao mamma'
declare PTR1 PTR2 AFTER_PTR
declare -i LEN LEN_PLUS

mmux_pointer_from_bash_string PTR1 @WW{ORIGINAL_STRING}
@{
    # Compute LEN_PLUS to include the terminating null character
    # from the source buffer.
    mmux_libc_strlen LEN @WW{PTR1}
    mmux_usize_incr LEN_PLUS @RR{LEN}

    mmux_libc_malloc PTR2 @RR{LEN_PLUS}
    @{
        mmux_libc_stpncpy AFTER_PTR @RR{PTR2} @RR{PTR1} @RR{LEN_PLUS}
        # Here $AFTER_PTR references the null character at the end of
        # the destination buffer.
    @}
    mmux_libc_free @WW{PTR2}
@}
mmux_libc_free @RR{PTR1}
@end example
@end deffn


@deffn Builtin mmux_libc_strdup @var{ASCIIZ_PTRVAR} @var{ASCIIZ_POINTER}
Interface to the standard C language function @cfunc{strdup}; @cfuncpage{strdup}.

@example
declare PTR1 PTR2

mmux_pointer_from_bash_string PTR1 'ciao mamma'
@{
    mmux_libc_strdup PTR2 @RR{PTR1}
    @{
        ...
    @}
    mmux_libc_free @RR{PTR2}
@}
mmux_libc_free @RR{PTR1}
@end example
@end deffn


@deffn Builtin mmux_libc_strndup @var{ASCIIZ_PTRVAR} @var{ASCIIZ_POINTER} @var{SSIZE}
Interface to the standard C language function @cfunc{strndup}; @cfuncpage{strndup}.
@end deffn

@c page
@node strings concatenation
@section Concatenating @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strcat @var{PTR_TO} @var{PTR_FROM}
Interface to the standard C language function @cfunc{strcat}; @cfuncpage{strcat}.

@example
declare -r ORIGINAL_STRING1='ciao ' ORIGINAL_STRING2='mamma'
declare STRING PTR1 PTR2 PTR3
declare -i LEN1 LEN2 LEN3 LEN3_PLUS

mmux_pointer_from_bash_string PTR1 @WW{ORIGINAL_STRING1}
@{
    mmux_pointer_from_bash_string PTR2 @WW{ORIGINAL_STRING2}
    @{
        mmux_libc_strlen LEN1 @RR{PTR1}
        mmux_libc_strlen LEN2 @RR{PTR2}
        mmux_usize_add LEN3 @RR{LEN2} @RR{LEN1}
        mmux_usize_incr LEN3_PLUS @RR{LEN3}

        mmux_libc_malloc PTR3 @RR{LEN3_PLUS}
        @{
            # Put a null character at the end of the destination string!
            mmux_schar_pointer_set @RR{PTR3} 0 0

            mmux_libc_strcat @RR{PTR3} @RR{PTR1}
            mmux_libc_strcat @RR{PTR3} @RR{PTR2}
            mmux_pointer_to_bash_string STRING @RR{PTR3}
            @WW{STRING} @result{} ciao mamma
        @}
        mmux_libc_free @RR{PTR3}
    @}
    mmux_libc_free @RR{PTR2}
@}
mmux_libc_free @RR{PTR1}
@end example
@end deffn


@deffn Builtin mmux_libc_strncat @var{PTR_TO} @var{PTR_FROM} @var{SSIZE}
Interface to the standard C language function @cfunc{strncat}; @cfuncpage{strncat}.  This builtin
always appends a null character to the destination buffer after copying at most @var{SSIZE} bytes
from the source buffer.
@end deffn

@c page
@node strings comparison
@section Comparing @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strcmp @var{SINTVAR} @vari{PTR} @varii{PTR}
Interface to the standard C language function @cfunc{strcmp}; @cfuncpage{strcmp}.  A string
representation of the C language ternary return value is bound to the shell variable @var{SINTVAR}.

@example
declare PTR1 PTR2
declare -i TERNARY

mmux_pointer_from_bash_string PTR1 'ciao mamma'
@{
    mmux_pointer_from_bash_string PTR2 'hello world'
    @{
        mmux_libc_strcmp TERNARY @WW{PTR1} @WW{PTR2}
        (( 0 == TERNARY ))
    @}
    mmux_libc_free @RR{PTR2}
@}
mmux_libc_free @RR{PTR1}
@end example
@end deffn


@deffn Builtin mmux_libc_strncmp @var{SINTVAR} @vari{PTR} @varii{PTR} @var{USIZE_LEN}
Interface to the standard C language function @cfunc{strncmp}; @cfuncpage{strncmp}.  A string
representation of the C language ternary return value is bound to the shell variable @var{SINTVAR}.
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_strcasecmp @var{SINTVAR} @vari{PTR} @varii{PTR}
Interface to the extension C language function @cfunc{strncmp}; @cfuncpage{strncmp}.  A string
representation of the C language ternary return value is bound to the shell variable @var{SINTVAR}.
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_strncasecmp @var{SINTVAR} @vari{PTR} @varii{PTR} @var{USIZE_LEN}
Interface to the extension C language function @cfunc{strncasecmp}; @cfuncpage{strncasecmp}.  A
string representation of the C language ternary return value is bound to the shell variable
@var{SINTVAR}.
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_strverscmp @var{SINTVAR} @vari{PTR} @varii{PTR}
Interface to the extension C language function @cfunc{strverscmp}; @cfuncpage{strverscmp}.  A string
representation of the C language ternary return value is bound to the shell variable @var{SINTVAR}.

@example
declare PTR1 PTR2
declare -i TERNARY

mmux_pointer_from_bash_string PTR1 '1.2.3'
@{
    mmux_pointer_from_bash_string PTR2 '1.2.9'
    @{
        mmux_libc_strverscmp TERNARY @WW{PTR1} @WW{PTR2}
        (( 0 > TERNARY ))
    @}
    mmux_libc_free @RR{PTR2}
@}
mmux_libc_free @RR{PTR1}
@end example
@end deffn

@c page
@node strings collation
@section Collation builtins for @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strcoll @var{SINTVAR} @vari{PTR} @varii{PTR}
Interface to the standard C language function @cfunc{strcoll}; @cfuncpage{strcoll}.  A string
representation of the C language ternary return value is bound to the shell variable @var{SINTVAR}.
@end deffn


@deffn Builtin mmux_libc_strxfrm @var{RESULT_USIZE_VAR} @vari{PTR} @varii{PTR} @var{ULEN}
Interface to the standard C language function @cfunc{strxfrm}; @cfuncpage{strxfrm}.  A string
representation of the C language return value is bound to the shell variable @var{RESULT_USIZE_VAR}.
@end deffn

@c page
@node strings searching
@section Searching in @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strchr @var{RESULT_ASCIIZ_PTRVAR} @var{ASCIIZ_PTR} @var{SCHAR}
Interface to the standard C language function @cfunc{strchr}; @cfuncpage{strchr}.

@example
declare PTR RESULT_PTR

mmux_pointer_from_bash_string PTR 'CIAO MAMMA'
@{
    mmux_libc_strchr RESULT_PTR @RR{PTR} 65
    ...
@}
mmux_libc_free @RR{PTR}
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_strchrnul @var{RESULT_ASCIIZ_PTRVAR} @var{ASCIIZ_PTR} @var{SCHAR}
Interface to the extension C language function @cfunc{strchrnul}; @cfuncpage{strchrnul}.
@end deffn


@deffn Builtin mmux_libc_strrchr @var{RESULT_ASCIIZ_PTRVAR} @var{ASCIIZ_PTR} @var{SCHAR}
Interface to the standard C language function @cfunc{strrchr}; @cfuncpage{strrchr}.
@end deffn


@deffn Builtin mmux_libc_strstr @var{RESULT_ASCIIZ_PTRVAR} @var{ASCIIZ_HAYSTACK_PTR} @var{ASCIIZ_NEEDLE_PTR}
Interface to the standard C language function @cfunc{strstr}; @cfuncpage{strstr}.
@end deffn


@deffn Builtin mmux_libc_strcasestr @var{RESULT_ASCIIZ_PTRVAR} @var{ASCIIZ_HAYSTACK_PTR} @var{ASCIIZ_NEEDLE_PTR}
Interface to the standard C language function @cfunc{strcasestr}; @cfuncpage{strcasestr}.
@end deffn


@deffn Builtin mmux_libc_strspn @var{USIZEVAR} @var{ASCIIZ_PTR} @var{ASCIIZ_SKIPSET_PTR}
Interface to the standard C language function @cfunc{strspn}; @cfuncpage{strspn}.
@end deffn


@deffn Builtin mmux_libc_strcspn @var{USIZEVAR} @var{ASCIIZ_PTR} @var{ASCIIZ_STOPSET_PTR}
Interface to the standard C language function @cfunc{strcspn}; @cfuncpage{strcspn}.
@end deffn


@deffn Builtin mmux_libc_strpbrk @var{ASCIIZ_RESULT_PTRVAR} @var{ASCIIZ_PTR} @var{ASCIIZ_STOPSET_PTR}
Interface to the standard C language function @cfunc{strpbrk}; @cfuncpage{strpbrk}.
@end deffn

@c page
@node strings tokens
@section Finding tokens in @asciiz{} strings


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_strtok @var{ASCIIZ_RESULT_PTRVAR} @var{ASCIIZ_NEWSTRING_PTR} @var{ASCIIZ_DELIMITERS_PTR}
Interface to the standard C language function @cfunc{strtok}; @cfuncpage{strtok}.

@example
declare STRING
declare -a TOKEN

mmux_pointer_from_bash_string STRING 'uno due tre quattro '
@{
    mmux_pointer_from_bash_string DELIMITERS ' '
    @{
        mmux_libc_strtok @SS{TOKEN,0} @RR{STRING} @RR{DELIMITERS}
        mmux_libc_strtok @SS{TOKEN,1} 0           @RR{DELIMITERS}
        mmux_libc_strtok @SS{TOKEN,2} 0           @RR{DELIMITERS}
        mmux_libc_strtok @SS{TOKEN,3} 0           @RR{DELIMITERS}

        mmux_pointer_to_bash_string @SS{TOKEN,0} @WW{TOKEN[0]}
        mmux_pointer_to_bash_string @SS{TOKEN,1} @WW{TOKEN[1]}
        mmux_pointer_to_bash_string @SS{TOKEN,2} @WW{TOKEN[2]}
        mmux_pointer_to_bash_string @SS{TOKEN,3} @WW{TOKEN[3]}

        @WW{TOKEN[0]}   @result{} uno
        @WW{TOKEN[1]}   @result{} due
        @WW{TOKEN[2]}   @result{} tre
        @WW{TOKEN[3]}   @result{} quattro
    @}
    mmux_libc_free @RR{DELIMITERS}
@}
mmux_libc_free @RR{STRING}
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_basename @var{ASCIIZ_RESULT_PTRVAR} @var{ASCIIZ_PATHNAME_PTR}
Interface to the extension C language function @cfunc{basename}; @cfuncpage{basename}.

@example
declare PATHNAME RESULT

mmux_pointer_from_bash_string PATHNAME '/path/to/filename.ext'
@{
    mmux_libc_basename RESULT @RR{PATHNAME}
    mmux_pointer_to_bash_string RESULT @WW{RESULT}
    @WW{RESULT} @result{} filename.ext
@}
mmux_libc_free @RR{PATHNAME}
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_dirname @var{ASCIIZ_RESULT_PTRVAR} @var{ASCIIZ_PATHNAME_PTR}
Interface to the extension C language function @cfunc{dirname}; @cfuncpage{dirname}.

@example
declare PATHNAME RESULT

mmux_pointer_from_bash_string PATHNAME '/path/to/filename.ext'
@{
    mmux_libc_dirname RESULT @RR{PATHNAME}
    mmux_pointer_to_bash_string RESULT @WW{RESULT}
    @WW{RESULT} @result{} /path/to
@}
mmux_libc_free @RR{PATHNAME}
@end example
@end deffn

@c page
@node fds
@chapter Core file descriptor operations


@deffn Builtin mmux_libc_open @var{FDVAR} @var{FILENAME} @var{FLAGS}
@deffnx Builtin mmux_libc_open @var{FDVAR} @var{FILENAME} @var{FLAGS} @var{MODE}
Interface to the standard C function @cfunc{open}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{FDVAR} must be a string representing a shell variable name; when the operation is
successful: a string representing the new file descriptor is stored in the variable.

The argument @var{FILENAME} must be a string representing the file pathname.

The argument @var{FLAGS} must be a string representing the exact integer resulting from the bitwise
OR combination of the flags supported by the standard function.

The optional argument @var{MODE} must a string representing the exact integer resulting from the
bitwise OR combination of the mode flags supported by the standard function; when not present it
defaults to @samp{0}.

@example
declare FILENAME='/path/to/name.ext'
declare -i FLAGS=$((mmux_libc_O_RDWR | mmux_libc_O_CREAT))
declare -i MODE=$((mmux_libc_S_IRUSR | mmux_libc_S_IWUSR))
declare -i FD ERRNO

if ! mmuc_libc_open FD "$FILENAME" $FLAGS $MODE
then # handle the error
fi
@end example
@end deffn


@deffn Builtin mmux_libc_openat @var{FDVAR} @var{DIRFD} @var{FILENAME} @var{FLAGS}
@deffnx Builtin mmux_libc_openat @var{FDVAR} @var{DIRFD} @var{FILENAME} @var{FLAGS} @var{MODE}
Interface to the standard C function @cfunc{openat}, @cfuncpage{openat}.
@end deffn


@deffn Builtin mmux_libc_close @var{FD}
Interface to the standard C function @cfunc{close}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{FD} must be the string representation of a file descriptor.
@end deffn


@deffn Builtin mmux_libc_read @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE}
Interface to the standard C function @cfunc{read}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{read} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from the file descriptor and write to memory; it must be compatible with
the type @objtype{usize}.

@example
declare -i ERRNO; # to be used in case of error
declare -i ITEM_SIZE=$mmux_sint32_SIZEOF
declare -i ITEM_COUNT=123
declare BUFFER

@{
    declare -i OCTET_SIZE=$(( ITEM_SIZE * ITEM_COUNT ))

    if ! mmux_libc_calloc BUFFER $ITEM_COUNT $ITEM_SIZE
    then # error
    fi

    @{
        declare -i DONE FD=$(gimme-an-fd)

        if ! mmux_libc_read DONE $FD $BUFFER $OCTET_SIZE
        then # error
        fi
    @}
@}

@{
    declare -a VALUES

    mmux_sint32_array_ref 'VALUES[0]' $BUFFER 0
    mmux_sint32_array_ref 'VALUES[1]' $BUFFER 1
@}
@end example
@end deffn


@deffn Builtin mmux_libc_write @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE}
Interface to the standard C function @cfunc{write}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{write} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from memory and write to the file descriptor; it must be compatible with
the type @objtype{usize}.

@example
declare -i ERRNO; # to be used in case of error
declare -i ITEM_SIZE=$mmux_sint32_SIZEOF ITEM_COUNT=123
declare BUFFER

if ! mmux_libc_calloc BUFFER $ITEM_COUNT $ITEM_SIZE
then # error
fi

@{
    mmux_sint32_array_set $BUFFER 0 '123'
    mmux_sint32_array_set $BUFFER 1 '456'
    # ...
@}

@{
    declare -i FD=$(gimme-an-fd)
    declare -i OCTET_SIZE=$(( ITEM_SIZE * ITEM_COUNT ))
    declare -i DONE

    if ! mmux_libc_write DONE $FD $BUFFER $OCTET_SIZE
    then # error
    fi
@}
@end example
@end deffn


@deffn Builtin mmux_libc_pread @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE} @var{OFFSET}
Interface to the standard C function @cfunc{pread}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{read} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from the file descriptor and write to memory; it must be compatible with
the type @objtype{usize}.

The argument @var{OFFSET} must be the string representation of an exact, non-negative, integer being
the offset from the start of the file for the read operation; it must be compatible with the type
@objtype{usize}.
@end deffn


@deffn Builtin mmux_libc_pwrite @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE} @var{OFFSET}
Interface to the standard C function @cfunc{pwrite}.  When successful: return true; otherwise set
the shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return
false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{pwrite} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from memory and write to the file descriptor; it must be compatible with
the type @objtype{usize}.

The argument @var{OFFSET} must be the string representation of an exact, non-negative, integer being
the offset from the start of the file for the write operation; it must be compatible with the type
@objtype{off}.
@end deffn


@deffn Builtin mmux_libc_lseek @var{OFFVAR} @var{FD} @var{OFFSET} @var{WHENCE}
Interface to the standard C function @cfunc{lseek}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{OFFVAR} must be the name of a shell variable in which the return value of
@cfunc{lseek} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{OFFSET} must be the string representation of an exact, non-negative, integer being
the offset from the position selected by @var{WHENCE}; it must be compatible with the type
@objtype{off}.

The argument @var{WHENCE} must be the string representation of an exact, non-negative, integer being
one of the constants @code{mmux_libc_SEEK_SET}, @code{mmux_libc_SEEK_CUR},
@code{mmux_libc_SEEK_END}, and others if supported.

@example
declare -i RESULT_OFFSET ERRNO FD=$(gimme-an-fd)

if ! mmux_libc_lseek RESULT_OFFSET $FD 123 $mmux_libc_SEEK_CUR
then # error
fi
@end example
@end deffn


@deffn Builtin mmux_libc_dup @var{FDVAR} @var{OLD_FD}
Interface to the standard C function @cfunc{dup}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{FDVAR} must be the name of a shell variable in which the return value of
@cfunc{dup} will be stored.

The argument @var{OLD_FD} must be the string representation of a file descriptor.
@end deffn


@deffn Builtin mmux_libc_dup2 @var{RVAR} @var{OLD_FD} @var{NEW_FD}
Interface to the standard C function @cfunc{dup2}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{rDVAR} must be the name of a shell variable in which the return value of
@cfunc{dup} will be stored.

The argument @var{OLD_FD} must be the string representation of a file descriptor.

The argument @var{NEW_FD} must be the string representation of a file descriptor.
@end deffn

@c page
@node fs
@chapter File system interface


@menu
* fs errors::                   How to handle errors.
* fs links::                    Hard and symbolic link builtins.
* fs deleting::                 Deleting links builtins.
* fs renaming::                 Renaming links builtins.
* fs directories::              Directory builtins.
* fs ownership::                File ownership builtins.
@end menu

@c page
@node fs errors
@section How to handle errors


Unless otherwise specified: the file system builtins return false when an error occurs and set the
shell variable @env{ERRNO}.  To handle an error we should do something like:

@example
declare -i ERRNO

if ! mmux_libc_link 'oldname.ext' 'newname.ext'
then
    declare ERRMSG

    mmux_libc_strerror ERRMSG @RR{ERRNO}
    printf 'link: error: %s\n' @WW{ERRMSG} >&2
fi
@end example

@c page
@node fs links
@section Hard and symbolic link builtins


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_link @var{OLDNAME} @var{NEWNAME}
Interface to the standard C language function @cfunc{link}, @glibcref{Hard Links, link}.

@example
mmux_libc_link 'oldname.ext' 'newname.ext'
@end example
@end deffn


@deffn Builtin mmux_libc_linkat @var{OLDFD} @var{OLDNAME} @var{NEWFD} @var{NEWNAME} @var{FLAGS}
Interface to the standard C language function @cfunc{linkat}, @glibcref{Hard Links, linkat}.

@example
mmux_libc_linkat @RR{mmux_libc_AT_FDCWD} 'oldname.ext' \
                 @RR{mmux_libc_AT_FDCWD} 'newname.ext' \
                 @RR{mmux_libc_AT_SYMLINK_FOLLOW}
@end example
@end deffn


@deffn Builtin mmux_libc_symlink @var{OLDNAME} @var{NEWNAME}
Interface to the standard C language function @cfunc{symlink}, @glibcref{Symbolic Links, symlink}.

@example
mmux_libc_symlink 'oldname.ext' 'newname.ext'
@end example
@end deffn


@deffn Builtin mmux_libc_readlink @var{REAL_PATHNAME_VAR} @var{PATHNAME}
Interface to the standard C language function @cfunc{readlink}, @glibcref{Symbolic Links, readlink}.

@example
declare PATHNAME

mmux_libc_symlink 'oldname.ext' 'newname.ext'
mmux_libc_readlink PATHNAME 'newname.ext'
@WW{PATHNAME}      @result{} oldname.ext
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_canonicalize_file_name @var{REAL_PATHNAME_VAR} @var{PATHNAME}
Interface to the extension C language function @cfunc{canonicalize_file_name}, @glibcref{Symbolic
Links, canonicalize_file_name}.
@end deffn


@deffn Builtin mmux_libc_realpath @var{REAL_PATHNAME_VAR} @var{PATHNAME}
Interface to the standard C language function @cfunc{realpath}, @glibcref{Symbolic Links, realpath}.
@end deffn

@c page
@node fs deleting
@section Deleting links builtins


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_unlink @var{PATHNAME}
Interface to the standard C language function @cfunc{unlink}, @glibcref{Deleting Files, unlink}.

@example
mmux_libc_unlink 'filename.ext'
@end example
@end deffn


@deffn Builtin mmux_libc_unlinkat @var{DIRFD} @var{PATHNAME} @var{FLAGS}
Interface to the standard C language function @cfunc{unlinkat}, @cfuncpage{unlinkat}.

@example
mmux_libc_unlinkat @RR{mmux_libc_AT_FDCWD} 'filename.ext' 0
@end example
@end deffn


@deffn Builtin mmux_libc_rmdir @var{PATHNAME}
Interface to the standard C language function @cfunc{rmdir}, @glibcref{Deleting Files, rmdir}.
@end deffn


@deffn Builtin mmux_libc_remove @var{PATHNAME}
Interface to the standard C language function @cfunc{remove}, @glibcref{Deleting Files, remove}.
@end deffn

@c page
@node fs renaming
@section Renaming links builtins


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_rename @var{PATHNAME}
Interface to the standard C language function @cfunc{rename}, @glibcref{Deleting Files, rename}.

@example
mmux_libc_rename 'oldname.ext' 'newname.ext'
@end example
@end deffn


@deffn Builtin mmux_libc_renameat @var{OLDDIRFD} @var{OLDNAME} @var{NEWDIRFD} @var{NEWNAME}
Interface to the standard C language function @cfunc{renameat}, @cfuncpage{renameat}.

@example
mmux_libc_renameat @RR{mmux_libc_AT_FDCWD} 'oldname.ext' \
                   @RR{mmux_libc_AT_FDCWD} 'newname.ext'
@end example
@end deffn


@deffn {Linux Builtin} mmux_libc_renameat2 @var{OLDDIRFD} @var{OLDNAME} @var{NEWDIRFD} @var{NEWNAME}
Interface to the standard C language function @cfunc{renameat2}, @cfuncpage{renameat2}.

@example
mmux_libc_renameat2 @RR{mmux_libc_AT_FDCWD} 'oldname.ext' \
                    @RR{mmux_libc_AT_FDCWD} 'newname.ext' \
                    @RR{mmux_libc_RENAME_EXCHANGE}
@end example
@end deffn

@c page
@node fs directories
@section Directory builtins


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_mkdir @var{PATHNAME} @var{MODE}
Interface to the standard C language function @cfunc{mkdir}, @glibcref{Creating Directories, mkdir}.

@example
mmux_libc_mkdir 'pathname.d' @RR{mmux_libc_S_IRUSR}
@end example
@end deffn


@deffn Builtin mmux_libc_mkdirat @var{DIRFD} @var{PATHNAME} @var{MODE}
Interface to the standard C language function @cfunc{mkdirat}, @cfuncpage{mkdirat}.

@example
mmux_libc_mkdirat @RR{mmux_libc_AT_FDCWD} 'pathname.d' @RR{mmux_libc_S_IRUSR}
@end example
@end deffn

@c page
@node fs ownership
@section File ownership builtins


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_chown @var{PATHNAME} @var{UID} @var{GID}
Interface to the standard C language function @cfunc{chown}, @glibcref{File Owner, chown}.
@end deffn


@deffn Builtin mmux_libc_fchown @var{FD} @var{UID} @var{GID}
Interface to the standard C language function @cfunc{fchown}, @glibcref{File Owner, fchown}.
@end deffn


@deffn Builtin mmux_libc_lchown @var{PATHNAME} @var{UID} @var{GID}
Interface to the standard C language function @cfunc{lchown}, @cfuncpage{lchown}.
@end deffn


@deffn Builtin mmux_libc_fchownat @var{DIRFD} @var{PATHNAME} @var{UID} @var{GID} @var{FLAGS}
Interface to the standard C language function @cfunc{fchownat}, @cfuncpage{fchownat}.
@end deffn

@c page
@node persona
@chapter Persona operations


@menu
* persona getting::             Getting users and groups.
* persona setting::             Setting users and groups.
* persona login::               Identifying who logged in.
* persona database user::       User database.
* persona database group::      Group database.
@end menu

@c page
@node persona getting
@section Getting users and groups


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_getuid @var{UIDVAR}
Interface to the standard C language function @cfunc{getuid}, @glibcref{Reading Persona, getuid}.

@example
declare THE_UID
mmux_libc_getuid THE_UID
@end example
@end deffn


@deffn Builtin mmux_libc_getgid @var{GIDVAR}
Interface to the standard C language function @cfunc{getgid}, @glibcref{Reading Persona, getgid}.
@end deffn


@deffn Builtin mmux_libc_geteuid @var{UIDVAR}
Interface to the standard C language function @cfunc{geteuid}, @glibcref{Reading Persona, geteuid}.
@end deffn


@deffn Builtin mmux_libc_getegid @var{GIDVAR}
Interface to the standard C language function @cfunc{getegid}, @glibcref{Reading Persona, getegid}.
@end deffn


@deffn Builtin mmux_libc_getgroups @var{INDEX_ARRAY_VARNAME}
Interface to the standard C language function @cfunc{getgroups}, @glibcref{Reading Persona, getgroups}.

@example
declare -a THE_GIDS
mmux_libc_getgroups THE_GIDS
@end example
@end deffn


@deffn Builtin mmux_libc_getgrouplist @var{INDEX_ARRAY_VARNAME} @var{USERNAME} @var{GID}
Interface to the standard C language function @cfunc{getgrouplist}, @glibcref{Reading Persona, getgrouplist}.

@example
declare -a THE_GIDS
mmux_libc_getgroups THE_GIDS 'marco' 1000

$@{THE_GIDS[0]@}        @result{} 1000
$@{THE_GIDS[1]@}        @result{} 7
@end example
@end deffn


@deffn {@gnu{} Builtin} mmux_libc_group_member @var{BOOLVAR} @var{GID}
Interface to the extension C language function @cfunc{group_member}, @cfuncpage{group_member}.

@example
declare SOME_GID=...
declare -i BOOL

mmux_libc_group_member BOOL @WW{SOME_GID}
if (( 1 == BOOL ))
then # it is a member
else # it is not
fi
@end example
@end deffn


@c page
@node persona setting
@section Setting users and groups


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_setuid @var{UID}
Interface to the standard C language function @cfunc{setuid}, @glibcref{Setting User ID, setuid}.
@end deffn


@deffn Builtin mmux_libc_seteuid @var{UID}
Interface to the standard C language function @cfunc{seteuid}, @glibcref{Setting User ID, seteuid}.
@end deffn


@deffn Builtin mmux_libc_setreuid @var{RUID} @var{EUID}
Interface to the standard C language function @cfunc{setreuid}, @glibcref{Setting User ID, setreuid}.
@end deffn


@deffn Builtin mmux_libc_setgid @var{GID}
Interface to the standard C language function @cfunc{setgid}, @glibcref{Setting Groups, setgid}.
@end deffn


@deffn Builtin mmux_libc_setegid @var{GID}
Interface to the standard C language function @cfunc{setegid}, @glibcref{Setting Groups, setegid}.
@end deffn


@deffn Builtin mmux_libc_setregid @var{RGID} @var{EGID}
Interface to the standard C language function @cfunc{setregid}, @glibcref{Setting Groups, setregid}.
@end deffn

@c page
@node persona login
@section Identifying who logged in


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_getlogin @var{USERNAMEVAR}
Interface to the standard C language function @cfunc{getlogin}, @glibcref{Who Logged In, getlogin}.

@example
declare USERNAME
mmux_libc_getlogin USERNAME
@WW{USERNAME}   @result{} marco
@end example
@end deffn


@deffn Builtin mmux_libc_cuserid @var{USERNAMEVAR}
Interface to the standard C language function @cfunc{cuserid}, @glibcref{Who Logged In, cuserid}.
@end deffn

@c page
@node persona database user
@section User database


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_getpwuid @var{PASSWD_POINTER_VAR} @var{UID}
Interface to the standard C language function @cfunc{getpwuid}, @glibcref{Lookup User, getpwuid}.

Bind the shell variable whose name is @var{PASSWD_POINTER_VAR} to a string representation of a
pointer to the @code{struct passwd} returned by the internal call to @cfunc{getpwuid}.  This value
can be @cnull{} if there is no database entry associated to @var{UID}.

@example
declare PASSWD
declare PW_NAME PW_PASSWD PW_UID PW_GID PW_GECOS PW_DIR PW_SHELL

mmux_libc_getpwuid PASSWD @RR{UID}
mmux_libc_pw_name   PW_NAME   @RR{PASSWD}
mmux_libc_pw_passwd PW_PASSWD @RR{PASSWD}
mmux_libc_pw_uid    PW_UID    @RR{PASSWD}
mmux_libc_pw_gid    PW_GID    @RR{PASSWD}
mmux_libc_pw_gecos  PW_GECOS  @RR{PASSWD}
mmux_libc_pw_dir    PW_DIR    @RR{PASSWD}
mmux_libc_pw_shell  PW_SHELL  @RR{PASSWD}
@end example
@end deffn


@deffn Builtin mmux_libc_getpwnam @var{PASSWD_POINTER_VAR} @var{USERNAME}
Interface to the standard C language function @cfunc{getpwnam}, @glibcref{Lookup User, getpwnam}.

Bind the shell variable whose name is @var{PASSWD_POINTER_VAR} to a string representation of a
pointer to the @code{struct passwd} returned by the internal call to @cfunc{getpwnam}.  This value
can be @cnull{} if there is no database entry associated to @var{USERNAME}.
@end deffn


@deffn Builtin mmux_libc_setpwent
Interface to the standard C language function @cfunc{setpwent}, @glibcref{Scanning All Users, setpwent}.
@end deffn


@deffn Builtin mmux_libc_getpwent @var{PASSWD_POINTER_VAR}
Interface to the standard C language function @cfunc{setpwent}, @glibcref{Scanning All Users,
setpwent}.

Bind the shell variable whose name is @var{PASSWD_POINTER_VAR} to a string representation of a
pointer to the @code{struct passwd} returned by the internal call to @cfunc{getpwent}.  This value
is @cnull{} if there are no more entries in this iteration of the database.

@example
declare PASSWD PW_NAME

mmux_libc_setpwent
mmux_libc_getpwent PASSWD
until mmux_pointer_is_zero @RR{PASSWD}
do
    mmux_libc_pw_name PW_NAME @RR{PASSWD}
    echo @WW{PW_NAME}
    mmux_libc_getpwent PASSWD
done
mmux_libc_endpwent
@end example
@end deffn


@deffn Builtin mmux_libc_endpwent
Interface to the standard C language function @cfunc{endpwent}, @glibcref{Scanning All Users, endpwent}.
@end deffn


@deffn Builtin mmux_libc_pw_name @var{PW_NAME_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_NAME_VAR} a string representation of the field
@code{pw_name} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn


@deffn Builtin mmux_libc_pw_passwd @var{PW_PASSWD_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_PASSWD_VAR} a string representation of the field
@code{pw_passwd} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn


@deffn Builtin mmux_libc_pw_uid @var{PW_UID_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_UID_VAR} a string representation of the field
@code{pw_uid} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn


@deffn Builtin mmux_libc_pw_gid @var{PW_GID_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_GID_VAR} a string representation of the field
@code{pw_gid} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn


@deffn Builtin mmux_libc_pw_gecos @var{PW_GECOS_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_GECOS_VAR} a string representation of the field
@code{pw_gecos} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn


@deffn Builtin mmux_libc_pw_dir @var{PW_DIR_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_DIR_VAR} a string representation of the field
@code{pw_dir} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn


@deffn Builtin mmux_libc_pw_shell @var{PW_SHELL_VAR} @var{PASSWD_POINTER}
Bind to the shell variable whose name is @var{PW_SHELL_VAR} a string representation of the field
@code{pw_shell} in the @code{struct passwd} referenced by the pointer @var{PASSWD_POINTER}.
@end deffn

@c page
@node persona database group
@section Group database


@ref{overview conventions, Conventions in coding and documentation}.


@deffn Builtin mmux_libc_getgrgid @var{GROUP_POINTER_VAR} @var{GID}
Interface to the standard C language function @cfunc{getgrgid}, @glibcref{Lookup Group, getgrgid}.

Bind the shell variable whose name is @var{GROUP_POINTER_VAR} to a string representation of a
pointer to the @code{struct group} returned by the internal call to @cfunc{getgrgid}.  This value
can be @cnull{} if there is no database entry associated to @var{GID}.

@example
declare GROUP
declare GR_NAME GR_GID
declare -a GR_MEM

mmux_libc_getgrgid GROUP @RR{SOME_GID}
mmux_libc_gr_name GR_NAME   @RR{GROUP}
mmux_libc_gr_gid  GR_GID    @RR{GROUP}
mmux_libc_gr_mem  GR_MEM    @RR{GROUP}
@end example
@end deffn


@deffn Builtin mmux_libc_getgrnam @var{GROUP_POINTER_VAR} @var{GROUPNAME}
Interface to the standard C language function @cfunc{getgrnam}, @glibcref{Lookup Group, getgrnam}.

Bind the shell variable whose name is @var{GROUP_POINTER_VAR} to a string representation of a
pointer to the @code{struct group} returned by the internal call to @cfunc{getgrnam}.  This value
can be @cnull{} if there is no database entry associated to @var{GROUPNAME}.
@end deffn


@deffn Builtin mmux_libc_setgrent
Interface to the standard C language function @cfunc{setgrent}, @glibcref{Scanning All Groups, setgrent}.
@end deffn


@deffn Builtin mmux_libc_getgrent @var{GROUP_POINTER_VAR}
Interface to the standard C language function @cfunc{setgrent}, @glibcref{Scanning All Groups,
setgrent}.

Bind the shell variable whose name is @var{GROUP_POINTER_VAR} to a string representation of a
pointer to the @code{struct group} returned by the internal call to @cfunc{getgrent}.  This value is
@cnull{} if there are no more entries in this iteration of the database.

@example
declare GROUP GR_NAME

mmux_libc_setgrent
mmux_libc_getgrent GROUP
until mmux_pointer_is_zero @RR{GROUP}
do
    mmux_libc_gr_name GR_NAME @RR{GROUP}
    echo @WW{GR_NAME}
    mmux_libc_getgrent GROUP
done
mmux_libc_endgrent
@end example
@end deffn


@deffn Builtin mmux_libc_endgrent
Interface to the standard C language function @cfunc{endgrent}, @glibcref{Scanning All Groups, endgrent}.
@end deffn


@deffn Builtin mmux_libc_gr_name @var{GR_NAME_VAR} @var{GROUP_POINTER}
Bind to the shell variable whose name is @var{GR_NAME_VAR} a string representation of the field
@code{gr_name} in the @code{struct group} referenced by the pointer @var{GROUP_POINTER}.
@end deffn


@deffn Builtin mmux_libc_gr_gid @var{GR_GID_VAR} @var{GROUP_POINTER}
Bind to the shell variable whose name is @var{GR_GID_VAR} a string representation of the field
@code{gr_gid} in the @code{struct group} referenced by the pointer @var{GROUP_POINTER}.
@end deffn


@deffn Builtin mmux_libc_gr_mem @var{GR_MEM_INDEX_ARRAY_VAR} @var{GROUP_POINTER}
Bind to the elements of the shell index array variable whose name is @var{GR_MEM_INDEX_ARRAY_VAR}
the string representations of the elements in the vector field @code{gr_mem} in the @code{struct
group} referenced by the pointer @var{GROUP_POINTER}.
@end deffn

@c page
@node errors
@chapter Handling errors


@menu
* errors builtins::             Builtin handling errors.
* errors errno::                Values of @code{errno}.
@end menu

@c page
@node errors builtins
@section Builtin handling errors


@defvr {Shell Variable} ERRNO
If an error occurs in the call to a builtin that interfaces a Standard C Library function: the
builtin will set the shell variable @env{ERRNO} to the string representation of an exact integer,
itself representing a standard @code{errno} code.

@example
declare PTR ERRNO=0 SYM

mmux_libc_malloc PTR 'ciao'
mmux-bash-pointers-errno-to-string SYM $ERRNO
$SYM    @result{} EINVAL
@end example
@end defvr


@deffn Builtin mmux_libc_strerror @var{MSGVAR} @var{ERRNUM}
Store in @var{MSGVAR} the error message corresponding to @var{ERRNUM}, which must be the string
representation of an exact integer, itself representing a valid value for @code{errno}; @var{ERRNUM}
must fit the C language type @code{int}.

@example
declare MSG

if test -v mmux_libc_EINVAL
then mmux_libc_strerror MSG $mmux_libc_EINVAL
else MSG='EINVAL undefined'
fi

"$MSG"  @result{} Invalid argument
@end example
@end deffn


@defun mmux-bash-pointers-errno-to-string @var{SYMVAR} @var{ERRNUM}
Store in @var{SYMVAR} a string representation of the @code{errno} code @var{ERRNUM}.  When
successful return true, otherwise return false.

@example
declare SYM

mmux-bash-pointers-errno-to-string SYM $mmux_libc_ENOMEM
"$SYM"  @result{} ENOMEM
@end example
@end defun

@c page
@node errors errno
@section Values of @code{errno}


If a C language constant referenced by one of the following variables is undefined: the
corresponding Bash variable is undefined; we can test this condition with @code{test -v}; to test if
the underlying platform implements the constant @code{ENOMEM}, we can do:

@example
if test -v mmux_libc_ENOMEM
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarErrno{NAME}
@defvar mmux_libc_\NAME\
Global variable holding the value of the C language constant @code{\NAME\}.
@end defvar

@end macro

@MmuxDefineGlobalVarErrno{EPERM}
@MmuxDefineGlobalVarErrno{ENOENT}
@MmuxDefineGlobalVarErrno{ESRCH}
@MmuxDefineGlobalVarErrno{EINTR}
@MmuxDefineGlobalVarErrno{EIO}
@MmuxDefineGlobalVarErrno{ENXIO}
@MmuxDefineGlobalVarErrno{E2BIG}
@MmuxDefineGlobalVarErrno{ENOEXEC}
@MmuxDefineGlobalVarErrno{EBADF}
@MmuxDefineGlobalVarErrno{ECHILD}
@MmuxDefineGlobalVarErrno{EAGAIN}
@MmuxDefineGlobalVarErrno{ENOMEM}
@MmuxDefineGlobalVarErrno{EACCES}
@MmuxDefineGlobalVarErrno{EFAULT}
@MmuxDefineGlobalVarErrno{ENOTBLK}
@MmuxDefineGlobalVarErrno{EBUSY}
@MmuxDefineGlobalVarErrno{EEXIST}
@MmuxDefineGlobalVarErrno{EXDEV}
@MmuxDefineGlobalVarErrno{ENODEV}
@MmuxDefineGlobalVarErrno{ENOTDIR}
@MmuxDefineGlobalVarErrno{EISDIR}
@MmuxDefineGlobalVarErrno{EINVAL}
@MmuxDefineGlobalVarErrno{ENFILE}
@MmuxDefineGlobalVarErrno{EMFILE}
@MmuxDefineGlobalVarErrno{ENOTTY}
@MmuxDefineGlobalVarErrno{ETXTBSY}
@MmuxDefineGlobalVarErrno{EFBIG}
@MmuxDefineGlobalVarErrno{ENOSPC}
@MmuxDefineGlobalVarErrno{ESPIPE}
@MmuxDefineGlobalVarErrno{EROFS}
@MmuxDefineGlobalVarErrno{EMLINK}
@MmuxDefineGlobalVarErrno{EPIPE}
@MmuxDefineGlobalVarErrno{EDOM}
@MmuxDefineGlobalVarErrno{ERANGE}
@MmuxDefineGlobalVarErrno{EDEADLK}
@MmuxDefineGlobalVarErrno{ENAMETOOLONG}
@MmuxDefineGlobalVarErrno{ENOLCK}
@MmuxDefineGlobalVarErrno{ENOSYS}
@MmuxDefineGlobalVarErrno{ENOTEMPTY}
@MmuxDefineGlobalVarErrno{ELOOP}
@MmuxDefineGlobalVarErrno{EWOULDBLOCK}
@MmuxDefineGlobalVarErrno{ENOMSG}
@MmuxDefineGlobalVarErrno{EIDRM}
@MmuxDefineGlobalVarErrno{ECHRNG}
@MmuxDefineGlobalVarErrno{EL2NSYNC}
@MmuxDefineGlobalVarErrno{EL3HLT}
@MmuxDefineGlobalVarErrno{EL3RST}
@MmuxDefineGlobalVarErrno{ELNRNG}
@MmuxDefineGlobalVarErrno{EUNATCH}
@MmuxDefineGlobalVarErrno{ENOCSI}
@MmuxDefineGlobalVarErrno{EL2HLT}
@MmuxDefineGlobalVarErrno{EBADE}
@MmuxDefineGlobalVarErrno{EBADR}
@MmuxDefineGlobalVarErrno{EXFULL}
@MmuxDefineGlobalVarErrno{ENOANO}
@MmuxDefineGlobalVarErrno{EBADRQC}
@MmuxDefineGlobalVarErrno{EBADSLT}
@MmuxDefineGlobalVarErrno{EDEADLOCK}
@MmuxDefineGlobalVarErrno{EBFONT}
@MmuxDefineGlobalVarErrno{ENOSTR}
@MmuxDefineGlobalVarErrno{ENODATA}
@MmuxDefineGlobalVarErrno{ETIME}
@MmuxDefineGlobalVarErrno{ENOSR}
@MmuxDefineGlobalVarErrno{ENONET}
@MmuxDefineGlobalVarErrno{ENOPKG}
@MmuxDefineGlobalVarErrno{EREMOTE}
@MmuxDefineGlobalVarErrno{ENOLINK}
@MmuxDefineGlobalVarErrno{EADV}
@MmuxDefineGlobalVarErrno{ESRMNT}
@MmuxDefineGlobalVarErrno{ECOMM}
@MmuxDefineGlobalVarErrno{EPROTO}
@MmuxDefineGlobalVarErrno{EMULTIHOP}
@MmuxDefineGlobalVarErrno{EDOTDOT}
@MmuxDefineGlobalVarErrno{EBADMSG}
@MmuxDefineGlobalVarErrno{EOVERFLOW}
@MmuxDefineGlobalVarErrno{ENOTUNIQ}
@MmuxDefineGlobalVarErrno{EBADFD}
@MmuxDefineGlobalVarErrno{EREMCHG}
@MmuxDefineGlobalVarErrno{ELIBACC}
@MmuxDefineGlobalVarErrno{ELIBBAD}
@MmuxDefineGlobalVarErrno{ELIBSCN}
@MmuxDefineGlobalVarErrno{ELIBMAX}
@MmuxDefineGlobalVarErrno{ELIBEXEC}
@MmuxDefineGlobalVarErrno{EILSEQ}
@MmuxDefineGlobalVarErrno{ERESTART}
@MmuxDefineGlobalVarErrno{ESTRPIPE}
@MmuxDefineGlobalVarErrno{EUSERS}
@MmuxDefineGlobalVarErrno{ENOTSOCK}
@MmuxDefineGlobalVarErrno{EDESTADDRREQ}
@MmuxDefineGlobalVarErrno{EMSGSIZE}
@MmuxDefineGlobalVarErrno{EPROTOTYPE}
@MmuxDefineGlobalVarErrno{ENOPROTOOPT}
@MmuxDefineGlobalVarErrno{EPROTONOSUPPORT}
@MmuxDefineGlobalVarErrno{ESOCKTNOSUPPORT}
@MmuxDefineGlobalVarErrno{EOPNOTSUPP}
@MmuxDefineGlobalVarErrno{EPFNOSUPPORT}
@MmuxDefineGlobalVarErrno{EAFNOSUPPORT}
@MmuxDefineGlobalVarErrno{EADDRINUSE}
@MmuxDefineGlobalVarErrno{EADDRNOTAVAIL}
@MmuxDefineGlobalVarErrno{ENETDOWN}
@MmuxDefineGlobalVarErrno{ENETUNREACH}
@MmuxDefineGlobalVarErrno{ENETRESET}
@MmuxDefineGlobalVarErrno{ECONNABORTED}
@MmuxDefineGlobalVarErrno{ECONNRESET}
@MmuxDefineGlobalVarErrno{ENOBUFS}
@MmuxDefineGlobalVarErrno{EISCONN}
@MmuxDefineGlobalVarErrno{ENOTCONN}
@MmuxDefineGlobalVarErrno{ESHUTDOWN}
@MmuxDefineGlobalVarErrno{ETOOMANYREFS}
@MmuxDefineGlobalVarErrno{ETIMEDOUT}
@MmuxDefineGlobalVarErrno{ECONNREFUSED}
@MmuxDefineGlobalVarErrno{EHOSTDOWN}
@MmuxDefineGlobalVarErrno{EHOSTUNREACH}
@MmuxDefineGlobalVarErrno{EALREADY}
@MmuxDefineGlobalVarErrno{EINPROGRESS}
@MmuxDefineGlobalVarErrno{ESTALE}
@MmuxDefineGlobalVarErrno{EUCLEAN}
@MmuxDefineGlobalVarErrno{ENOTNAM}
@MmuxDefineGlobalVarErrno{ENAVAIL}
@MmuxDefineGlobalVarErrno{EISNAM}
@MmuxDefineGlobalVarErrno{EREMOTEIO}
@MmuxDefineGlobalVarErrno{EDQUOT}
@MmuxDefineGlobalVarErrno{ENOMEDIUM}
@MmuxDefineGlobalVarErrno{EMEDIUMTYPE}
@MmuxDefineGlobalVarErrno{ECANCELED}
@MmuxDefineGlobalVarErrno{ENOKEY}
@MmuxDefineGlobalVarErrno{EKEYEXPIRED}
@MmuxDefineGlobalVarErrno{EKEYREVOKED}
@MmuxDefineGlobalVarErrno{EKEYREJECTED}
@MmuxDefineGlobalVarErrno{EOWNERDEAD}
@MmuxDefineGlobalVarErrno{ENOTRECOVERABLE}

@c page
@node misc
@chapter Miscellaneous features


@defun mmux_bash_pointers_builtin_p @var{NAME}
Return true if @var{NAME} is the identifier of an existing builtin; otherwise return false.  We can
use this function to test if a shell library implements a builtin whose availability depends on the
underlying platform.

For example, the package @mmux{} Bash @acronym{MPFR} implements the builtin
@code{mpfr_set_decimal128} only if the underlying platform implements the C language type
@objtype{_Decimal128} and all the involved libraries were compiled with support for such type.  So
we can do:

@example
if mmux_bash_pointers_builtin_p mpfr_set_decimal128
then # builtin implemented
else # builtin not implemented
fi
@end example
@end defun


@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node shared library
@appendix Using the shared library


@value{PACKAGE} installs a shared library:

@example
libmmux-bash-pointers.so
@end example

@noindent
and C language headers:

@example
libmmux-bash-pointers.h
libmmux-bash-pointers-config.h
@end example

@noindent
we can write code that links to the shared library to reuse some of its facilities.  @ref{overview
linking} for details.

The bulk of the C language types @api{} is implemented by the library @mmux{} CC Types, which is
installed along with this package.  Refer to its documentation for details.

@menu
* shared library config::       How to configure a package to link the shared library.
* shared library version::      Version functions.
* shared library retvals::      Return values of C language functions.
* shared library bindings::     Binding values to variables.
* shared library arrays::       Handling array variables.
* shared library errors::       Handling errors.
@end menu

@c page
@node shared library config
@appendixsec How to configure a package to link the shared library


It happens that some rare platform may not implement the C language types @objtype{signed long long
int}, @objtype{unsigned long long int} and @objtype{long double}; more platforms may not implement
the extension types @objtype{_FloatN} and @objtype{_FloatNx}, which usually are:

@example
_Float32
_Float64
_Float128
_Float32x
_Float64x
_Float128x
@end example

@noindent
even more platforms may not implement the extension types @objtype{_DecimalN}, which usually are:

@example
_Decimal32
_Decimal64
_Decimal128
@end example

@noindent
these types are supported by @value{PACKAGE}.

This package assumes that: if the real floating--point types are supported, the corresponding
complex floating--point types are also supported; so the following types are supported:

@example
_Float32 complex
_Float64 complex
_Float128 complex
_Float32x complex
_Float64x complex
_Float128x complex
@end example

This package implements complex floating--point numbers whose real and imaginary parts are
@objtype{_DecimalN} numbers through a custom data structure.

At package--configuration time: @value{PACKAGE} tries to determine if these types are supported and
it defines the following symbols in its header files.

@c ------------------------------------------------------------------------

We can use the following C preprocesso symbols with code like:

@example
#if ((defined MMUX_HAVE_CC_TYPE_LDOUBLE) && (1 == MMUX_HAVE_CC_TYPE_LDOUBLE))
...
#endif
@end example

@macro MmuxDefineCppSymbolHaveType{CPPSTEM}
@defvr {C Preprocessor Symbol} MMUX_HAVE_CC_TYPE_\CPPSTEM\
If this preprocessor symbol is defined and its use expands to @samp{1}: the corresponding C language
type is supported.
@end defvr

@end macro

@MmuxDefineCppSymbolHaveType{SLLONG}
@MmuxDefineCppSymbolHaveType{ULLONG}
@MmuxDefineCppSymbolHaveType{LDOUBLE}
@MmuxDefineCppSymbolHaveType{FLOAT32}
@MmuxDefineCppSymbolHaveType{FLOAT64}
@MmuxDefineCppSymbolHaveType{FLOAT128}
@MmuxDefineCppSymbolHaveType{FLOAT32X}
@MmuxDefineCppSymbolHaveType{FLOAT64X}
@MmuxDefineCppSymbolHaveType{FLOAT128X}
@MmuxDefineCppSymbolHaveType{DECIMAL32}
@MmuxDefineCppSymbolHaveType{DECIMAL64}
@MmuxDefineCppSymbolHaveType{DECIMAL128}
@MmuxDefineCppSymbolHaveType{COMPLEXF32}
@MmuxDefineCppSymbolHaveType{COMPLEXF64}
@MmuxDefineCppSymbolHaveType{COMPLEXF128}
@MmuxDefineCppSymbolHaveType{COMPLEXF32X}
@MmuxDefineCppSymbolHaveType{COMPLEXF64X}
@MmuxDefineCppSymbolHaveType{COMPLEXF128X}
@MmuxDefineCppSymbolHaveType{COMPLEXD32}
@MmuxDefineCppSymbolHaveType{COMPLEXD64}
@MmuxDefineCppSymbolHaveType{COMPLEXD128}

@c page
@node shared library version
@appendixsec Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmux_bash_pointers_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node shared library retvals
@appendixsec Return values of C language functions


@deftp {Typedef} mmux_bash_rv_t
Type of constant values used as return value by C language functions.
@end deftp


@deftypevr {Constant} mmux_bash_rv_t MMUX_SUCCESS
Return value used to signal a successful function call.
@end deftypevr


@deftypevr {Constant} mmux_bash_rv_t MMUX_FAILURE
Return value used to signal a failed function call.
@end deftypevr

@c page
@node shared library bindings
@appendixsec Binding values to variables


@cindex Binding strings to shell variables
@cindex Binding values to shell variables
@cindex Assigning strings to shell variables
@cindex Assigning values to shell variables
@cindex Shell variables, binding values with C functions
@cindex Shell variables, assigning values with C functions
@cindex Creating a global shell variable with C functions
@cindex Declaring a global shell variable with C functions
@cindex Assigning a global shell variable with C functions


@deftypefun mmux_bash_rv_t mmux_string_bind_to_bash_variable (char const * @var{variable_name}, char const * @var{s_value}, char const * @var{who})
Assign @var{s_value} to the shell @var{variable_name}; the @asciiz{} string referenced by
@var{s_value} is duplicated internally by Bash, so Bash does @strong{not} own the memory referenced
by @var{s_value}.  When successful return @code{MMUX_SUCCESS}; otherwise return @code{MMUX_FAILURE}.

When @var{who} is not @cnull{} and an error occurs: an error message is printed on @stderr{}, and
@var{who} is used as ``subject'' that signalled the error.  @var{who} is usually the name of a
builtin.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_string_bind_to_bash_global_variable (char const * @var{variable_name}, char const * @var{s_value}, char const * @var{who})
Like @cfunc{mmux_string_bind_to_bash_variable} but bind the value to a global shell variable.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_bash_create_global_string_variable (char const * @var{variable_name}, char const * @var{s_value}, char const * @var{who})
Like @cfunc{mmux_string_bind_to_bash_global_variable} but  return @code{MMUX_FAILURE} if the shell
variable already exists.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_bash_create_global_sint_variable (char const * @var{variable_name}, int @var{value}, char const * @var{who})
Like @cfunc{mmux_bash_create_global_string_variable} but convert @var{value} to its string
representation and bind that string to the shell variable.
@end deftypefun

@c ------------------------------------------------------------------------

@macro MmuxDefineCFunctionBindToVariable{STEM}
@deftypefun mmux_bash_rv_t mmux_\STEM\_bind_to_bash_variable (char const * @var{variable_name}, mmux_\STEM\_t @var{value}, char const * @var{who})
Assign @var{value} to the shell @var{variable_name}.  When successful return @code{MMUX_SUCCESS};
otherwise return @code{MMUX_FAILURE}.

When @var{who} is not @cnull{} and an error occurs: an error message is printed on @stderr{}, and
@var{who} is used as ``subject'' that signalled the error.  @var{who} is usually the name of a
builtin.
@end deftypefun

@end macro


@MmuxDefineCFunctionBindToVariable{pointer}

@MmuxDefineCFunctionBindToVariable{schar}
@MmuxDefineCFunctionBindToVariable{uchar}
@MmuxDefineCFunctionBindToVariable{sshort}
@MmuxDefineCFunctionBindToVariable{ushort}
@MmuxDefineCFunctionBindToVariable{sint}
@MmuxDefineCFunctionBindToVariable{uint}
@MmuxDefineCFunctionBindToVariable{slong}
@MmuxDefineCFunctionBindToVariable{ulong}
@MmuxDefineCFunctionBindToVariable{sllong}
@MmuxDefineCFunctionBindToVariable{ullong}
@MmuxDefineCFunctionBindToVariable{float}
@MmuxDefineCFunctionBindToVariable{double}
@MmuxDefineCFunctionBindToVariable{ldouble}

@MmuxDefineCFunctionBindToVariable{float32}
@MmuxDefineCFunctionBindToVariable{float64}
@MmuxDefineCFunctionBindToVariable{float128}

@MmuxDefineCFunctionBindToVariable{float32x}
@MmuxDefineCFunctionBindToVariable{float64x}
@MmuxDefineCFunctionBindToVariable{float128x}

@MmuxDefineCFunctionBindToVariable{decimal32}
@MmuxDefineCFunctionBindToVariable{decimal64}
@MmuxDefineCFunctionBindToVariable{decimal128}

@MmuxDefineCFunctionBindToVariable{complexf}
@MmuxDefineCFunctionBindToVariable{complexd}
@MmuxDefineCFunctionBindToVariable{complexld}

@MmuxDefineCFunctionBindToVariable{complexf32}
@MmuxDefineCFunctionBindToVariable{complexf64}
@MmuxDefineCFunctionBindToVariable{complexf128}

@MmuxDefineCFunctionBindToVariable{complexf32x}
@MmuxDefineCFunctionBindToVariable{complexf64x}
@MmuxDefineCFunctionBindToVariable{complexf128x}

@MmuxDefineCFunctionBindToVariable{complexd32}
@MmuxDefineCFunctionBindToVariable{complexd64}
@MmuxDefineCFunctionBindToVariable{complexd128}

@MmuxDefineCFunctionBindToVariable{sint8}
@MmuxDefineCFunctionBindToVariable{uint8}
@MmuxDefineCFunctionBindToVariable{sint16}
@MmuxDefineCFunctionBindToVariable{uint16}
@MmuxDefineCFunctionBindToVariable{sint32}
@MmuxDefineCFunctionBindToVariable{uint32}
@MmuxDefineCFunctionBindToVariable{sint64}
@MmuxDefineCFunctionBindToVariable{uint64}

@MmuxDefineCFunctionBindToVariable{ssize}
@MmuxDefineCFunctionBindToVariable{usize}
@MmuxDefineCFunctionBindToVariable{sintmax}
@MmuxDefineCFunctionBindToVariable{uintmax}
@MmuxDefineCFunctionBindToVariable{sintptr}
@MmuxDefineCFunctionBindToVariable{uintptr}
@MmuxDefineCFunctionBindToVariable{mode}
@MmuxDefineCFunctionBindToVariable{off}
@MmuxDefineCFunctionBindToVariable{pid}
@MmuxDefineCFunctionBindToVariable{uid}
@MmuxDefineCFunctionBindToVariable{gid}
@MmuxDefineCFunctionBindToVariable{wchar}
@MmuxDefineCFunctionBindToVariable{wint}

@c page
@node shared library arrays
@appendixsec Handling array variables


@menu
* shared library arrays index:: Handling index array variables.
@end menu

@c page
@node shared library arrays index
@appendixsubsec Handling index array variables


To bind a value to a shell index array variable we can do:

@example
mmux_bash_index_array_variable_t        index_array_variable;
mmux_bash_index_array_index_t           index_array_key   = 1;
char const *                            index_array_value = "ciao";
mmux_bash_rv_t                          rv;

rv = mmux_bash_index_array_find_or_make_mutable(&index_array_variable, index_array_name, "mybuiltin");
if (MMUX_SUCCESS != rv) @{ /* handle the error */ @}

rv = mmux_bash_index_array_bind(index_array_variable, index_array_key, index_array_value, "mybuiltin");
if (MMUX_SUCCESS != rv) @{ /* handle the error */ @}
@end example


@deftp {Opaque Pointer Typedef} mmux_bash_index_array_variable_t
Pointer to a data structure representing an shell index array variable.
@end deftp


@deftp {Exact Integer Typedef} mmux_bash_index_array_index_t
Type of exact integers representing indexes in a shell index array variable.
@end deftp


@deftypefun bool mmux_bash_index_array_mutable_p (mmux_bash_index_array_variable_t @var{INDEX_ARRAY_VARIABLE})
Return @ctrue{} if the index array variable referenced by @var{INDEX_ARRAY_VARIABLE} is mutable: not
read--only, not no--assign; otherwise return @cfalse{}.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_bash_index_array_find_or_make_mutable (mmux_bash_index_array_variable_t * @var{INDEX_ARRAY_VARIABLE_P}, char const * @var{INDEX_ARRAY_NAME}, char const * @var{WHO})
Search the shell context for a shell index array variable with name equal to the @asciiz{} string
referenced by @var{INDEX_ARRAY_NAME}, and whose attributes make it mutable:

@itemize
@item
If a shell variable already exists: store a pointer to its data structure in the location referenced
by @var{INDEX_ARRAY_VARIABLE_P}; then return @code{MMUX_SUCCESS}.

@item
If a shell variable does not already exists: create a new one and store a pointer to its data
structure in the location referenced by @var{INDEX_ARRAY_VARIABLE_P}; then return
@code{MMUX_SUCCESS}.

@item
If no suitable shell variable is found or can be created: return @code{MMUX_FAILURE}.
@end itemize

In case of failure and if @var{WHO} is not @cnull{}: print an error message to @stderr{} describing
the error; use the @asciiz{} string referenced by @var{WHO} as name of the entity that signals the
error; usually @var{WHO} references the name of a builtin.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_bash_index_array_bind (mmux_bash_index_array_variable_t @var{INDEX_ARRAY_VARIABLE}, mmux_bash_index_array_index_t @var{iNDEX_ARRAY_KEY}, char const * @var{INDEX_ARRAY_VALUE}, char const * @var{WHO})
Bind a value in a shell index array variable.  When successful return @code{MMUX_SUCCESS}; otherwise
return @code{MMUX_FAILURE}.

The variable referenced by @var{INDEX_ARRAY_VARIABLE} must be mutable.

The index key is represented by @var{iNDEX_ARRAY_KEY}.

The value to bind is the @asciiz{} string referenced by @var{INDEX_ARRAY_VALUE}.

In case of failure and if @var{WHO} is not @cnull{}: print an error message to @stderr{} describing
the error; use the @asciiz{} string referenced by @var{WHO} as name of the entity that signals the
error; usually @var{WHO} references the name of a builtin.
@end deftypefun

@c page
@node shared library errors
@appendixsec Handling errors


@deftypefun mmux_bash_rv_t mmux_bash_pointers_set_ERRNO (int @var{errnum}, char const * @var{who})
Set the shell variable @env{ERRNO} to a string representation of @var{errnum}.  When successful
return @samp{MMUX_SUCCESS}, otherwise return @samp{MMUX_FAILURE}.

If an error occurs and @var{who} is not @cnull{}: print an error message to @stderr{}.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_bash_pointers_consume_errno (char const * @var{who})
Call @cfunc{mmux_bash_pointers_set_ERRNO} to deal with the current value of the standard
@code{errno}; then set @code{errno} itself to zero.  When successful return @samp{MMUX_SUCCESS},
otherwise return @samp{MMUX_FAILURE}.

If an error occurs and @var{who} is not @cnull{}: print an error message to @stderr{}.
@end deftypefun

@c page
@node packages
@appendix @mmux{} Bash Packages Infrastructure


@cindex @mmux{} Bash Packages Infrastructure


@value{PACKAGE} installs a shell library to handle @gnu{} Bash packages; choices were made to define
what it means that a package uses the @mmux{} Bash Packaging Infrastructure; it is sort of primitive
in its version @samp{0}.  The shell library is:

@center @file{libmmux-bash-packages.bash}

@noindent
and it is installed under @code{$datadir/bash}.  This library must be sourced before sourcing other
libraries that use it.

Use of this package management library is mandatory to load @file{libmmux-bash-pointers.bash}, but
not really required by other shell libraries, including those depending on
@file{libmmux-bash-pointers.bash} itself, unless otherwise documented.

@menu
* packages overview::           Overview of the library.
* packages conventions::        Conventions used in this documentation.
* packages descriptor::         Package descriptor.
* packages registry::           Registry of descriptors.
* packages requiring::          Requiring a package.
* packages providing::          Providing a package.
* packages loading::            Loading a package.
* packages unloading::          Unloading a package.
* packages printing::           Printing messages.
* packages exiting::            Exiting the script.
@end menu

@c page
@node packages overview
@appendixsec Overview of the library


The @mmux{} Bash Packaging Infrastructure defines the following concepts:

@table @dfn
@item shared library
It is a C11 language library compiled into binary code and installed as a shared object; it is meant
to implement loadable @gnu{} Bash builtins.

@item shell package
It is a set of features collected into an Application Programming Interface; the package and the
@api{} are given a version specification.

@item shell library
It is a file containing @gnu{} Bash source code; a shell library might implement zero, one or more
shell packages; a shell library might require a shared library from which to load builtins.
@end table

In general, to load a shell library we could just source its file, using the @code{source} builtin;
the library code itself can perform initialisation operations like defining global variables,
functions and enabling loadable builtins.  There are situations in which it is convenient to
systematise part of of this work.

@mmux{} Bash Packaging Infrastructure version @samp{0} provides, through the shell library
@file{libmmux-bash-packages.bash}, a way to organise and manage:

@itemize
@item
Installed packages version specification.

@item
Installed packages' @api{} version specification.

@item
Loading of builtins from a shared library.
@end itemize

@noindent
the infrastructure does @strong{not} provide:

@itemize
@item
Searching a file system for the location of installed libraries or packages to load at run--time.

@item
Package dependency management.
@end itemize

To use @file{libmmux-bash-packages.bash} we have to source it @strong{before} other shell libraries
that use it:

@example
#!/bin/bash

source libmmux-bash-packages.bash
source libmmux-bash-pointers.bash

...
### end of file
@end example

@noindent
before loading other libraries we might want to configure the behaviour of the package manager:

@example
#!/bin/bash

source libmmux-bash-packages.bash

mmux_package_enable_debug_mode
source libmmux-bash-pointers.bash
mmux_package_disable_debug_mode

source libmmux-bash-spiffy-stuff.bash
...
### end of file
@end example

To comply with the @mmux{} Bash Packaging Infrastructure a shell library defines:

@table @asis
@item package descriptor
Mandatory.  An associative shell array holding informations about a package, @ref{packages
descriptor, Package descriptor}.

@item after--loading hook
Optional.  An evaluatable identifier (alias, function, builtin) that is evaluated after a package
has been loaded.

@item before--unloading hook
Optional.  An evaluatable identifier (alias, function, builtin) that is evaluated before a package
is unloaded.
@end table

@c page
@node packages conventions
@appendixsec Conventions used in this documentation


The following naming conventions for builtin and function parameters are used in this documentation:

@table @var
@item DESCRIPTOR_ARRAYNAME
It is the name of the associative array representing a package descriptor.  For the library
@file{libmmux-bash-pointers.bash} it is @env{MMUX_BASH_POINTERS_PACKAGE}.
@end table

@c page
@node packages descriptor
@appendixsec Package descriptor


Packages adopting the @mmux{} Bash infrastructure are described by a shell global associative array;
for example @value{PACKAGE} defines an array @env{MMUX_BASH_POINTERS_PACKAGE} in its shell library
@file{libmmux-bash-pointers.bash}.

Packages adopting the @mmux{} Bash infrastructure are meant to follow interface version numbering as
established by the @gnu{} Autotools.  For an explanation of interface numbers as managed by @gnu{}
Libtool @xref{Libtool versioning, interface, Libtool's versioning system, libtool, Shared library
support for @gnu{}}.

The following are the expected array keys.

@table @samp
@item PACKAGING_VERSION
Mandatory.  Specifies the version of the packaging system, the one implemented by the library
@file{libmmux-bash-packages.bash} itself.  At present only version @samp{0} is defined.

@item PACKAGE_NAME
Mandatory.  A free format string representing the name of the package; for example
``@value{PACKAGE}''.

@item SEMANTIC_VERSION
Mandatory.  The semantic version specification for the package; this can be the version
specification of the distribution of shell libraries that define the package.

For example, the distribution package @value{PACKAGE} installs the shell library
@file{libmmux-bash-pointers.bash} which defines the shell package @env{MMUX_BASH_POINTERS_PACKAGE};
the distribution package @value{PACKAGE} has version @value{MmuxPkgSemanticVersion}.

@item INTERFACE_VERSION_CURRENT
Mandatory.  A string representing a non--negative exact integer specifying the current @api{}
version number implemented by the package.

@item INTERFACE_VERSION_REVISION
Mandatory.  A string representing a non--negative exact integer specifying the revision of the
@api{} version number implemented by the package; it means the package implements revision
@samp{REVISION} of the interface @samp{CURRENT}.

@item INTERFACE_VERSION_AGE
Mandatory.  A string representing a non--negative exact integer specifying the age of the @api{}
version number implemented by the package; it means the package implements all the @api{} versions
from version @samp{(CURRENT - AGE)} included to version @samp{CURRENT} included.

@item SHARED_LIBRARY
Optional, but see @samp{BUILTIN_0}.  A string representing the filename of a shared library
installed on the system; a library that implements loadable builtins; for example
@file{libmmux-bash-pointers.so}.  A package can implement loadable builtins, but it is not
mandatory.

@item SHELL_LIBRARY
Optional.  A string representing the filename of the shell library installed on the system; the one
that implements the loading and unloading of the package; the one that defines the package
descriptor itself.  For example @file{libmmux-bash-pointers.bash}.

@item PACKAGE_AFTER_LOADING_HOOK
Optional.  An evaluatable identifier (function, alias, builtin); it is evaluated, without arguments,
after the package has been loaded.

@item PACKAGE_BEFORE_UNLOADING_HOOK
Optional.  An evaluatable identifier; it is evaluated, without arguments, before the package is
unloaded.

@item BUILTIN_0
@itemx BUILTIN_1
@itemx @dots{}
@itemx BUILTIN_N
Loadable builtin identifiers; if @samp{BUILTIN_0} exists: at least one bulitin must be loaded and
enabled from the shared library selected by the key @samp{SHARED_LIBRARY}, whose presence becomes
mandatory.

When a package is loaded through this descriptor: the builtins are loaded and enabled from the
shared library starting from @samp{BUILTIN_0}.

@item ENABLED_BUILTIN_0
@itemx ENABLED_BUILTIN_1
@itemx @dots{}
@itemx ENABLED_BUILTIN_N
Undefinable.  A package loader should add these elements to list the builtins that are enabled; so
that, later, these elements might be used to disable them.  A package unloader should disable these
builtins starting from @samp{ENABLED_BUILTIN_0}, then unset the keys from the array.
@end table


@defvr {Associative Shell Array} MMUX_BASH_PACKAGES_PACKAGE
A descriptor representing informations about the package provided by
@file{libmmux-bash-packages.bash}.  This package implements @api{} version @samp{0.0.0}.
@end defvr

@c page
@node packages registry
@appendixsec Registry of descriptors


A registry is maintained to keep track of the state of packages.  The functions of
@file{libmmux-bash-packages.bash} register a package descriptor changing its state as appropriate
while loading and unloading the package itself.  A package can be in the following states:

@table @code
@item provided
The source code has been sourced, but the package is not loaded.

This is the initial state after a package has been successfully provided with a call to
@func{mmux_package_provide_by_descriptor}.

This is the final state after a package has been successfully unloaded with a call to
@func{mmux_package_unload_by_descriptor}.

@item loaded
The source code has been sourced, and the package has been successfully loaded; which means that the
after--loading hook, if any, has been successfully evaluated.

This is the final state after a package has been successfully loaded with a call to
@func{mmux_package_load_by_descriptor}.

@item broken
The source code has been sourced, but an error occurred while loading or unloading the package; it
is safe to consider the package in an internally inconsistent state.
@end table


@ref{packages conventions, Conventions used in this documentation}.


@anchor{mmux_package_forget_descriptor}
@defun mmux_package_forget_descriptor @var{DESCRIPTOR_ARRAYNAME}
Remove from the registry a previously registered package descriptor.  The descriptor is removed no
matter its state.
@end defun


@defun mmux_package_register_descriptor_as_provided @var{DESCRIPTOR_ARRAYNAME}
Register a package descriptor giving it the state of @samp{provided}.
@end defun


@defun mmux_package_register_descriptor_as_loaded @var{DESCRIPTOR_ARRAYNAME}
Register a package descriptor giving it the state of @samp{loaded}.
@end defun


@defun mmux_package_register_descriptor_as_broken @var{DESCRIPTOR_ARRAYNAME}
Register a package descriptor giving it the state of @samp{broken}.
@end defun


@defun mmux_package_descriptor_is_registered @var{DESCRIPTOR_ARRAYNAME}
Return true if a package descriptor has been registered, no matter its state; otherwise return
false.
@end defun


@defun mmux_package_descriptor_is_registered_as_provided @var{DESCRIPTOR_ARRAYNAME}
Return true if a package descriptor has been registered and its state is @samp{provided}; otherwise
return false.
@end defun


@defun mmux_package_descriptor_is_registered_as_loaded @var{DESCRIPTOR_ARRAYNAME}
Return true if a package descriptor has been registered and its state is @samp{loaded}; otherwise
return false.
@end defun


@defun mmux_package_descriptor_is_registered_as_broken @var{DESCRIPTOR_ARRAYNAME}
Return true if a package descriptor has been registered and its state is @samp{broken}; otherwise
return false.
@end defun

@c page
@node packages requiring
@appendixsec Requiring a package


When the code of a package adhering to the @mmux{} Bash Packaging Infrastructure is sourced: it can
require a list of packages satisfying @api{} version requirements.  So in the source code of
@file{libmmux-bash-pointers.bash} there is the top--level code:

@example
mmux_package_require_by_descriptor MMUX_BASH_PACKAGES_PACKAGE 0
@end example

@noindent
while in the source code of @file{libmmux-bash-mpc.bash} there is the top--level code:

@example
mmux_package_require_by_descriptor MMUX_BASH_PACKAGES_PACKAGE 0
mmux_package_require_by_descriptor MMUX_BASH_POINTERS_PACKAGE 0
mmux_package_require_by_descriptor MMUX_BASH_MPFR_PACKAGE     0
@end example

@ref{packages conventions, Conventions used in this documentation}.

@defun mmux_package_require_by_descriptor @var{DESCRIPTOR_ARRAYNAME}
@defunx mmux_package_require_by_descriptor @var{DESCRIPTOR_ARRAYNAME} @var{API_VERSION}
Check that the registry contains a descriptor with name @var{DESCRIPTOR_ARRAYNAME} which supports
@api{} version @var{API_VERSION}, which must be the string representation of a non--negative exact
integer.  If the requirements are satisfied: return success; otherwise print error messages to
@stderr{} then call @func{mmux_package_exit_because_error_loading_package}.

When the argument @var{API_VERSION} is not present: it defaults to @samp{0}.

If @var{DESCRIPTOR_ARRAYNAME} is registered and it implements an @api{} with version number
@var{CURRENT} and age number @var{AGE}, the requirements are satisfied if:

@example
(@var{CURRENT} - @var{AGE}) <= @var{API_VERSION} <= @var{CURRENT}
@end example
@end defun

@c page
@node packages providing
@appendixsec Providing a package


When the code of a package adhering to the @mmux{} Bash Packaging Infrastructure is sourced: it
should announce itself by signalling that some package is provided.  So in the source code of
@file{libmmux-bash-pointers.bash} there is the top--level code:

@example
mmux_package_provide_by_descriptor MMUX_BASH_POINTERS_PACKAGE
@end example

@ref{packages conventions, Conventions used in this documentation}.


@defun mmux_package_provide_by_descriptor @var{DESCRIPTOR_ARRAYNAME}
Register a new package descriptor as provided.  When successful return true; otherwise return false.

It is an error to provide an already registered descriptor; if a descriptor with name
@var{DESCRIPTOR_ARRAYNAME} is already registered (no matter its state): an error message is printed
on @stderr{} and the return value is false.  To replace a descriptor we have to first forget it,
@ref{mmux_package_forget_descriptor} for details; this is required if, for example, we want to
re--source a shell library.

If the configuration option ``load when provide'' is enabled: load the package immediately by
applying @func{mmux_package_load_by_descriptor} to @var{DESCRIPTOR_ARRAYNAME}.
@end defun


@defun mmux_package_option_enable_load_when_provide
@defunx mmux_package_option_disable_load_when_provide
Enable or disable the configuration option ``load when provide''.  The default is: enabled.
@end defun


@defun mmux_package_option_load_when_provide_is_enabled
Return true if the option ``load when provide'' is enabled; otherwise return false.
@end defun

@c page
@node packages loading
@appendixsec Loading a package


Loading a package means to load a shell script in the current shell session and, if defined, to
enable loadable builtins from a shared library.


@defun mmux_package_load_by_descriptor @var{DESCRIPTOR_ARRAYNAME}
Do what is needed to load the package whose descriptor is the shell associative array
@var{DESCRIPTOR_ARRAYNAME}.  When successful return true; otherwise return false.

It is an error to load a shell package whose descriptor is not registered; if a descriptor with name
@var{DESCRIPTOR_ARRAYNAME} is not registered: an error message is printed on @stderr{}; the function
call returns immediately with status false.

It is an error to load a descriptor not in @samp{provided} state; if a descriptor with name
@var{DESCRIPTOR_ARRAYNAME} is already registered, and its state is not @samp{provided}: an error
message is printed on @stderr{}; the function call returns immediately with status false.

If the descriptor has a key @samp{BUILTIN_0}: the package requires loading a shared library to
enable builtins; the shared library file name is meant to be in the descriptor itself at key
@samp{SHARED_LIBRARY}.

It is an error if the descriptor has a key @samp{BUILTIN_0} but the key @samp{SHARED_LIBRARY} does
not exist or is not associated to a valid shared library name; in case of this error: the package is
registered as @samp{broken}; an error message is printed on @stderr{}; the function call returns
immediately with status false.

Use the @MmuxBuiltin{enable} builtin to load bulitins from the shared library using the identifiers
from the descriptor pairs with keys @samp{BUILTIN_0}, @samp{BUILTIN_1}, @dots{}

If an error occurs while enabling a loadable builtin:

@itemize
@item
If the option ``ignore enable builtin errors'' is enabled: the error message printed by
@MmuxBuiltin{enable} is redirected to @file{/dev/null} and the error ignored.

@item
If the option ``ignore enable builtin errors'' is disabled: the error message printed by
@MmuxBuiltin{enable} is redirected to @stderr{}; the package is registered as @samp{broken}; the
function call returns immediately with status false.
@end itemize

If the descriptor has a key @samp{PACKAGE_AFTER_LOADING_HOOK}, associated to an identifier: evaluate
that identifier to initialise the package after loading.  If an error occurs: register the package
as @samp{broken}; return false.

Finally register the package with state @samp{loaded}, then return true.
@end defun


@defun mmux_package_option_enable_ignore_enable_builtin_errors
@defunx mmux_package_option_disable_ignore_enable_builtin_errors
Enable or disable the configuration option ``ignore enable builtin errors''.  The default is: option
disabled.
@end defun


The following functions are made available in case there is the need to implement a custom package
loader.


@defun mmux_package_option_ignore_enable_builtin_errors_is_enabled
Return true if the configuration option ``ignore enable builtin errors'' is enabled; otherwise
return false.
@end defun


@defun mmux_package_descriptor_has_builtins_to_enable @var{DESCRIPTOR_ARRAYNAME}
Return true if the package descriptor lists builtins to enable; otherwise return false.
@end defun


@defun mmux_package_descriptor_has_shared_library @var{DESCRIPTOR_ARRAYNAME}
Return true if the package descriptor specifies a shared library from which builtins can be loaded;
otherwise return false.
@end defun


@defun mmux_package_enable_builtins @var{DESCRIPTOR_ARRAYNAME}
If the package descriptor lists builtins to enable: load them from the shared library and enable
them.  When successful return true; otherwise return false.

This function does @strong{not} change the registered state of the descriptor.

This function must be called only if: the descriptor lists builtins to enable; the descriptor
specifies a shared library.

If an error occurs while enabling a loadable builtin:

@itemize
@item
If the option ``ignore enable builtin errors'' is enabled: the error message printed by
@MmuxBuiltin{enable} is redirected to @file{/dev/null} and the error ignored.

@item
If the option ``ignore enable builtin errors'' is disabled: the error message printed by
@MmuxBuiltin{enable} is redirected to @stderr{}; the function call returns immediately with status
false.
@end itemize
@end defun


@defun mmux_package_run_descriptor_after_loading_hook @var{DESCRIPTOR_ARRAYNAME}
If the package descriptor specifies an after--loading hook: evaluate it; otherwise do nothing.  When
successful return true; otherwise return false.

This function does @strong{not} change the registered state of the descriptor.
@end defun

@c page
@node packages unloading
@appendixsec Unloading a package


Unloading a package means to remove from a shell session everything a package has added: variables,
functions, builtins, aliases, @MmuxBuiltin{trap} commands.  It might not always be possible.


@defun mmux_package_unload_by_descriptor @var{DESCRIPTOR_ARRAYNAME}
Do what is needed to unload the package whose descriptor is the shell associative array
@var{DESCRIPTOR_ARRAYNAME}.  When successful return true; otherwise return false.

It is an error to unload a shell package whose descriptor is not registered; if a descriptor with
name @var{DESCRIPTOR_ARRAYNAME} is not registered: an error message is printed on @stderr{} and the
return value is false.

It is an error to unload a descriptor not in @samp{loaded} state; if a descriptor with name
@var{DESCRIPTOR_ARRAYNAME} is already registered, and its state is not @samp{loaded}: an error
message is printed on @stderr{} and the return value is false.

If the descriptor has a key @samp{PACKAGE_BEFORE_UNLOADING_HOOK}, associated to an identifier:
evaluate that identifier to finalise the package before unloading.  If an error occurs: the package
is registered as @samp{broken}; the function call returns immediately with status false.

If the descriptor has a key @samp{ENABLED_BUILTIN_0}: the package required loading a shared library
to enable builtins; the shared library file name is meant to be in the descriptor itself at key
@samp{SHARED_LIBRARY}.  Use the @code{enable} builtin to disable bulitins from the shared library
using the identifiers from the descriptor pairs with keys @samp{ENABLED_BUILTIN_0},
@samp{ENABLED_BUILTIN_1}, @dots{} When all the enabled builtins are disabled: the shared library
should be closed.  If an error occurs disabling builtins: register the package as @samp{broken};
return false.

Finally register the package as @samp{unloaded}, then return true.
@end defun


The following functions are made available in case there is the need to implement a custom package
unloader.


@defun mmux_package_run_descriptor_before_unloading_hook @var{DESCRIPTOR_ARRAYNAME}
If the package descriptor specifies an before--unloading hook: evaluate it; otherwise do nothing.
When successful return true; otherwise return false.

This function does @strong{not} change the registered state of the descriptor.
@end defun


@defun mmux_package_descriptor_has_builtins_to_disable @var{DESCRIPTOR_ARRAYNAME}
Return true if the package descriptor lists builtins to disable; otherwise return false.
@end defun


@defun mmux_package_disable_builtins @var{DESCRIPTOR_ARRAYNAME}
Disable previously enabled builtins.  When successful return true; otherwise return false.

This function does @strong{not} change the registered state of the descriptor.
@end defun

@c page
@node packages printing
@appendixsec Printing messages


Some functions are implemented to print messages related to shell packages management.  They are
made available especially for ``after--loading hooks'' and ``before--unloading hooks''.


@defun mmux_package_print_error_message @var{TEMPLATE} @var{ARG} @dots{}
Works like @MmuxBuiltin{printf} and prints to @stderr{}.  Prefixes the message with @samp{MMUX
Package Manager: error: }, prints a trailing newline character.
@end defun


@defun mmux_package_print_warning_message @var{TEMPLATE} @var{ARG} @dots{}
Works like @MmuxBuiltin{printf} and prints to @stderr{}.  Prefixes the message with @samp{MMUX
Package Manager: warning: }, prints a trailing newline character.
@end defun


@defun mmux_package_print_verbose_message @var{TEMPLATE} @var{ARG} @dots{}
Works like @MmuxBuiltin{printf} and prints to @stderr{}.  Prefixes the message with @samp{MMUX
Package Manager: }, prints a trailing newline character.

Messages are printed only if the option ``verbose mode'' is enabled; nothing is printed if the
option is disabled.
@end defun


@defun mmux_package_print_debug_message @var{TEMPLATE} @var{ARG} @dots{}
Works like @MmuxBuiltin{printf} and prints to @stderr{}.  Prefixes the message with @samp{MMUX
Package Manager: debug: }, prints a trailing newline character.

Messages are printed only if the option ``debug mode'' is enabled; nothing is printed if the option
is disabled.
@end defun


@defun mmux_package_option_enable_verbose_mode
@defunx mmux_package_option_disable_verbose_mode
Enable or disable the option ``verbose mode''.
@end defun


@defun mmux_package_option_enable_debug_mode
@defunx mmux_package_option_disable_debug_mode
Enable or disable the option ``debug mode''.
@end defun


@defun mmux_package_option_verbose_mode_is_enabled
Return true if the option ``verbose mode'' is enabled; otherwise return false.
@end defun


@defun mmux_package_option_debug_mode_is_enabled
Return true if the option ``debug mode'' is enabled; otherwise return false.
@end defun

@c page
@node packages exiting
@appendixsec Exiting the script


@defun mmux_package_exit_because_error_loading_package
Exit the script by calling the builtin @MmuxBuiltin{exit} with exit status @samp{100}.  When a fatal
error occurs while managing a package: this function is used to terminate the script.
@end defun


@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mbfl{} is available online:

@center @url{http://github.com/marcomaggi/mbfl/}

the package @code{libdfp} is available online:

@center @url{https://github.com/libdfp/libdfp}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

