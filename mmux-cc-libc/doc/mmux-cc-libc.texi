\input texinfo.tex
@c %**start of header
@setfilename mmux-cc-libc.info
@settitle MMUX CC Types
@c %**end of header

@c @include version.texi
@include mmux-version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX CC Libc

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-cc-libc

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_CC_LIBC
@set PackagePkgconfigModule             mmux-cc-libc
@set PackageLibsVar                     @env{MMUX_CC_LIBC_LIBS}
@set PackageCflagsVar                   @env{MMUX_CC_LIBC_CFLAGS}
@c This is the stem of the library in "libmmux-cc-libc.so".
@set PackageLibstem                     mmux-cc-libc
@set PackageApiPrefixLower              mmux_
@set PackageApiPrefixUpper              MMUX_

@set PackageHeader                      mmux-cc-libc.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@macro mmuxcctypesref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,mmux-cc-types}
@end macro

@macro MmuxCFuncpage{FUNCNAME}
@ref{\FUNCNAME\,\FUNCNAME\,\FUNCNAME\,*manpages*}
@end macro

@macro MmuxCStruct{NAME}
@code{struct \NAME\}
@end macro

@macro MmuxCInterface{FUNCNAME}
Interface to the function @cfunc{\FUNCNAME\}, @MmuxCFuncpage{\FUNCNAME\}
@end macro

@c ------------------------------------------------------------------------

@macro MmuxCStructOpaqueTypedef{STRUCTNAME}
@deftp {Opaque Struct Typedef} mmux_libc_\STRUCTNAME\_t
An opaque alias for @MmuxCStruct{\STRUCTNAME\}.
@end deftp

@end macro

@macro MmuxSetterGetter{STRUCTNAME, FIELDNAME, FIELDTYPE}
@deftypefun bool mmux_libc_\FIELDNAME\_set (mmux_libc_\STRUCTNAME\_t * @var{\STRUCTNAME\_p}, \FIELDTYPE\ @var{\FIELDNAME\})
@deftypefunx bool mmux_libc_\FIELDNAME\_ref (\FIELDTYPE\ * @var{result_p}, mmux_libc_\STRUCTNAME\_t const * @var{\STRUCTNAME\_p})
Setter and getter for the field @code{\FIELDNAME\} of @objtype{mmux_libc_\STRUCTNAME\_t}.
@end deftypefun

@end macro

@macro MmuxStructDumper{STRUCTNAME}
@deftypefun bool mmux_libc_\STRUCTNAME\_dump (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_\STRUCTNAME\_t const * @var{struct_p}, char const * @var{struct_name})
Write to @var{fd} a description of the fields of the @MmuxCStruct{\STRUCTNAME\} referenced by
@var{struct_p}.  @var{struct_name} must be a pointer to an @asciiz{} string representing the name of
the data structure used in the description; when @cnull{}: it defaults to @samp{struct
\STRUCTNAME\}.
@end deftypefun

@end macro

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library implementing a wrapper to the @gnu{} C Library that makes it easier to interface it to
high--level platforms.

The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@gpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{MmuxPkgSemanticVersion}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-cc-libc: (mmux-cc-libc).       C11 language library wrapper for the @gnu{} C Library.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* version::                     Version functions.
* initialisation::              Library initialisation.
* memory::                      Memory management.
* time::                        Times and dates.
* system::                      System configuration.
* persona::                     Persona operations.
* processes::                   Processes.
* fds::                         File descriptors.
* fs::                          File system.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{MmuxPkgSemanticVersion} of @value{PACKAGE}, a C11 language
library meant to be used in foreign functions interfaces for higher--level languages.

@cindex @value{PackageHeaderFile}, header file
@cindex Header file @value{PackageHeaderFile}
@value{PACKAGE} installs multiple header files, of which @value{PackageHeaderFile} is the main one,
exporting the whole library @api{}.  All the function names in the @api{} are prefixed with
@code{@value{PackageApiPrefixLower}}; all the preprocessor symbol names are prefixed with
@code{@value{PackageApiPrefixUpper}}; all the type names are prefixed with
@code{@value{PackageApiPrefixLower}} and suffixed with @code{_t}.

The library is installed under @code{$libdir}; for example:

@example
/usr/local/lib64/lib@value{PackageLibstem}.so
@end example

@noindent
C language header files are installed under @code{$includedir}, for example:

@example
/usr/local/include/@value{PackageHeaderFile}
@end example

@menu
* overview stems::              Specifying C language types with their stem.
* overview errors::             Error handling.
* overview results::            Results handling.
* overview linking::            Linking code with the shared library.
@end menu

@c page
@node overview stems
@section Specifying C language types with their stem


@value{PACKAGE} uses the type definitions of the external package @emph{@mmux{} CC Types},
@mmuxcctypesref{overview stems, Specifying C language types with their stem}.

@c page
@node overview errors
@section Error handling


Unless otherwise specified, the functions that can fail return a @objtype{bool} value: @cfalse{}
when successful; @ctrue{} when an error occurs.

If a function may not be implemented by the system or the C library: the corresponding
@value{PACKAGE} function is always implemented; its return value is a @objtype{bool} and it is
always @cfalse{}; it sets @code{errno} to @samp{MMUX_LIBC_ENOSYS}.

@c page
@node overview results
@section Results handling


Unless otherwise specified, if the first argument of a function is a pointer named @var{result_p}:
the function will store in the referenced location the result of the call.

For example, we can write:

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example

@c page

@include overview-linking.texi

@c page
@node version
@chapter Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmux_cc_libc_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_cc_libc_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node initialisation
@chapter Library initialisation


@deftypefun bool mmux_cc_libc_init (void)
Initialise library's internal state; we can safely call this function multimple times.  When
successful return @cfalse{}; otherwise return @ctrue{}.
@end deftypefun

@c page
@node memory
@chapter Memory management


@menu
* memory allocation::           Memory allocation.
* memory operations::           Memory operations.
@end menu

@c page
@node memory allocation
@section Memory allocation


@deftypefn {Preprocessor Macro} bool mmux_libc_malloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{len})
@deftypefnx {Function} bool mmux_libc_malloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{len})
@MmuxCInterface{malloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.  Upon successful return: the pointer variable referenced by @var{P_p} is set to the pointer
referencing the newly allocated memory block.

@example
mmux_libc_tm_t *  tm;

if (mmux_libc_malloc(&tm, sizeof(mmux_libc_tm_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_calloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_calloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{calloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.  Upon successful return: the pointer variable referenced by @var{P_p} is set to the pointer
referencing the newly allocated memory block.

@example
mmux_double_t *  P;

if (mmux_libc_calloc(&P, 123, sizeof(mmux_double_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_realloc (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{newlen})
@deftypefnx Function bool mmux_libc_realloc_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{newlen})
@MmuxCInterface{realloc}.  The macro just casts a pointer @var{P_p} of any type to @code{mmux_pointer_t
*}.

@itemize
@item
Upon calling this function: @var{P_p} must reference a pointer variable holding the pointer to the
memory block to reallocate.

@item
Upon successfully returning from this function: the pointer variable referenced by @var{P_p} holds
the new pointer.
@end itemize

@example
mmux_libc_tm_t *  tm;

if (mmux_libc_malloc(&tm, 1024)) @{
  /* error */
@}
if (mmux_libc_realloc(&tm, 4096)) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} bool mmux_libc_reallocarray (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@deftypefnx Function bool mmux_libc_reallocarray_ (mmux_pointer_t * @var{P_p}, mmux_usize_t @var{item_num}, mmux_usize_t @var{item_len})
@MmuxCInterface{reallocarray}.  The macro just casts a pointer @var{P_p} of any type to
@code{mmux_pointer_t *}.  Upon successful return: the pointer variable referenced by @var{P_p} is
set to the pointer referencing the newly allocated memory block.

@example
mmux_double_t *  P;

if (mmux_libc_calloc(&P, 123, sizeof(mmux_double_t))) @{
  /* error */
@}
if (mmux_libc_reallocarray(&P, 456, sizeof(mmux_double_t))) @{
  /* error */
@}
@end example
@end deftypefn


@deftypefun bool mmux_libc_free (mmux_pointer_t @var{P})
@MmuxCInterface{free}.
@end deftypefun

@c page
@node memory operations
@section Memory operations


@deftypefun bool mmux_libc_memset (mmux_pointer_t @var{ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memset}.
@end deftypefun


@deftypefun bool mmux_libc_memzero (mmux_pointer_t @var{ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memzero}.
@end deftypefun


@deftypefun bool mmux_libc_memcpy (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcpy}.
@end deftypefun


@deftypefun bool mmux_libc_mempcpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{mempcpy}.
@end deftypefun


@deftypefun bool mmux_libc_memccpy (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_uint8_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memccpy}.
@end deftypefun


@deftypefun bool mmux_libc_memmove (mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memmove}.
@end deftypefun


@deftypefun bool mmux_libc_memcmp (mmux_sint_t * @var{result_p}, mmux_pointer_t @var{dst_ptr}, mmux_pointer_t @var{src_ptr}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memcmp}.
@end deftypefun


@deftypefun bool mmux_libc_memchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memchr}.
@end deftypefun


@deftypefun bool mmux_libc_rawmemchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet})
@MmuxCInterface{rawmemchr}.
@end deftypefun


@deftypefun bool mmux_libc_memrchr (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{ptr}, mmux_octet_t @var{octet}, mmux_usize_t @var{nbytes})
@MmuxCInterface{memrchr}.
@end deftypefun


@deftypefun bool mmux_libc_memmem (mmux_pointer_t * @var{result_p}, mmux_pointer_t @var{haystack_ptr}, mmux_usize_t @var{haystack_len}, mmux_pointer_t @var{needle_ptr}, mmux_usize_t @var{needle_len})
@MmuxCInterface{memmem}.
@end deftypefun

@c page
@node time
@chapter Times and dates


@menu
* time timeval::                The @objtype{mmux_libc_timeval_t} type.
* time timespec::               The @objtype{mmux_libc_timespec_t} type.
* time tm::                     The @objtype{mmux_libc_tm_t} type.
* time functions::              Handling time.
@end menu

@c page
@node time timeval
@section The @objtype{mmux_libc_timeval_t} type


@MmuxCStructOpaqueTypedef{timeval}
@MmuxSetterGetter{timeval, tv_sec,  mmux_time_t}
@MmuxSetterGetter{timeval, tv_usec, mmux_slong_t}
@MmuxStructDumper{timeval}


@deftypefun bool mmux_libc_timeval_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{microseconds})
Initialise the fields of a @MmuxCStruct{timeval}.
@end deftypefun

@c page
@node time timespec
@section The @objtype{mmux_libc_timespec_t} type


To have more expressive names: in this @api{} we ``rename'' the fields @samp{tv_sec} and
@samp{tv_nsec} of @MmuxCStruct{timespec} to @samp{ts_sec} and @samp{ts_nsec}.


@MmuxCStructOpaqueTypedef{timespec}
@MmuxSetterGetter{timespec, ts_sec,  mmux_time_t}
@MmuxSetterGetter{timespec, ts_nsec, mmux_slong_t}
@MmuxStructDumper{timespec}


@deftypefun bool mmux_libc_timespec_set (mmux_libc_timeval_t * @var{timeval_p}, mmux_time_t @var{seconds}, mmux_slong_t @var{nanoseconds})
Initialise the fields of a @MmuxCStruct{timespec}.
@end deftypefun

@c page
@node time tm
@section The @objtype{mmux_libc_tm_t} type


@MmuxCStructOpaqueTypedef{tm}
@MmuxSetterGetter{tm, tm_sec,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_min,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_hour,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_mon,         mmux_sint_t}
@MmuxSetterGetter{tm, tm_year,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_wday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_yday,        mmux_sint_t}
@MmuxSetterGetter{tm, tm_isdst,       mmux_sint_t}
@MmuxSetterGetter{tm, tm_gmtoff,      mmux_slong_t}
@MmuxSetterGetter{tm, tm_zone,        char const *}
@MmuxStructDumper{tm}


@deftypefun bool mmux_libc_tm_reset (mmux_libc_tm_t * @var{TM_P})
Reset the fields to:

@example
tm_sec    = 0
tm_min    = 0
tm_hour   = 0
tm_mday   = 1
tm_mon    = 0
tm_year   = 0
tm_wday   = 0
tm_yday   = 0
tm_isdst  = 0
tm_gmtoff = 0
tm_zone   = NULL
@end example
@end deftypefun

@c page
@node time functions
@section Handling time


@deftypefun bool mmux_libc_time (mmuc_time_t * @var{result_p})
@MmuxCInterface{time}.

@example
mmux_time_t       T;

mmux_libc_time(&T);
@end example
@end deftypefun


@deftypefun bool mmux_libc_localtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{localtime}.

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T);
mmux_libc_localtime(&tm_p, T);
@end example
@end deftypefun


@deftypefun bool mmux_libc_gmtime (mmux_libc_tm_t * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{gmtime}.

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T);
mmux_libc_gmtime(&tm_p, T);
@end example
@end deftypefun


@deftypefun bool mmux_libc_ctime (char const * * @var{result_p}, mmux_time_t @var{T})
@MmuxCInterface{ctime}.

@example
mmux_time_t     T;
char const *    str;

mmux_libc_time(&T);
mmux_libc_ctime(&str, T);
mmux_libc_dprintfou("%s\n", str);
@end example
@end deftypefun


@deftypefun bool mmux_libc_mktime (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{mktime}.

@example
mmux_time_t       T1, T2;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T1);
mmux_libc_localtime(&tm_p, T1);
mmux_libc_mktime(&T2, tm_p);
@end example
@end deftypefun


@deftypefun bool mmux_libc_timegm (mmux_time_t * @var{result_p}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{timegm}.

@example
mmux_time_t       T1, T2;
mmux_libc_tm_t *  tm_p;

mmux_libc_time(&T1);
mmux_libc_localtime(&tm_p, T1);
mmux_libc_timegm(&T2, tm_p);
@end example
@end deftypefun


@deftypefun bool mmux_libc_asctime (char const * * @var{result_p}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{asctime}.

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;
char const *      str;

mmux_libc_time(&T);
mmux_libc_localtime(&tm_p, T);
mmux_libc_asctime(&str, tm_p);
mmux_libc_dprintfou("%s\n", str);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strftime (char * @var{bufptr}, mmux_usize_t * @var{buflen_p}, char const * @var{template}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{strftime}.  Format an output string representation of the timestamp referenced by
@var{TM_P} and store it in the buffer referenced by @var{bufptr}.

@itemize
@item
Upon calling this function: @var{buflen_p} must reference a location containing the number of bytes
in the buffer referenced by @var{bufptr}.

@item
Upon successfully returning from a function call: the location referenced by @var{buflen_p} is set
to the number of characters in the output string, including the terminating null byte.
@end itemize

@example
mmux_time_t       T;
mmux_libc_tm_t *  tm_p;

#undef  IS_THIS_ENOUGH_QUESTION_MARK
#define IS_THIS_ENOUGH_QUESTION_MARK	4096
mmux_usize_t  buflen = IS_THIS_ENOUGH_QUESTION_MARK;
char          bufstr[buflen];

mmux_libc_time(&T);
mmux_libc_localtime(&tm_p, T);
if (mmux_libc_strftime(bufstr, &buflen, template, tm_p)) @{
  /* error */
@}
mmux_libc_dprintfou("%s\n", bufstr);
@end example
@end deftypefun


@deftypefun bool mmux_libc_strptime (char ** @var{first_unprocessed_after_timestamp_p}, char const * @var{input_string}, char const * @var{template}, mmux_libc_tm_t * @var{tm_p})
@MmuxCInterface{strptime}.

@example
char const *      template     = "%a, %d %b %Y %H:%M:%S %z";
char const *      input_string = "Fri, 15 Nov 2024 23:11:20 +0100";
mmux_libc_tm_t *  tm_p;
char *            first_unprocessed_after_timestamp;

if (mmux_libc_calloc(&tm_p, 1, sizeof(mmux_libc_tm_t)) @{
  /* error */
@}
if (mmux_libc_strptime(&first_unprocessed_after_timestamp, input_string, template, tm_p)) @{
  /* error */
@}
mmux_libc_tm_dump(MMUX_LIBC_STDOU, tm_p, NULL);
@end example
@end deftypefun


@deftypefun mmux_uint_t mmux_libc_sleep (mmux_uint_t * @var{leftover_result_p}, mmux_uint_t @var{seconds})
@MmuxCInterface{sleep}.
@end deftypefun


@deftypefun bool mmux_libc_nanosleep (mmux_libc_timespec_t * @var{requested_time}, mmux_libc_timespec_t * @var{remaining_time})
@MmuxCInterface{nanosleep}.

@example
mmux_libc_timespec_t    requested_time;
mmux_libc_timespec_t    remaining_time;

mmux_libc_timespec_set(&requested_time, 12, 34);
if (mmux_libc_nanosleep(&requested_time, &remaining_time)) @{
  /* error or interruption */
@}
@end example
@end deftypefun

@c page
@node system
@chapter System configuration


@menu
* system parameters::           Configuration parameters.
* system limits::               Configuration limits.
@end menu

@c page
@node system parameters
@section Configuration parameters


@cindex @samp{MMUX_LIBC_SC_} constants
@cindex @samp{MMUX_LIBC_CS_} constants
@cindex Constants @samp{MMUX_LIBC_SC_}
@cindex Constants @samp{MMUX_LIBC_CS_}


@deftypefun bool mmux_libc_sysconf (mmux_slong_t * @var{result_p}, mmux_sint_t @var{parameter})
@MmuxCInterface{sysconf}.  @var{parameter} must be one of the @samp{MMUX_LIBC__SC_*} constants.

@example
mmux_slong_t    result;

if (mmux_libc_sysconf(&result, MMUX_LIBC__SC_PAGESIZE)) @{
  /* error */
@}
/* the result is in "result" */
@end example
@end deftypefun


@deftypefun bool mmux_libc_confstr_size (mmux_usize_t * @var{result_required_nbytes_p}, mmux_sint_t @var{parameter})
@deftypefunx bool mmux_libc_confstr (mmux_sint_t @var{parameter}, char * @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{confstr}.  @var{parameter} must be one of the @samp{MMUX_LIBC__CS_*} constants.

@example
mmux_sint_t     parameter = MMUX_LIBC__CS_PATH;
mmux_usize_t    required_nbytes;

if (mmux_libc_confstr_size(&required_nbytes, parameter)) @{ /* error */ @}
@{
  char value[required_nbytes];

  if (mmux_libc_confstr(parameter, value, required_nbytes)) @{ /* error */ @}
  /* the result is in "value" */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pathconf (mmux_slong_t * @var{result_p}, char const * @var{pathname}, mmux_sint_t @var{parameter})
@MmuxCInterface{pathconf}.
@end deftypefun


@deftypefun bool mmux_libc_fpathconf (mmux_slong_t * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{parameter})
@MmuxCInterface{fpathconf}.
@end deftypefun

@c page
@node system limits
@section Configuration limits


@MmuxCStructOpaqueTypedef{rlimit}
@MmuxSetterGetter{rlimit, rlim_cur, mmux_rlim_t}
@MmuxSetterGetter{rlimit, rlim_max, mmux_rlim_t}
@MmuxStructDumper{rlimit}


@deftypefun bool mmux_libc_getrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{getrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_setrlimit (mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{rlimit_p})
@MmuxCInterface{setrlimit}.
@end deftypefun


@deftypefun bool mmux_libc_prlimit (mmux_libc_pid_t @var{pid}, mmux_sint_t @var{resource}, mmux_libc_rlimit_t * @var{new_rlimit_p}, mmux_libc_rlimit_t * @var{old_rlimit_p})
@MmuxCInterface{prlimit}.
@end deftypefun

@c page
@node persona
@chapter Persona operations


@menu
* persona uids::                Representing UIDs.
* persona gids::                Representing GIDs.
* persona getting::             Getting users and groups.
* persona setting::             Setting users and groups.
* persona login::               Identifying who logged in.
* persona database user::       User database.
* persona database group::      Group database.
@end menu

@c page
@node persona uids
@section Representing UIDs


To obtain a UID value and convert it to string, we can do:

@example
mmux_libc_uid_t         the_uid;
mmux_usize_t            required_nchars;

mmux_libc_getuid(&the_uid);

if (mmux_libc_uid_sprint_size(&required_nchars, the_uid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_uid_sprint(str, required_nchars, the_uid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_uid_t
Type of data structure containing a value of type @objtype{mmux_uid_t}.
@end deftp


@deftypefun bool mmux_libc_make_uid (mmux_libc_uid_t * @var{result_p}, mmux_uid_t @var{uid_num})
Build a new value of type @objtype{mmux_libc_uid_t}.
@end deftypefun


@deftypefun bool mmux_libc_uid_parse (mmux_libc_uid_t * @var{uid_p}, char const * @var{str}, char const * @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_uid_t}
value; store the value in the location referenced by @var{uid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_uid_t @var{uid})
Determine the number of characters required to contain the string representation of @var{uid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_uid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_uid_t @var{uid})
Convert @var{uid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona gids
@section Representing GIDs


To obtain a GID value and convert it to string, we can do:

@example
mmux_libc_gid_t         the_gid;
mmux_usize_t            required_nchars;

mmux_libc_getgid(&the_gid);

if (mmux_libc_gid_sprint_size(&required_nchars, the_gid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_gid_sprint(str, required_nchars, the_gid) @{
    /* error */
  @}
@}
@end example


@deftp {Opaque Struct Alias} mmux_libc_gid_t
Type of data structure containing a value of type @objtype{mmux_gid_t}.
@end deftp


@deftypefun bool mmux_libc_make_gid (mmux_libc_gid_t * @var{result_p}, mmux_gid_t @var{gid_num})
Build a new value of type @objtype{mmux_libc_gid_t}.
@end deftypefun


@deftypefun bool mmux_libc_gid_parse (mmux_libc_gid_t * @var{gid_p}, char const * @var{str}, char const * @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_gid_t}
value; store the value in the location referenced by @var{gid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_gid_t @var{gid})
Determine the number of characters required to contain the string representation of @var{gid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_gid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_gid_t @var{gid})
Convert @var{gid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node persona getting
@section Getting users and groups


@deftypefun bool mmux_libc_getuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{getuid}.
@end deftypefun


@deftypefun bool mmux_libc_getgid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getgid}.
@end deftypefun


@deftypefun bool mmux_libc_geteuid (mmux_libc_uid_t * @var{result_p})
@MmuxCInterface{geteuid}.
@end deftypefun


@deftypefun bool mmux_libc_getegid (mmux_libc_gid_t * @var{result_p})
@MmuxCInterface{getegid}.
@end deftypefun


To retrieve the supplementary groups of the current process we do:

@example
mmux_usize_t    ngroups;

if (mmux_libc_getgroups_size(&ngroups)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgroups(&ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgroups_size (mmux_usize_t * @var{result_ngroups_p})
Determine the number of supplementary groups of the current process and store it in the location
referenced by @var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgroups (mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgroups}.  Fill the array referenced by @var{groups_p} with values representing
the supplementary groups of the current process.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun


To retrieve the groups a user belongs to we do:

@example
char const *    user_name = gimme_a_username();
mmux_libc_git_t user_gid  = gimme_its_gid(user_name);
mmux_usize_t    ngroups;

if (mmux_libc_getgrouplist_size(&ngroups, user_name, user_gid)) @{
  /* error */
@} else @{
  mmux_libc_gid_t       gids[ngroups];

  if (mmux_libc_getgrouplist(user_name, user_gid, &ngroups, gids)) @{
    /* error */
  @} else @{
    /* do something with gids */
  @}
@}
@end example


@deftypefun bool mmux_libc_getgrouplist_size (mmux_usize_t * @var{result_ngroups_p}, char const * @var{username}, mmux_libc_gid_t @var{gid})
Determine the number of groups a user belongs to and store it in the location referenced by
@var{ngroups_p}.
@end deftypefun


@deftypefun bool mmux_libc_getgrouplist (char const * @var{username}, mmux_libc_gid_t @var{gid}, mmux_usize_t * @var{ngroups_p}, mmux_libc_gid_t * @var{groups_p})
@MmuxCInterface{getgrouplist}.  Fill the array referenced by @var{groups_p} with values representing
the groups a user belongs to.

@itemize
@item
Upon entering the function call: the array must have a number of elements equal to the value
referenced by @var{ngroups_p}.

@item
Upon returning from the function call: the location referenced by @var{ngroups_p} is updated with
the actual number of values stored in the array.
@end itemize
@end deftypefun

@c page
@node persona setting
@section Setting users and groups


@deftypefun bool mmux_libc_setuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{setuid}.
@end deftypefun


@deftypefun bool mmux_libc_seteuid (mmux_libc_uid_t @var{uid})
@MmuxCInterface{seteuid}.
@end deftypefun


@deftypefun bool mmux_libc_setreuid (mmux_libc_uid_t @var{uid}, mmux_libc_uid_t @var{euid})
@MmuxCInterface{setreuid}.
@end deftypefun


@deftypefun bool mmux_libc_setgid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setgid}.
@end deftypefun


@deftypefun bool mmux_libc_setegid (mmux_libc_gid_t @var{gid})
@MmuxCInterface{setegid}.
@end deftypefun


@deftypefun bool mmux_libc_setregid (mmux_libc_gid_t @var{gid}, mmux_libc_gid_t @var{egid})
@MmuxCInterface{setregid}.
@end deftypefun

@c page
@node persona login
@section Identifying who logged in


@deftypefun bool mmux_libc_getlogin (char const * * @var{result_username_p})
@MmuxCInterface{getlogin}.
@end deftypefun

@c page
@node persona database user
@section User database


@MmuxCStructOpaqueTypedef{passwd}
@MmuxSetterGetter{passwd,	pw_name,	char const *}
@MmuxSetterGetter{passwd,	pw_passwd,	char const *}
@MmuxSetterGetter{passwd,	pw_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{passwd,	pw_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{passwd,	pw_gecos,	char const *}
@MmuxSetterGetter{passwd,	pw_dir,		char const *}
@MmuxSetterGetter{passwd,	pw_shell,	char const *}
@MmuxStructDumper{passwd}


@deftypefun bool mmux_libc_getpwuid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_uid_t @var{uid})
@MmuxCInterface{getpwuid}.
@end deftypefun


@deftypefun bool mmux_libc_getpwnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, char const * @var{username})
@MmuxCInterface{getpwnam}.
@end deftypefun


@deftypefun bool mmux_libc_setpwent (void)
@MmuxCInterface{setpwent}.
@end deftypefun


@deftypefun bool mmux_libc_endpwent (void)
@MmuxCInterface{endpwent}.
@end deftypefun


@deftypefun bool mmux_libc_getpwent (mmux_libc_passwd_t * * @var{result_passwd_pp})
@MmuxCInterface{getpwent}.
@end deftypefun

@c page
@node persona database group
@section Group database


@MmuxCStructOpaqueTypedef{group}
@MmuxSetterGetter{group,	gr_name,	char const *}
@MmuxSetterGetter{group,	gr_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{group,	gr_mem,		char const **}
@MmuxStructDumper{group}


@deftypefun bool mmux_libc_getgrgid (mmux_libc_passwd_t * * @var{result_passwd_pp}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{getgrgid}.
@end deftypefun


@deftypefun bool mmux_libc_getgrnam (mmux_libc_passwd_t * * @var{result_passwd_pp}, char const * @var{groupname})
@MmuxCInterface{getgrnam}.
@end deftypefun


@deftypefn {@gnu{} Function} bool mmux_libc_group_member (bool * @var{result_is_member_p}, mmux_libc_gid_t @var{gid})
@MmuxCInterface{group_member}.
@end deftypefn


@deftypefun bool mmux_libc_setgrent (void)
@MmuxCInterface{setgrent}.
@end deftypefun


@deftypefun bool mmux_libc_endgrent (void)
@MmuxCInterface{endgrent}.
@end deftypefun


@deftypefun bool mmux_libc_getgrent (mmux_libc_group_t * * @var{result_group_pp})
@MmuxCInterface{getgrent}.
@end deftypefun

@c page
@node processes
@chapter Processes


@menu
* processes pids::              Representing PIDs.
* processes getting::           Getting PIDs.
@end menu

@c page
@node processes pids
@section Representing PIDs


@deftp {Opaque Struct Typedef} mmux_libc_pid_t
Opaque data structure type representing a @objtype{mmux_pid_t}.
@end deftp


@deftypefun bool mmux_libc_make_pid (mmux_libc_pid_t * @var{result_p}, mmux_pid_t @var{pid_num})
Build a new value of type @objtype{mmux_libc_pid_t}.
@end deftypefun


To convert a file descriptor to string we can do:

@example
mmux_libc_pid_t the_pid;
mmux_usize_t    required_nchars;

mmux_libc_getpid (&the_pid);

if (mmux_libc_pid_sprint_size(&required_nchars, the_pid) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_pid_sprint(str, required_nchars, the_pid) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_pid_parse (mmux_libc_pid_t * @var{pid_p}, char const * @var{str}, char const * @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_pid_t}
value; store the value in the location referenced by @var{pid_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_pid_t @var{pid})
Determine the number of characters required to contain the string representation of @var{pid} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_pid_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_pid_t @var{pid})
Convert @var{pid} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node processes getting
@section Getting PIDs


@deftypefun bool mmux_libc_getpid  (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitpid}.
@end deftypefun


@deftypefun  bool mmux_libc_getppid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gitppid}.
@end deftypefun


@deftypefun bool mmux_libc_gettid (mmux_libc_pid_t * @var{result_p})
@MmuxCInterface{gittid}.
@end deftypefun

@c page
@node fds
@chapter File descriptors


@menu
* fds fds::                     File descriptors type.
* fds printing::                Printing formatted output.
* fds opening::                 Opening file descriptors.
* fds closing::                 Closing file descriptors.
* fds reading::                 Reading from file descriptors.
* fds writing::                 Writing to file descriptors.
* fds seeking::                 Seeking position in file descriptors.
* fds duplicating::             Duplicating file descriptors.
* fds piping::                  Opening file descriptor pipes.
* fds selecting::               Selecting file descriptors.
* fds scatter-gather::          Scatter--gather input and output.
* fds range-copying::           Copying ranges from file to file.
* fds flock::                   File locks.
* fds fun control::             File descriptors functionality ontrol.
* fds io control::              File descriptors input/output control.
@end menu

@c page
@node fds fds
@section File descriptors type


@deftp {Opaque Type} mmux_libc_file_descriptor_t
@deftpx {Opaque Type} mmux_libc_fd_t
Opaque type representing file descriptors.  It must be passed by value.
@end deftp


@deftypefun bool mmux_libc_stdin (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard input.
@end deftypefun


@deftypefun bool mmux_libc_stdou (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard output.
@end deftypefun


@deftypefun bool mmux_libc_stder (mmux_libc_file_descriptor_t * @var{fd_p})
Retrieve the file descriptor value associated to the standard error.
@end deftypefun


@deftypefun bool mmux_libc_at_fdcwd (mmux_libc_file_descriptor_t * @var{result_p})
Return the file descriptor associated to the constant @code{AT_FDCWD}.  We can use it with
@cfunc{mmux_libc_openat} and similar functions.
@end deftypefun


@deftypefun bool mmux_libc_make_fd (mmux_libc_file_descriptor_t * @var{result_p}, mmux_sint_t @var{fd_num})
Make a new file descriptor value.
@end deftypefun

To convert a file descriptor to string we can do:

@example
mmux_libc_fd_t  the_fd = gimme_an_fd();
mmux_usize_t    required_nchars;

if (mmux_libc_fd_sprint_size(&required_nchars, the_fd) @{
  /* error */
@} else @{
  char  str[required_nchars];

  if (mmux_libc_fd_sprint(str, required_nchars, the_fd) @{
    /* error */
  @}
@}
@end example


@deftypefun bool mmux_libc_fd_parse (mmux_libc_fd_t * @var{fd_p}, char const * @var{str}, char const * @var{who})
Parse the @asciiz{} string referenced by @var{str} and convert it into a @objtype{mmux_libc_fd_t}
value; store the value in the location referenced by @var{fd_p}.  If an error occurs and @var{who}
is not @cnull{}: print an error message to @stderr{} using @var{who} as name of the entity that
performed the function call.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint_size (mmux_usize_t * @var{required_nchars_p}, mmux_libc_fd_t @var{fd})
Determine the number of characters required to contain the string representation of @var{fd} as
@asciiz{} string, @strong{including} the terminating nul character, and store it in the location
referenced by @var{required_nchars_p}.
@end deftypefun


@deftypefun bool mmux_libc_fd_sprint (char * @var{str}, mmux_usize_t @var{nchars}, mmux_libc_fd_t @var{fd})
Convert @var{fd} to its @asciiz{} string representation and store the result, @strong{including}
the terminating nul character, in the array referenced by @var{str}, which must be @var{nchars}
wide.
@end deftypefun

@c page
@node fds printing
@section Printing formatted output


@deftypefun bool mmux_libc_dprintf (mmux_libc_file_descriptor_t @var{fd}, char const * @var{template}, ...)
@MmuxCInterface{dprintf}.
@end deftypefun


@deftypefun bool mmux_libc_dprintfou (char const * template, ...)
Like @cfunc{mmux_libc_dprintf} but prints on @stdout{}.
@end deftypefun


@deftypefun bool mmux_libc_dprintfer (char const * template, ...)
Like @cfunc{mmux_libc_dprintf} but prints on @stderr{}.
@end deftypefun

@c page
@node fds opening
@section Opening file descriptors


@deftypefun bool mmux_libc_open (mmux_libc_file_descriptor_t * @var{result_p}, char const * @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{open}.

@example
char const *    pathname = "/path/to/file.ext";
mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

mmux_libc_file_descriptor_t     fd;

if (mmux_libc_open(&fd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_openat (mmux_libc_file_descriptor_t * @var{result_p}, mmux_libc_file_descriptor_t @var{dirfd}, char const * @var{pathname}, mmux_sint_t @var{flags}, mmux_mode_t @var{mode})
@MmuxCInterface{openat}.

@example
char const *    pathname = "path/to/file.ext";
mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

mmux_libc_file_descriptor_t     dirfd;
mmux_libc_file_descriptor_t     fd;

mmux_libc_at_fdcwd(&dirfd);
if (mmux_libc_openat(&fd, dirfd, pathname, flags, mode)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds closing
@section Closing file descriptors


@deftypefun bool mmux_libc_close (mmux_libc_file_descriptor_t @var{fd})
@MmuxCInterface{close}.
@end deftypefun

@c page
@node fds reading
@section Reading from file descriptors


@deftypefun bool mmux_libc_read (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{read}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
mmux_usize_t                    buflen = 4096;
mmux_uint8_t                    bufptr[buflen];

mmux_libc_stdin(&fd);
if (mmux_libc_read(&nbytes_done, fd, bufptr, bulen)) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pread (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pread}.
@end deftypefun

@c page
@node fds writing
@section Writing to file descriptors


@deftypefun bool mmux_libc_write (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen})
@MmuxCInterface{write}.

@example
mmux_libc_file_descriptor_t     fd;
mmux_usize_t                    nbytes_done;
char const *                    bufptr = "ciao";

mmux_libc_stdou(&fd);
if (mmux_libc_write(&nbytes_done, fd, bufptr, strlen(bufptr))) @{
  /* error */
@}
@end example
@end deftypefun


@deftypefun bool mmux_libc_pwrite (mmux_usize_t * @var{nbytes_done_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_pointer_t @var{bufptr}, mmux_usize_t @var{buflen}, mmux_off_t @var{offset})
@MmuxCInterface{pwrite}.
@end deftypefun

@c page
@node fds seeking
@section Seeking position in file descriptors


@deftypefun bool mmux_libc_lseek (mmux_libc_file_descriptor_t @var{fd}, mmux_off_t * @var{offset_p}, mmux_sint_t @var{whence})
@MmuxCInterface{lseek}.

Upon calling this function: @var{offset_p} must reference a variable whose value represents the
offset from the position selected by @var{whence}.

Upon successfully returning from this function: the variable referenced by @var{offset_p} has been
updated to represent the resulting position, measured in bytes, from the beginning of the file.

@example
mmux_libc_fd_t  fd     = get_some_fd();
mmux_off_t      offset = 123;
mmux_sint_t     whence = MMUX_LIBC_SEEK_SET;

if (mmux_libc_lseek(fd, &offset, whence)) @{
  /* error */
@}

/* now "offset" has been updated */
@end example
@end deftypefun

@c page
@node fds duplicating
@section Duplicating file descriptors


@deftypefun bool mmux_libc_dup (mmux_libc_file_descriptor_t * @var{new_fd_p}, mmux_libc_file_descriptor_t @var{old_fd})
@MmuxCInterface{dup}.
@end deftypefun


@deftypefun bool mmux_libc_dup2 (mmux_libc_file_descriptor_t @var{old_fd}, mmux_libc_file_descriptor_t @var{new_fd})
@MmuxCInterface{dup2}.
@end deftypefun


@deftypefun bool mmux_libc_dup3 (mmux_libc_file_descriptor_t @var{old_fd}, mmux_libc_file_descriptor_t @var{new_fd}, mmux_sint_t @var{flags})
@MmuxCInterface{dup3}.

@example
char const *    pathname = "/path/to/file.ext";
mmux_sint_t     flags    = MMUX_LIBC_O_RDWR | MMUX_LIBC_O_CREAT | MMUX_LIBC_O_EXCL;
mmux_mode_t     mode     = MMUX_LIBC_S_IRUSR | MMUX_LIBC_S_IWUSR;

mmux_libc_fd_t  fd1, fd2;

if (mmux_libc_open(&fd1, pathname, flags, mode)) @{
  /* error */
@}

/* I'm so dirty. */
mmux_libc_make_fd(&fd2, 5);

if (mmux_libc_dup3(fd1, fd2, MMUX_LIBC_O_CLOEXEC)) @{
  /* error */
@}
@end example
@end deftypefun

@c page
@node fds piping
@section Opening file descriptor pipes


@deftypefun bool mmux_libc_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
@MmuxCInterface{pipe}.
@end deftypefun


@deftypefun bool mmux_libc_close_pipe (mmux_libc_file_descriptor_t @var{fds}[2])
Close both the file descriptors in @var{fds}.  If both closures succeed: return @cfalse{}; otherwise
return @ctrue{}.  If closing the first fails: this function still closes the second.

This function might be useful when an error occurs after we have created a pipe.
@end deftypefun

@c page
@node fds selecting
@section Selecting file descriptors


Example:

@example
mmux_libc_fd_set_t      read_fd_set, writ_fd_set, exce_fd_set;
mmux_uint_t             nfds_ready;
mmux_uint_t             maximum_nfds_to_check = MMUX_LIBC_FD_SETSIZE;
mmux_libc_timeval_t     timeout;
mmux_libc_fd_t          in, ou;
bool                    isset;

mmux_libc_stdin(&in);
mmux_libc_stdou(&ou);

mmux_libc_FD_ZERO(read_fd_set);
mmux_libc_FD_ZERO(writ_fd_set);
mmux_libc_FD_ZERO(exce_fd_set);

mmux_libc_FD_SET(in, read_fd_set);
mmux_libc_FD_SET(ou, writ_fd_set);

mmux_timeval_set(&timeout, 1, 0);

if (mmux_libc_select(&nfds_ready, maximum_nfds_to_check,
                     &read_fd_set, &writ_fd_set, &exce_fd_set,
                     &timeout)) @{
  /* error */
@}

mmux_libc_FD_ISSET(&isset, in, read_fd_set);
/* do something */
mmux_libc_FD_ISSET(&isset, ou, writ_fd_set);
/* do something */
@end example


@deftypefun bool mmux_libc_FD_ZERO (mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_ZERO}.
@end deftypefun


@deftypefun bool mmux_libc_FD_SET (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_SET}.
@end deftypefun


@deftypefun bool mmux_libc_FD_CLR (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t * @var{fd_set_p})
@MmuxCInterface{FD_CLR}.
@end deftypefun


@deftypefun bool mmux_libc_FD_ISSET (bool * @var{result_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_fd_set_t const * @var{fd_set_p})
@MmuxCInterface{FD_ISSET}.
@end deftypefun


@deftypefun bool mmux_libc_select (mmux_uint_t * @var{nfds_ready_p}, mmux_uint_t @var{maximum_nfds_to_check}, mmux_libc_fd_set_t * @var{read_fd_set_p}, mmux_libc_fd_set_t * @var{write_fd_set_p}, mmux_libc_fd_set_t * @var{except_fd_set_p}, mmux_libc_timeval_t * @var{timeout_p})
@MmuxCInterface{select}.
@end deftypefun

@c page
@node fds scatter-gather
@section Scatter--gather input and output


@MmuxCStructOpaqueTypedef{iovec}


@deftp {Opaque Struct Typedef} mmux_libc_iovec_array_t
Data structure type representing an array of @objtype{mmux_libc_iovec_t} data structures.  It has
the following fields:

@table @code
@item iova_base
Pointer to the array.

@item iova_len
Number of slots in the array.
@end table
@end deftp

@MmuxSetterGetter{iovec, iov_base, mmux_pointer_t}
@MmuxSetterGetter{iovec, iov_len,  mmux_usize_t}
@MmuxStructDumper{iovec}

@MmuxSetterGetter{iovec_array, iova_base, mmux_pointer_t}
@MmuxSetterGetter{iovec_array, iova_len,  mmux_usize_t}
@MmuxStructDumper{iovec_array}


@deftypefun bool mmux_libc_readv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array})
@MmuxStructDumper{readv}.
@end deftypefun


@deftypefun bool mmux_libc_writev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array})
@MmuxStructDumper{writev}.
@end deftypefun


@deftypefun bool mmux_libc_preadv (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset})
@MmuxStructDumper{preadv}.
@end deftypefun


@deftypefun bool mmux_libc_pwritev (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset})
@MmuxStructDumper{pwritev}.
@end deftypefun


@deftypefun bool mmux_libc_preadv2 (mmux_usize_t * @var{nbytes_read_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxStructDumper{preadv2}.
@end deftypefun


@deftypefun bool mmux_libc_pwritev2 (mmux_usize_t * @var{nbytes_written_p}, mmux_libc_file_descriptor_t @var{fd}, mmux_libc_iovec_array_t @var{iovec_array}, mmux_off_t @var{offset}, mmux_sint_t @var{flags})
@MmuxStructDumper{pwritev2}.
@end deftypefun

@c page
@node fds range-copying
@section Copying ranges from file to file


@deftypefun bool mmux_libc_copy_file_range (mmux_usize_t * @var{number_of_bytes_copied_p}, mmux_libc_file_descriptor_t @var{input_fd}, mmux_sint64_t * @var{input_position_p}, mmux_libc_file_descriptor_t @var{ouput_fd}, mmux_sint64_t * @var{ouput_position_p}, mmux_usize_t @var{number_of_bytes_to_copy}, mmux_sint_t @var{flags})
@MmuxCInterface{copy_file_range}.
@end deftypefun

@c page
@node fds flock
@section File locks


@MmuxCStructOpaqueTypedef{flock}
@MmuxSetterGetter{flock, l_type,   mmux_sshort_t}
@MmuxSetterGetter{flock, l_whence, mmux_sshort_t}
@MmuxSetterGetter{flock, l_start,  mmux_off_t}
@MmuxSetterGetter{flock, l_len,    mmux_off_t}
@MmuxSetterGetter{flock, l_pid,    mmux_libc_pid_t}
@MmuxStructDumper{flock}

@deftypefun bool mmux_libc_flag_to_symbol_struct_flock_l_type (char const ** @var{str_p}, mmux_sint_t @var{flag})
Identify @var{flag} as a value for the field @code{l_type} of @objtype{mmux_libc_flock_t}; store in
the variable referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string
representing the name of the value.
@end deftypefun

@c page
@node fds fun control
@section File descriptors functionality ontrol


@deftypefun bool mmux_libc_fcntl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{fcntl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{fcntl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun


@deftypefun bool mmux_libc_fcntl_command_flag_to_symbol (char const ** @var{str_p}, mmux_sint_t @var{command})
Identify @var{command} as a command argument for @cfunc{mmux_libc_fcntl}; store in the variable
referenced by @var{str_p} a pointer to a statically allocated @asciiz{} string representing a string
representation of the @var{command}.
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_DUPFD
Duplicate a file descriptor; @var{parameter_p} reference a variable of type
@objtype{mmux_libc_file_descriptor_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFD
Get file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} reference a variable
of type @objtype{mmux_sint_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFD
Set file descriptor flags, like @samp{MMUX_LIBC_FD_CLOEXEC}; @var{parameter_p} reference a variable
of type @objtype{mmux_sint_t} holding a bitwise OF combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETFL
Get open file descriptor flags, like @samp{O_RDWR}; @var{parameter_p} reference a variable of type
@objtype{mmux_sint_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETFL
Set open file descriptor flags, like @samp{O_APPEND}; @var{parameter_p} reference a variable of type
@objtype{mmux_sint_t} holding a bitwise OF combination of flags.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_GETLK
Get a @MmuxCStruct{flock} describing a lock that blocks a requested lock; @var{parameter_p} must
reference a value of type @objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLK
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_OFD_SETLKW
Set or clear file lock; @var{parameter_p} must reference a value of type
@objtype{mmux_libc_flock_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_GETOWN
Get the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c ------------------------------------------------------------------------

@defvr {Fcntl Command} MMUX_LIBC_F_SETOWN
Set the process or group id that receives the signal @samp{SIGIO}; @var{parameter_p} must reference
a variable of type @objtype{mmux_libc_pid_t}.
@end defvr

@c page
@node fds io control
@section File descriptors input/output control


@deftypefun bool mmux_libc_ioctl (mmux_libc_file_descriptor_t @var{fd}, mmux_sint_t @var{command}, mmux_pointer_t @var{parameter_p})
@MmuxCInterface{ioctl}.  Arguments:

@table @var
@item fd
A file descriptor.

@item command
A constant representing a command for @cfunc{ioctl}.

@item parameter_p
Pointer to a variable representing a parameter that can be input or output depending on the
@var{command}.
@end table
@end deftypefun

@c ------------------------------------------------------------------------

@defvr {Iontl Command} MMUX_LIBC_SIOCATMARK
Detect if the data received through a socket has reached the mark; @var{parameter_p} must reference
a variable of type @objtype{mmux_sint_t}.
@end defvr

@c page
@node fs
@chapter File system


@menu
* fs types::                    Type definitions for file system operations.
* fs links::                    Hard and symbolic links.
* fs deleting::                 Deleting links.
* fs renaming::                 Renaming links.
* fs directories::              Directories.
* fs ownership::                File ownership.
* fs permissions::              File access permissions.
* fs attributes::               File attributes.
* fs truncating::               Truncating files.
* fs times::                    File system times.
@end menu

@c page
@node fs types
@section Type definitions for file system operations


@deftp {Opaque Struct Type} mmux_libc_file_system_pathname_t
@deftpx {Opaque Struct Type} mmux_libc_ptn_t
Data type representing a file system pathname as a non--@cnull{} pointer to @asciiz{} string.
@end deftp


@deftypefun bool mmux_libc_make_file_system_pathname (mmux_libc_file_system_pathname_t * @var{pathname_p}, mmux_asciizcp_t @var{asciiz_pathname})
Make a new file system pathname value.
@end deftypefun


@deftypefun bool mmux_libc_file_system_pathname_free (mmux_libc_file_system_pathname_t @var{pathname})
Release the memory holding the pathname as @asciiz{} string using @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs links
@section Hard and symbolic links


@deftypefun bool mmux_libc_link (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{link}.
@end deftypefun


@deftypefun bool mmux_libc_linkat (mmux_libc_file_descriptor_t @var{oldfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_sint_t @var{flags})
@MmuxCInterface{linkat}
@end deftypefun


@deftypefun bool mmux_libc_symlink (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{symlink}.
@end deftypefun


@deftypefun bool mmux_libc_readlink (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlink}.
@end deftypefun


@deftypefun bool mmux_libc_readlink_malloc (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{linkname})
Like @cfunc{mmux_libc_readlink} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it, including the
terminating nul character; we must release the allocated memory using @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_readlinkat (mmux_usize_t * @var{required_nbytes_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname}, mmux_asciizp_t @var{buffer}, mmux_usize_t @var{provided_nbytes})
@MmuxCInterface{readlinkat}.
@end deftypefun


@deftypefun bool mmux_libc_readlinkat_malloc (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{linkname})
Like @cfunc{mmux_libc_readlinkat} but when successful: allocate a memory block, using
@cfunc{mmux_libc_malloc}, and store the resulting pathname @asciiz{} string in it, including the
terminating nul character; we must release the allocated memory using @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_canonicalize_file_name (mmux_libc_file_system_pathname_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{canonicalize_file_name}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun


@deftypefun bool mmux_libc_realpath (mmux_asciizp_t * @var{result_pathname_p}, mmux_libc_file_system_pathname_t @var{input_pathname})
@MmuxCInterface{realpath}.  When successful: a memory buffer is allocated, using
@cfunc{mmux_libc_malloc}, and the resulting pathname is stored in it, including the terminating nul;
a pointer to the buffer is stored in the location referenced by @var{result_pathname_p}.  It is
responsibility of the caller to release the buffer with a call to @cfunc{mmux_libc_free}.
@end deftypefun

@c page
@node fs deleting
@section Deleting links


@deftypefun bool mmux_libc_unlink (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{unlink}.
@end deftypefun


@deftypefun bool mmux_libc_unlinkat (mmux_libc_file_descriptor_t dirfd, mmux_libc_file_system_pathname_t pathname, mmux_sint_t flags)
@MmuxCInterface{unlinkat}.
@end deftypefun


@deftypefun bool mmux_libc_rmdir (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{rmdir}.
@end deftypefun


@deftypefun bool mmux_libc_remove (mmux_libc_file_system_pathname_t pathname)
@MmuxCInterface{remove}.
@end deftypefun

@c page
@node fs renaming
@section Renaming links


@deftypefun mmux_cc_libc_decl bool mmux_libc_rename (mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{rename}.
@end deftypefun


@deftypefun mmux_cc_libc_decl bool mmux_libc_renameat (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname})
@MmuxCInterface{renameat}.
@end deftypefun


@deftypefn {Linux Function} mmux_cc_libc_decl bool mmux_libc_renameat2 (mmux_libc_file_descriptor_t @var{olddirfd}, mmux_libc_file_system_pathname_t @var{oldname}, mmux_libc_file_descriptor_t @var{newdirfd}, mmux_libc_file_system_pathname_t @var{newname}, mmux_uint_t flags)
@MmuxCInterface{renameat2}.
@end deftypefn

@c page
@node fs directories
@section Directories


@deftypefun bool mmux_libc_mkdir (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t mode)
@MmuxCInterface{mkdir}.
@end deftypefun


@deftypefun bool mmux_libc_mkdirat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{mkdirat}.
@end deftypefun

@c page
@node fs ownership
@section File ownership


@deftypefun bool mmux_libc_chown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{chown}.
@end deftypefun


@deftypefun bool mmux_libc_fchown (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{fchown}.
@end deftypefun


@deftypefun bool mmux_libc_lchown (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid});
@MmuxCInterface{lchown}.
@end deftypefun


@deftypefun bool mmux_libc_fchownat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_uid_t @var{uid}, mmux_libc_gid_t @var{gid}, mmux_sint_t flags);
@MmuxCInterface{fchownat}.
@end deftypefun

@c page
@node fs permissions
@section File access permissions


@deftypefun bool mmux_libc_umask (mmux_mode_t * @var{old_mask_p}, mmux_mode_t @var{new_mask})
@MmuxCInterface{umask}.
@end deftypefun


@deftypefun bool mmux_libc_getumask (mmux_mode_t * @var{current_mask_p})
Store the current mask in the location referenced by @var{current_mask_p}.  Do not change the
current mask.
@end deftypefun


@deftypefun bool mmux_libc_chmod (mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode})
@MmuxCInterface{chmod}.
@end deftypefun


@deftypefun bool mmux_libc_fchmod (mmux_libc_file_descriptor_t @var{fd}, mmux_mode_t @var{mode})
@MmuxCInterface{fchmod}.
@end deftypefun


@deftypefun bool mmux_libc_fchmodat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_mode_t @var{mode}, mmux_sint_t @var{flags})
@MmuxCInterface{fchmodat}.
@end deftypefun


@deftypefun bool mmux_libc_access (mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how})
@MmuxCInterface{access}.
@end deftypefun


@deftypefun bool mmux_libc_faccessat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_sint_t @var{how}, mmux_sint_t @var{flags})
@MmuxCInterface{faccessat}.
@end deftypefun

@c page
@node fs attributes
@section File attributes


@MmuxCStructOpaqueTypedef{stat}
@MmuxSetterGetter{stat, st_mode,        mmux_mode_t}
@MmuxSetterGetter{stat,	st_ino,		mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_dev,		mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_nlink,	mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_uid,		mmux_libc_uid_t}
@MmuxSetterGetter{stat,	st_gid,		mmux_libc_gid_t}
@MmuxSetterGetter{stat,	st_size,	mmux_off_t}
@MmuxSetterGetter{stat,	st_atime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_atime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_mtime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_mtime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_ctime_sec,	mmux_time_t}
@MmuxSetterGetter{stat,	st_ctime_nsec,	mmux_slong_t}
@MmuxSetterGetter{stat,	st_blocks,	mmux_uintmax_t}
@MmuxSetterGetter{stat,	st_blksize,	mmux_uint_t}
@MmuxStructDumper{stat}


@deftypefun bool mmux_libc_stat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{stat}.
@end deftypefun


@deftypefun bool mmux_libc_fstat (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{fstat}.
@end deftypefun


@deftypefun bool mmux_libc_lstat (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{lstat}.
@end deftypefun


@deftypefun bool mmux_libc_fstatat (mmux_libc_file_descriptor_t @var{dirfd}, mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_stat_t * @var{stat_p}, mmux_sint_t flags)
@MmuxCInterface{fstatat}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISMQ (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPESIMQ}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSEM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSEM}.
@end deftypefun


@deftypefun bool mmux_libc_S_TYPEISSHM (bool * @var{result_p}, mmux_libc_stat_t * @var{stat_p})
@MmuxCInterface{S_TYPEISSHM}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISDIR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISDIR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISCHR (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISCHR}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISBLK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISBLK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISREG (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISREG}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISFIFO (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISFIFO}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISLNK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISLNK}.
@end deftypefun


@deftypefun bool mmux_libc_S_ISSOCK (bool * @var{result_p}, mmux_mode_t @var{mode})
@MmuxCInterface{S_ISSOCK}.
@end deftypefun

@c page
@node fs truncating
@section Truncating files


@deftypefun bool mmux_libc_truncate (mmux_libc_file_system_pathname_t pathname, mmux_off_t len)
@MmuxCInterface{truncate}.
@end deftypefun


@deftypefun bool mmux_libc_ftruncate (mmux_libc_file_descriptor_t fd, mmux_off_t len);
@MmuxCInterface{ftruncate}.
@end deftypefun

@c page
@node fs times
@section File system times


@MmuxCStructOpaqueTypedef{utimbuf}
@MmuxSetterGetter{utimbuf, actime,   mmux_time_t}
@MmuxSetterGetter{utimbuf, modtime,   mmux_time_t}
@MmuxStructDumper{utimbuf}


@deftypefun bool mmux_libc_utime (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_utimbuf_t * @var{utimbuf_p})
@MmuxCInterface{utime}.
@end deftypefun


@deftypefun bool mmux_libc_utimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t * @var{access_p}, mmux_libc_timeval_t * @var{modification_p})
@MmuxCInterface{utimes}.
@end deftypefun

@deftypefun bool mmux_libc_lutimes (mmux_libc_file_system_pathname_t @var{pathname}, mmux_libc_timeval_t * @var{access_p}, mmux_libc_timeval_t * @var{modification_p})
@MmuxCInterface{lutimes}.
@end deftypefun


@deftypefun bool mmux_libc_futimes (mmux_libc_file_descriptor_t @var{fd}, mmux_libc_timeval_t * @var{access_p}, mmux_libc_timeval_t * @var{modification_p})
@MmuxCInterface{futimes}.
@end deftypefun

@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

