\input texinfo.tex
@c %**start of header
@setfilename mmux-bash-pointers.info
@settitle MMUX Bash Pointers
@c %**end of header

@include version.texi
@include macros.texi

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      MMUX Bash Pointers

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    MMUX Bash Pointers

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           mmux-bash-pointers

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{mrc.mgg@@gmail.com}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2024

@c ------------------------------------------------------------

@set PackageAutoconfPrefix              MMUX_BASH_POINTERS
@set PackagePkgconfigModule             mmux-bash-pointers
@set PackageLibsVar                     @env{MMUX_BASH_POINTERS_LIBS}
@set PackageCflagsVar                   @env{MMUX_BASH_POINTERS_CFLAGS}
@c This is the stem of the library in "libmmux-bash-pointers.so".
@set PackageLibstem                     mmux-bash-pointers
@set PackageApiPrefixLower              mmux_bash_pointers_
@set PackageApiPrefixUpper              MMUX_BASH_POINTERS_

@set PackageHeader                      mmux-bash-pointers.h
@set PackageHeaderFile                  @file{@value{PackageHeader}}

@set GithubUrl                 @url{https://github.com/marcomaggi/@value{PACKAGE_NICKNAME}}
@set DocumentationUrl          @url{https://marcomaggi.github.io/docs/@value{PACKAGE_NICKNAME}.html}

@c page
@c ------------------------------------------------------------
@c Local macros.
@c ------------------------------------------------------------

@ifinfo
@macro mbfl{}
@acronym{MBFL}
@end macro
@end ifinfo
@ifnotinfo
@macro mbfl{}
@acronym{mbfl}
@end macro
@end ifnotinfo

@ifinfo
@macro mmux{}
@acronym{MMUX}
@end macro
@end ifinfo
@ifnotinfo
@macro mmux{}
@acronym{mmux}
@end macro
@end ifnotinfo

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying

This document describes version @value{VERSION} of @value{PACKAGE}, a package implementing
additional builtin commands for the @gnu{} Bash shell; to do so it installs a C11 language library
and a shell script which is meant to be sourced in a Bash session or script.

This package makes raw memory pointers available in shell scripts; it also interfaces some basic
functions from the C language @posix{} standard library.  The package targets @posix{} platforms.

This package is distributed under the terms of the @gnu{} General Public License (@lgpl{}).

Development of this package takes place at:

@center @value{GithubUrl}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the @gnu{}
Free Documentation License, Version 1.3 or any later version published by the Free Software
Foundation; with Invariant Sections being ``@gnu{} Free Documentation License'' and ``@gnu{} Lesser
General Public License'', no Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @value{VERSION}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* mmux-bash-pointers: (mmux-bash-pointers).  Additional GNU Bash builtins.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* variables::                   Global variables.
* types::                       Interface to supported data types.
* memory::                      Raw memory operations.
* errors::                      Handling errors.
* fds::                         Core file descriptor operations.
* misc::                        Miscellaneous features.

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.
* shared library::              Using the shared library.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node overview
@chapter Overview of the package


This document describes version @value{VERSION} of @value{PACKAGE}, a package implementing
additional builtin commands for the @gnu{} Bash shell; to do so it installs a C11 language library
and a shell script which is meant to be sourced in a Bash session or script.

This package makes raw memory pointers available in shell scripts:

@example
source /usr/local/share/bash/libmmux-bash-pointers.bash

declare PTR VALUE

mmux_libc_malloc PTR 1024
@{
  mmux_sint_pointer_set $PTR 0 123
  mmux_sint_pointer_ref VALUE $PTR 0
@}
mmux_libc_free $PTR
$VALUE  @result{} 123
@end example

@menu
* overview install::            Installed files.
* overview linking::            Linking code with the library.
* overview decimal::            Support for the @objtype{_DecimalN} types.
* overview stems::              Specifying C language types with their stem.
@end menu

@c page
@node overview install
@section Installed files


@value{PACKAGE} installs a shell script, a ``shell library'', under @code{$datavar/bash}; for
example:

@center @file{/usr/local/share/bash/libmmux-bash-pointers.bash}

@noindent
to use the builtins, we have to load the shell library using Bash's builtin @code{source}.  A shared
library, actually implementing the builtins, is installed under @code{$libdir}; for example:

@center @file{/usr/local/lib64/libmmux-bash-pointers.so}

@noindent
the shared library is automatically loaded by the shell library.

C language header files are also installed under @code{$includedir}, for example:

@center @file{/usr/local/include/libmmux-bash-pointers.h}
@center @file{/usr/local/include/libmmux-bash-pointers-config.h}

@noindent
we can write code that links to the shared library to reuse some of its facilities.

@c page

@include overview-linking.texi

@c page
@node overview decimal
@section Support for the @objtype{_DecimalN} types


Support for the @objtype{_DecimalN} types is enabled if availability of such types is detected at
package--configuration time.  This package relies on the availability of the external package
@code{libdfp}.

@c page
@node overview stems
@section Specifying C language types with their stem


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{float}, type stem
@cindex @code{double}, type stem
@cindex @code{ldouble}, type stem

@cindex @code{float32}, type stem
@cindex @code{float64}, type stem
@cindex @code{float128}, type stem

@cindex @code{float32x}, type stem
@cindex @code{float64x}, type stem
@cindex @code{float128x}, type stem

@cindex @code{decimal32}, type stem
@cindex @code{decimal64}, type stem
@cindex @code{decimal128}, type stem

@cindex @code{complexf}, type stem
@cindex @code{complexd}, type stem
@cindex @code{complexld}, type stem

@cindex @code{complexf32}, type stem
@cindex @code{complexf64}, type stem
@cindex @code{complexf128}, type stem

@cindex @code{complexf32x}, type stem
@cindex @code{complexf64x}, type stem
@cindex @code{complexf128x}, type stem

@cindex @code{complexd32}, type stem
@cindex @code{complexd64}, type stem
@cindex @code{complexd128}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem


The following word definitions just alias the corresponding C language type; such uniform names are
useful when using preprocessor macros to generate code.

If @value{PACKAGE} supports a type: it blindly implements all the possible operations for it, even
when it looks like an operation does not make much sense.  A type is a type.

@macro MmuxDefineTypeStem{STEM,TYPE}
@deftp {Type Stem} \STEM\
Single--word specification of a C language type supported by this package.  It is an alias for the C
language type @code{\TYPE\}.
@end deftp

@end macro


@MmuxDefineTypeStem{pointer,void *}

@MmuxDefineTypeStem{schar,signed char}
@MmuxDefineTypeStem{uchar,unsigned char}
@MmuxDefineTypeStem{sshort,signed short int}
@MmuxDefineTypeStem{ushort,unsigned short int}
@MmuxDefineTypeStem{sint,signed int}
@MmuxDefineTypeStem{uint,unsigned int}
@MmuxDefineTypeStem{slong,signed long}
@MmuxDefineTypeStem{ulong,unsigned long}
@MmuxDefineTypeStem{sllong,signed long long}
@MmuxDefineTypeStem{ullong,unsigned long long}
@MmuxDefineTypeStem{float,float}
@MmuxDefineTypeStem{double,double}
@MmuxDefineTypeStem{ldouble,long double}

@MmuxDefineTypeStem{float32, _Float32}
@MmuxDefineTypeStem{float64, _Float64}
@MmuxDefineTypeStem{float128, _Float128}

@MmuxDefineTypeStem{float32x, _Float32x}
@MmuxDefineTypeStem{float64x, _Float64x}
@MmuxDefineTypeStem{float128x, _Float128x}

@MmuxDefineTypeStem{decimal32, _Decimal32}
@MmuxDefineTypeStem{decimal64, _Decimal64}
@MmuxDefineTypeStem{decimal128, _Decimal128}

@MmuxDefineTypeStem{complexf,float complex}
@MmuxDefineTypeStem{complexd,double complex}
@MmuxDefineTypeStem{complexld,long double complex}

@MmuxDefineTypeStem{complexf32, _Float32 complex}
@MmuxDefineTypeStem{complexf64, _Float64 complex}
@MmuxDefineTypeStem{complexf128, _Float128 complex}

@MmuxDefineTypeStem{complexf32x, _Float32 complex}
@MmuxDefineTypeStem{complexf64x, _Float64x complex}
@MmuxDefineTypeStem{complexf128x, _Float128x complex}

@MmuxDefineTypeStem{complexd32, _Decimal32 complex}
@MmuxDefineTypeStem{complexd64, _Decimal64 complex}
@MmuxDefineTypeStem{complexd128, _Decimal128 complex}

@MmuxDefineTypeStem{sint8,int8_t}
@MmuxDefineTypeStem{uint8,uint8_t}
@MmuxDefineTypeStem{sint16,int16_t}
@MmuxDefineTypeStem{uint16,uint16_t}
@MmuxDefineTypeStem{sint32,int32_t}
@MmuxDefineTypeStem{uint32,uint32_t}
@MmuxDefineTypeStem{sint64,int64_t}
@MmuxDefineTypeStem{uint64,uint64_t}

@MmuxDefineTypeStem{ssize,ssize_t}
@MmuxDefineTypeStem{usize,size_t}
@MmuxDefineTypeStem{sintmax, intmax_t}
@MmuxDefineTypeStem{uintmax, uintmax_t}
@MmuxDefineTypeStem{sintptr, intptr_t}
@MmuxDefineTypeStem{uintptr, uintptr_t}
@MmuxDefineTypeStem{mode, mode_t}
@MmuxDefineTypeStem{off, off_t}
@MmuxDefineTypeStem{pid, pid_t}
@MmuxDefineTypeStem{uid, uid_t}
@MmuxDefineTypeStem{gid, gid_t}
@MmuxDefineTypeStem{wchar, wchar_t}
@MmuxDefineTypeStem{wint, wint_t}

@c page
@node variables
@chapter Global variables


The shell library installed by @value{PACKAGE} defines global variables to allow inspection of the
underlying C language platform.

@menu
* variables version::           Version variables.
* variables sizeof::            C language type sizes.
* variables limits::            C language type maximum and minimum values.
* variables errno::             Values of @code{errno}.
* variables system::            Values of system constants.
@end menu

@c page
@node variables version
@section Version variables


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@defvr {Shell Variable} MMUX_BASH_POINTERS_CURRENT
An integer representing the library interface current number.
@end defvr


@defvr {Shell Variable} MMUX_BASH_POINTERS_REVISION
An integer representing the library interface current revision number.
@end defvr


@defvr {Shell Variable} MMUX_BASH_POINTERS_AGE
An integer representing the library interface current age.
@end defvr

@c page
@node variables sizeof
@section C language type sizes


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined; we can test this condition with @code{test -v}; to test if the
underlying platform implements the type @code{signed long long int}, we can do:

@example
if test -v mmux_sllong_SIZEOF
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarSizeof{STEM}
@defvar mmux_\STEM\_SIZEOF
Global variable holding the size, measured in bytes, of the C language type with stem @code{\STEM\}.
@end defvar

@end macro

@MmuxDefineGlobalVarSizeof{pointer}

@MmuxDefineGlobalVarSizeof{schar}
@MmuxDefineGlobalVarSizeof{uchar}
@MmuxDefineGlobalVarSizeof{sshort}
@MmuxDefineGlobalVarSizeof{ushort}
@MmuxDefineGlobalVarSizeof{sint}
@MmuxDefineGlobalVarSizeof{uint}
@MmuxDefineGlobalVarSizeof{slong}
@MmuxDefineGlobalVarSizeof{ulong}
@MmuxDefineGlobalVarSizeof{sllong}
@MmuxDefineGlobalVarSizeof{ullong}
@MmuxDefineGlobalVarSizeof{float}
@MmuxDefineGlobalVarSizeof{double}
@MmuxDefineGlobalVarSizeof{ldouble}

@MmuxDefineGlobalVarSizeof{float32}
@MmuxDefineGlobalVarSizeof{float64}
@MmuxDefineGlobalVarSizeof{float128}

@MmuxDefineGlobalVarSizeof{float32x}
@MmuxDefineGlobalVarSizeof{float64x}
@MmuxDefineGlobalVarSizeof{float128x}

@MmuxDefineGlobalVarSizeof{decimal32}
@MmuxDefineGlobalVarSizeof{decimal64}
@MmuxDefineGlobalVarSizeof{decimal128}

@MmuxDefineGlobalVarSizeof{complexf}
@MmuxDefineGlobalVarSizeof{complexd}
@MmuxDefineGlobalVarSizeof{complexld}

@MmuxDefineGlobalVarSizeof{complexf32}
@MmuxDefineGlobalVarSizeof{complexf64}
@MmuxDefineGlobalVarSizeof{complexf128}

@MmuxDefineGlobalVarSizeof{complexf32x}
@MmuxDefineGlobalVarSizeof{complexf64x}
@MmuxDefineGlobalVarSizeof{complexf128x}

@MmuxDefineGlobalVarSizeof{complexd32}
@MmuxDefineGlobalVarSizeof{complexd64}
@MmuxDefineGlobalVarSizeof{complexd128}

@MmuxDefineGlobalVarSizeof{sint8}
@MmuxDefineGlobalVarSizeof{uint8}
@MmuxDefineGlobalVarSizeof{sint16}
@MmuxDefineGlobalVarSizeof{uint16}
@MmuxDefineGlobalVarSizeof{sint32}
@MmuxDefineGlobalVarSizeof{uint32}
@MmuxDefineGlobalVarSizeof{sint64}
@MmuxDefineGlobalVarSizeof{uint64}

@MmuxDefineGlobalVarSizeof{ssize}
@MmuxDefineGlobalVarSizeof{usize}
@MmuxDefineGlobalVarSizeof{sintmax}
@MmuxDefineGlobalVarSizeof{uintmax}
@MmuxDefineGlobalVarSizeof{sintptr}
@MmuxDefineGlobalVarSizeof{uintptr}
@MmuxDefineGlobalVarSizeof{ptrdiff}
@MmuxDefineGlobalVarSizeof{mode}
@MmuxDefineGlobalVarSizeof{off}
@MmuxDefineGlobalVarSizeof{pid}
@MmuxDefineGlobalVarSizeof{uid}
@MmuxDefineGlobalVarSizeof{gid}
@MmuxDefineGlobalVarSizeof{wchar}
@MmuxDefineGlobalVarSizeof{wint}

@c page
@node variables limits
@section C language type maximum and minimum values


If a C language type referenced by one of the following variables is undefined: the corresponding
Bash variable is undefined.  Notice that the floating--point complex C language types have neither
maximum nor minimum limits.

Some of the following variables hold the minimum value representable by a C language real number
type; this is true even for floating--point numbers: the value is the minimum negative representable
value.  This is different from the standard C language constants like @code{FLT_MIN},
@code{DBL_MIN}, @code{LDBL_MIN}, which represent some sort of minimum representable positive value.

For the unsigned number types: the minimum value is zero.

@c ------------------------------------------------------------------------

@macro MmuxDefineGlobalVarLimits{STEM,TYPE}
@defvar mmux_\STEM\_MAX
@defvarx mmux_\STEM\_MIN
Global variables holding the maximum and minimum values of the C language type @objtype{mmux_\STEM\_t}.
@end defvar

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineGlobalVarLimits{pointer}

@MmuxDefineGlobalVarLimits{schar}
@MmuxDefineGlobalVarLimits{uchar}
@MmuxDefineGlobalVarLimits{sshort}
@MmuxDefineGlobalVarLimits{ushort}
@MmuxDefineGlobalVarLimits{sint}
@MmuxDefineGlobalVarLimits{uint}
@MmuxDefineGlobalVarLimits{slong}
@MmuxDefineGlobalVarLimits{ulong}
@MmuxDefineGlobalVarLimits{sllong}
@MmuxDefineGlobalVarLimits{ullong}

@MmuxDefineGlobalVarLimits{float}
@MmuxDefineGlobalVarLimits{double}
@MmuxDefineGlobalVarLimits{ldouble}

@MmuxDefineGlobalVarLimits{float32}
@MmuxDefineGlobalVarLimits{float64}
@MmuxDefineGlobalVarLimits{float128}

@MmuxDefineGlobalVarLimits{float32x}
@MmuxDefineGlobalVarLimits{float64x}
@MmuxDefineGlobalVarLimits{float128x}

@MmuxDefineGlobalVarLimits{decimal32}
@MmuxDefineGlobalVarLimits{decimal64}
@MmuxDefineGlobalVarLimits{decimal128}

@MmuxDefineGlobalVarLimits{sint8}
@MmuxDefineGlobalVarLimits{uint8}
@MmuxDefineGlobalVarLimits{sint16}
@MmuxDefineGlobalVarLimits{uint16}
@MmuxDefineGlobalVarLimits{sint32}
@MmuxDefineGlobalVarLimits{uint32}
@MmuxDefineGlobalVarLimits{sint64}
@MmuxDefineGlobalVarLimits{uint64}

@MmuxDefineGlobalVarLimits{ssize}
@MmuxDefineGlobalVarLimits{usize}
@MmuxDefineGlobalVarLimits{sintmax}
@MmuxDefineGlobalVarLimits{uintmax}
@MmuxDefineGlobalVarLimits{sintptr}
@MmuxDefineGlobalVarLimits{uintptr}
@MmuxDefineGlobalVarLimits{ptrdiff}
@MmuxDefineGlobalVarLimits{mode}
@MmuxDefineGlobalVarLimits{off}
@MmuxDefineGlobalVarLimits{pid}
@MmuxDefineGlobalVarLimits{uid}
@MmuxDefineGlobalVarLimits{gid}
@MmuxDefineGlobalVarLimits{wchar}
@MmuxDefineGlobalVarLimits{wint}

@c page
@node variables errno
@section Values of @code{errno}


If a C language constant referenced by one of the following variables is undefined: the
corresponding Bash variable is undefined; we can test this condition with @code{test -v}; to test if
the underlying platform implements the constant @code{ENOMEM}, we can do:

@example
if test -v mmux_libc_ENOMEM
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarErrno{NAME}
@defvar mmux_libc_\NAME\
Global variable holding the value of the C language constant @code{\NAME\}.
@end defvar

@end macro

@MmuxDefineGlobalVarErrno{EPERM}
@MmuxDefineGlobalVarErrno{ENOENT}
@MmuxDefineGlobalVarErrno{ESRCH}
@MmuxDefineGlobalVarErrno{EINTR}
@MmuxDefineGlobalVarErrno{EIO}
@MmuxDefineGlobalVarErrno{ENXIO}
@MmuxDefineGlobalVarErrno{E2BIG}
@MmuxDefineGlobalVarErrno{ENOEXEC}
@MmuxDefineGlobalVarErrno{EBADF}
@MmuxDefineGlobalVarErrno{ECHILD}
@MmuxDefineGlobalVarErrno{EAGAIN}
@MmuxDefineGlobalVarErrno{ENOMEM}
@MmuxDefineGlobalVarErrno{EACCES}
@MmuxDefineGlobalVarErrno{EFAULT}
@MmuxDefineGlobalVarErrno{ENOTBLK}
@MmuxDefineGlobalVarErrno{EBUSY}
@MmuxDefineGlobalVarErrno{EEXIST}
@MmuxDefineGlobalVarErrno{EXDEV}
@MmuxDefineGlobalVarErrno{ENODEV}
@MmuxDefineGlobalVarErrno{ENOTDIR}
@MmuxDefineGlobalVarErrno{EISDIR}
@MmuxDefineGlobalVarErrno{EINVAL}
@MmuxDefineGlobalVarErrno{ENFILE}
@MmuxDefineGlobalVarErrno{EMFILE}
@MmuxDefineGlobalVarErrno{ENOTTY}
@MmuxDefineGlobalVarErrno{ETXTBSY}
@MmuxDefineGlobalVarErrno{EFBIG}
@MmuxDefineGlobalVarErrno{ENOSPC}
@MmuxDefineGlobalVarErrno{ESPIPE}
@MmuxDefineGlobalVarErrno{EROFS}
@MmuxDefineGlobalVarErrno{EMLINK}
@MmuxDefineGlobalVarErrno{EPIPE}
@MmuxDefineGlobalVarErrno{EDOM}
@MmuxDefineGlobalVarErrno{ERANGE}
@MmuxDefineGlobalVarErrno{EDEADLK}
@MmuxDefineGlobalVarErrno{ENAMETOOLONG}
@MmuxDefineGlobalVarErrno{ENOLCK}
@MmuxDefineGlobalVarErrno{ENOSYS}
@MmuxDefineGlobalVarErrno{ENOTEMPTY}
@MmuxDefineGlobalVarErrno{ELOOP}
@MmuxDefineGlobalVarErrno{EWOULDBLOCK}
@MmuxDefineGlobalVarErrno{ENOMSG}
@MmuxDefineGlobalVarErrno{EIDRM}
@MmuxDefineGlobalVarErrno{ECHRNG}
@MmuxDefineGlobalVarErrno{EL2NSYNC}
@MmuxDefineGlobalVarErrno{EL3HLT}
@MmuxDefineGlobalVarErrno{EL3RST}
@MmuxDefineGlobalVarErrno{ELNRNG}
@MmuxDefineGlobalVarErrno{EUNATCH}
@MmuxDefineGlobalVarErrno{ENOCSI}
@MmuxDefineGlobalVarErrno{EL2HLT}
@MmuxDefineGlobalVarErrno{EBADE}
@MmuxDefineGlobalVarErrno{EBADR}
@MmuxDefineGlobalVarErrno{EXFULL}
@MmuxDefineGlobalVarErrno{ENOANO}
@MmuxDefineGlobalVarErrno{EBADRQC}
@MmuxDefineGlobalVarErrno{EBADSLT}
@MmuxDefineGlobalVarErrno{EDEADLOCK}
@MmuxDefineGlobalVarErrno{EBFONT}
@MmuxDefineGlobalVarErrno{ENOSTR}
@MmuxDefineGlobalVarErrno{ENODATA}
@MmuxDefineGlobalVarErrno{ETIME}
@MmuxDefineGlobalVarErrno{ENOSR}
@MmuxDefineGlobalVarErrno{ENONET}
@MmuxDefineGlobalVarErrno{ENOPKG}
@MmuxDefineGlobalVarErrno{EREMOTE}
@MmuxDefineGlobalVarErrno{ENOLINK}
@MmuxDefineGlobalVarErrno{EADV}
@MmuxDefineGlobalVarErrno{ESRMNT}
@MmuxDefineGlobalVarErrno{ECOMM}
@MmuxDefineGlobalVarErrno{EPROTO}
@MmuxDefineGlobalVarErrno{EMULTIHOP}
@MmuxDefineGlobalVarErrno{EDOTDOT}
@MmuxDefineGlobalVarErrno{EBADMSG}
@MmuxDefineGlobalVarErrno{EOVERFLOW}
@MmuxDefineGlobalVarErrno{ENOTUNIQ}
@MmuxDefineGlobalVarErrno{EBADFD}
@MmuxDefineGlobalVarErrno{EREMCHG}
@MmuxDefineGlobalVarErrno{ELIBACC}
@MmuxDefineGlobalVarErrno{ELIBBAD}
@MmuxDefineGlobalVarErrno{ELIBSCN}
@MmuxDefineGlobalVarErrno{ELIBMAX}
@MmuxDefineGlobalVarErrno{ELIBEXEC}
@MmuxDefineGlobalVarErrno{EILSEQ}
@MmuxDefineGlobalVarErrno{ERESTART}
@MmuxDefineGlobalVarErrno{ESTRPIPE}
@MmuxDefineGlobalVarErrno{EUSERS}
@MmuxDefineGlobalVarErrno{ENOTSOCK}
@MmuxDefineGlobalVarErrno{EDESTADDRREQ}
@MmuxDefineGlobalVarErrno{EMSGSIZE}
@MmuxDefineGlobalVarErrno{EPROTOTYPE}
@MmuxDefineGlobalVarErrno{ENOPROTOOPT}
@MmuxDefineGlobalVarErrno{EPROTONOSUPPORT}
@MmuxDefineGlobalVarErrno{ESOCKTNOSUPPORT}
@MmuxDefineGlobalVarErrno{EOPNOTSUPP}
@MmuxDefineGlobalVarErrno{EPFNOSUPPORT}
@MmuxDefineGlobalVarErrno{EAFNOSUPPORT}
@MmuxDefineGlobalVarErrno{EADDRINUSE}
@MmuxDefineGlobalVarErrno{EADDRNOTAVAIL}
@MmuxDefineGlobalVarErrno{ENETDOWN}
@MmuxDefineGlobalVarErrno{ENETUNREACH}
@MmuxDefineGlobalVarErrno{ENETRESET}
@MmuxDefineGlobalVarErrno{ECONNABORTED}
@MmuxDefineGlobalVarErrno{ECONNRESET}
@MmuxDefineGlobalVarErrno{ENOBUFS}
@MmuxDefineGlobalVarErrno{EISCONN}
@MmuxDefineGlobalVarErrno{ENOTCONN}
@MmuxDefineGlobalVarErrno{ESHUTDOWN}
@MmuxDefineGlobalVarErrno{ETOOMANYREFS}
@MmuxDefineGlobalVarErrno{ETIMEDOUT}
@MmuxDefineGlobalVarErrno{ECONNREFUSED}
@MmuxDefineGlobalVarErrno{EHOSTDOWN}
@MmuxDefineGlobalVarErrno{EHOSTUNREACH}
@MmuxDefineGlobalVarErrno{EALREADY}
@MmuxDefineGlobalVarErrno{EINPROGRESS}
@MmuxDefineGlobalVarErrno{ESTALE}
@MmuxDefineGlobalVarErrno{EUCLEAN}
@MmuxDefineGlobalVarErrno{ENOTNAM}
@MmuxDefineGlobalVarErrno{ENAVAIL}
@MmuxDefineGlobalVarErrno{EISNAM}
@MmuxDefineGlobalVarErrno{EREMOTEIO}
@MmuxDefineGlobalVarErrno{EDQUOT}
@MmuxDefineGlobalVarErrno{ENOMEDIUM}
@MmuxDefineGlobalVarErrno{EMEDIUMTYPE}
@MmuxDefineGlobalVarErrno{ECANCELED}
@MmuxDefineGlobalVarErrno{ENOKEY}
@MmuxDefineGlobalVarErrno{EKEYEXPIRED}
@MmuxDefineGlobalVarErrno{EKEYREVOKED}
@MmuxDefineGlobalVarErrno{EKEYREJECTED}
@MmuxDefineGlobalVarErrno{EOWNERDEAD}
@MmuxDefineGlobalVarErrno{ENOTRECOVERABLE}

@c page
@node variables system
@section Values of system constants


If a C language constant referenced by one of the following variables is undefined: the
corresponding Bash variable is undefined; we can test this condition with @code{test -v}; to test if
the underlying platform implements the constant @code{O_EXEC}, we can do:

@example
if test -v mmux_libc_O_EXEC
then # implemented
else # not implemented
fi
@end example

@macro MmuxDefineGlobalVarSystemConstant{NAME}
@defvar mmux_libc_\NAME\
Global variable holding the value of the C language constant @code{\NAME\}.
@end defvar

@end macro

@MmuxDefineGlobalVarSystemConstant{EOF}
@MmuxDefineGlobalVarSystemConstant{F_DUPFD}
@MmuxDefineGlobalVarSystemConstant{F_GETFD}
@MmuxDefineGlobalVarSystemConstant{F_GETFL}
@MmuxDefineGlobalVarSystemConstant{F_GETLK}
@MmuxDefineGlobalVarSystemConstant{F_GETOWN}
@MmuxDefineGlobalVarSystemConstant{F_OK}
@MmuxDefineGlobalVarSystemConstant{F_RDLCK}
@MmuxDefineGlobalVarSystemConstant{F_SETFD}
@MmuxDefineGlobalVarSystemConstant{F_SETFL}
@MmuxDefineGlobalVarSystemConstant{F_SETLK}
@MmuxDefineGlobalVarSystemConstant{F_SETLKW}
@MmuxDefineGlobalVarSystemConstant{F_SETOWN}
@MmuxDefineGlobalVarSystemConstant{F_UNLCK}
@MmuxDefineGlobalVarSystemConstant{F_WRLCK}
@MmuxDefineGlobalVarSystemConstant{O_ACCMODE}
@MmuxDefineGlobalVarSystemConstant{O_APPEND}
@MmuxDefineGlobalVarSystemConstant{O_ASYNC}
@MmuxDefineGlobalVarSystemConstant{O_CLOEXEC}
@MmuxDefineGlobalVarSystemConstant{O_CREAT}
@MmuxDefineGlobalVarSystemConstant{O_DIRECT}
@MmuxDefineGlobalVarSystemConstant{O_DIRECTORY}
@MmuxDefineGlobalVarSystemConstant{O_EXCL}
@MmuxDefineGlobalVarSystemConstant{O_EXEC}
@MmuxDefineGlobalVarSystemConstant{O_EXLOCK}
@MmuxDefineGlobalVarSystemConstant{O_FSYNC}
@MmuxDefineGlobalVarSystemConstant{O_IGNORE_CTTY}
@MmuxDefineGlobalVarSystemConstant{O_LARGEFILE}
@MmuxDefineGlobalVarSystemConstant{O_NDELAY}
@MmuxDefineGlobalVarSystemConstant{O_NOATIME}
@MmuxDefineGlobalVarSystemConstant{O_NOCTTY}
@MmuxDefineGlobalVarSystemConstant{O_NOFOLLOW}
@MmuxDefineGlobalVarSystemConstant{O_NOLINK}
@MmuxDefineGlobalVarSystemConstant{O_NONBLOCK}
@MmuxDefineGlobalVarSystemConstant{O_NOTRANS}
@MmuxDefineGlobalVarSystemConstant{O_RDONLY}
@MmuxDefineGlobalVarSystemConstant{O_RDWR}
@MmuxDefineGlobalVarSystemConstant{O_READ}
@MmuxDefineGlobalVarSystemConstant{O_SHLOCK}
@MmuxDefineGlobalVarSystemConstant{O_SYNC}
@MmuxDefineGlobalVarSystemConstant{O_TRUNC}
@MmuxDefineGlobalVarSystemConstant{O_WRITE}
@MmuxDefineGlobalVarSystemConstant{O_WRONLY}
@MmuxDefineGlobalVarSystemConstant{R_OK}
@MmuxDefineGlobalVarSystemConstant{SEEK_CUR}
@MmuxDefineGlobalVarSystemConstant{SEEK_DATA}
@MmuxDefineGlobalVarSystemConstant{SEEK_END}
@MmuxDefineGlobalVarSystemConstant{SEEK_HOLE}
@MmuxDefineGlobalVarSystemConstant{SEEK_SET}
@MmuxDefineGlobalVarSystemConstant{S_IRGRP}
@MmuxDefineGlobalVarSystemConstant{S_IROTH}
@MmuxDefineGlobalVarSystemConstant{S_IRUSR}
@MmuxDefineGlobalVarSystemConstant{S_IRWXG}
@MmuxDefineGlobalVarSystemConstant{S_IRWXO}
@MmuxDefineGlobalVarSystemConstant{S_IRWXU}
@MmuxDefineGlobalVarSystemConstant{S_ISGID}
@MmuxDefineGlobalVarSystemConstant{S_ISUID}
@MmuxDefineGlobalVarSystemConstant{S_ISVTX}
@MmuxDefineGlobalVarSystemConstant{S_IWGRP}
@MmuxDefineGlobalVarSystemConstant{S_IWOTH}
@MmuxDefineGlobalVarSystemConstant{S_IWUSR}
@MmuxDefineGlobalVarSystemConstant{S_IXGRP}
@MmuxDefineGlobalVarSystemConstant{S_IXOTH}
@MmuxDefineGlobalVarSystemConstant{S_IXUSR}
@MmuxDefineGlobalVarSystemConstant{W_OK}
@MmuxDefineGlobalVarSystemConstant{X_OK}

@c page
@node types
@chapter Interface to supported data types


@menu
* types predicates::            Type predicates.
* types comparison::            Comparison builtins.
* types arithmetics::           Arithmetics operation builtins.
* types complex::               Basic complex number builtins.
* types bitwise::               Bitwise operation builtins.
* types formats::               Input and output formats.
@end menu

@c page
@node types predicates
@section Type predicates


@menu
* types predicates stringrep::        String representation predicates.
* types predicates zero::             Zero number predicates.
* types predicates positive::         Positive number predicates.
* types predicates negative::         Negative number predicates.
* types predicates non-positive::     Non-positive number predicates.
* types predicates non-negative::     Non-negative number predicates.
* types predicates nan::              Not-a-number predicates.
* types predicates infinite::         Infinite number predicates.
@end menu

@c page
@node types predicates stringrep
@subsection String representation predicates


@macro MmuxDefineTypePredicateStringrepBuiltin{STEM}
@deffn Builtin mmux_string_is_\STEM\ @var{STRING_REP}
Return true if @var{STRING_REP} is a valid string representation for the C language type; otherwise
return false.
@end deffn

@end macro

@MmuxDefineTypePredicateStringrepBuiltin{pointer}

@MmuxDefineTypePredicateStringrepBuiltin{schar}
@MmuxDefineTypePredicateStringrepBuiltin{uchar}
@MmuxDefineTypePredicateStringrepBuiltin{sshort}
@MmuxDefineTypePredicateStringrepBuiltin{ushort}
@MmuxDefineTypePredicateStringrepBuiltin{sint}
@MmuxDefineTypePredicateStringrepBuiltin{uint}
@MmuxDefineTypePredicateStringrepBuiltin{slong}
@MmuxDefineTypePredicateStringrepBuiltin{ulong}
@MmuxDefineTypePredicateStringrepBuiltin{sllong}
@MmuxDefineTypePredicateStringrepBuiltin{ullong}
@MmuxDefineTypePredicateStringrepBuiltin{float}
@MmuxDefineTypePredicateStringrepBuiltin{double}
@MmuxDefineTypePredicateStringrepBuiltin{ldouble}

@MmuxDefineTypePredicateStringrepBuiltin{float32}
@MmuxDefineTypePredicateStringrepBuiltin{float64}
@MmuxDefineTypePredicateStringrepBuiltin{float128}

@MmuxDefineTypePredicateStringrepBuiltin{float32x}
@MmuxDefineTypePredicateStringrepBuiltin{float64x}
@MmuxDefineTypePredicateStringrepBuiltin{float128x}

@MmuxDefineTypePredicateStringrepBuiltin{decimal32}
@MmuxDefineTypePredicateStringrepBuiltin{decimal64}
@MmuxDefineTypePredicateStringrepBuiltin{decimal128}

@MmuxDefineTypePredicateStringrepBuiltin{complexf}
@MmuxDefineTypePredicateStringrepBuiltin{complexd}
@MmuxDefineTypePredicateStringrepBuiltin{complexld}

@MmuxDefineTypePredicateStringrepBuiltin{complexf32}
@MmuxDefineTypePredicateStringrepBuiltin{complexf64}
@MmuxDefineTypePredicateStringrepBuiltin{complexf128}

@MmuxDefineTypePredicateStringrepBuiltin{complexf32x}
@MmuxDefineTypePredicateStringrepBuiltin{complexf64x}
@MmuxDefineTypePredicateStringrepBuiltin{complexf128x}

@MmuxDefineTypePredicateStringrepBuiltin{complexd32}
@MmuxDefineTypePredicateStringrepBuiltin{complexd64}
@MmuxDefineTypePredicateStringrepBuiltin{complexd128}

@MmuxDefineTypePredicateStringrepBuiltin{sint8}
@MmuxDefineTypePredicateStringrepBuiltin{uint8}
@MmuxDefineTypePredicateStringrepBuiltin{sint16}
@MmuxDefineTypePredicateStringrepBuiltin{uint16}
@MmuxDefineTypePredicateStringrepBuiltin{sint32}
@MmuxDefineTypePredicateStringrepBuiltin{uint32}
@MmuxDefineTypePredicateStringrepBuiltin{sint64}
@MmuxDefineTypePredicateStringrepBuiltin{uint64}

@MmuxDefineTypePredicateStringrepBuiltin{ssize}
@MmuxDefineTypePredicateStringrepBuiltin{usize}
@MmuxDefineTypePredicateStringrepBuiltin{sintmax}
@MmuxDefineTypePredicateStringrepBuiltin{uintmax}
@MmuxDefineTypePredicateStringrepBuiltin{sintptr}
@MmuxDefineTypePredicateStringrepBuiltin{uintptr}
@MmuxDefineTypePredicateStringrepBuiltin{mode}
@MmuxDefineTypePredicateStringrepBuiltin{off}
@MmuxDefineTypePredicateStringrepBuiltin{pid}
@MmuxDefineTypePredicateStringrepBuiltin{uid}
@MmuxDefineTypePredicateStringrepBuiltin{gid}
@MmuxDefineTypePredicateStringrepBuiltin{wchar}
@MmuxDefineTypePredicateStringrepBuiltin{wint}

@c page
@node types predicates zero
@subsection Zero number predicates


@macro MmuxDefineTypePredicateZeroBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_zero @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
zero number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateZeroBuiltin{pointer}

@MmuxDefineTypePredicateZeroBuiltin{schar}
@MmuxDefineTypePredicateZeroBuiltin{uchar}
@MmuxDefineTypePredicateZeroBuiltin{sshort}
@MmuxDefineTypePredicateZeroBuiltin{ushort}
@MmuxDefineTypePredicateZeroBuiltin{sint}
@MmuxDefineTypePredicateZeroBuiltin{uint}
@MmuxDefineTypePredicateZeroBuiltin{slong}
@MmuxDefineTypePredicateZeroBuiltin{ulong}
@MmuxDefineTypePredicateZeroBuiltin{sllong}
@MmuxDefineTypePredicateZeroBuiltin{ullong}
@MmuxDefineTypePredicateZeroBuiltin{float}
@MmuxDefineTypePredicateZeroBuiltin{double}
@MmuxDefineTypePredicateZeroBuiltin{ldouble}

@MmuxDefineTypePredicateZeroBuiltin{float32}
@MmuxDefineTypePredicateZeroBuiltin{float64}
@MmuxDefineTypePredicateZeroBuiltin{float128}

@MmuxDefineTypePredicateZeroBuiltin{float32x}
@MmuxDefineTypePredicateZeroBuiltin{float64x}
@MmuxDefineTypePredicateZeroBuiltin{float128x}

@MmuxDefineTypePredicateZeroBuiltin{decimal32}
@MmuxDefineTypePredicateZeroBuiltin{decimal64}
@MmuxDefineTypePredicateZeroBuiltin{decimal128}

@MmuxDefineTypePredicateZeroBuiltin{complexf}
@MmuxDefineTypePredicateZeroBuiltin{complexd}
@MmuxDefineTypePredicateZeroBuiltin{complexld}

@MmuxDefineTypePredicateZeroBuiltin{complexf32}
@MmuxDefineTypePredicateZeroBuiltin{complexf64}
@MmuxDefineTypePredicateZeroBuiltin{complexf128}

@MmuxDefineTypePredicateZeroBuiltin{complexf32x}
@MmuxDefineTypePredicateZeroBuiltin{complexf64x}
@MmuxDefineTypePredicateZeroBuiltin{complexf128x}

@MmuxDefineTypePredicateZeroBuiltin{complexd32}
@MmuxDefineTypePredicateZeroBuiltin{complexd64}
@MmuxDefineTypePredicateZeroBuiltin{complexd128}

@MmuxDefineTypePredicateZeroBuiltin{sint8}
@MmuxDefineTypePredicateZeroBuiltin{uint8}
@MmuxDefineTypePredicateZeroBuiltin{sint16}
@MmuxDefineTypePredicateZeroBuiltin{uint16}
@MmuxDefineTypePredicateZeroBuiltin{sint32}
@MmuxDefineTypePredicateZeroBuiltin{uint32}
@MmuxDefineTypePredicateZeroBuiltin{sint64}
@MmuxDefineTypePredicateZeroBuiltin{uint64}

@MmuxDefineTypePredicateZeroBuiltin{ssize}
@MmuxDefineTypePredicateZeroBuiltin{usize}
@MmuxDefineTypePredicateZeroBuiltin{sintmax}
@MmuxDefineTypePredicateZeroBuiltin{uintmax}
@MmuxDefineTypePredicateZeroBuiltin{sintptr}
@MmuxDefineTypePredicateZeroBuiltin{uintptr}
@MmuxDefineTypePredicateZeroBuiltin{mode}
@MmuxDefineTypePredicateZeroBuiltin{off}
@MmuxDefineTypePredicateZeroBuiltin{pid}
@MmuxDefineTypePredicateZeroBuiltin{uid}
@MmuxDefineTypePredicateZeroBuiltin{gid}
@MmuxDefineTypePredicateZeroBuiltin{wchar}
@MmuxDefineTypePredicateZeroBuiltin{wint}

@c page
@node types predicates positive
@subsection Positive number predicates


@macro MmuxDefineTypePredicatePositiveBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_positive @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
positive number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicatePositiveBuiltin{pointer}

@MmuxDefineTypePredicatePositiveBuiltin{schar}
@MmuxDefineTypePredicatePositiveBuiltin{uchar}
@MmuxDefineTypePredicatePositiveBuiltin{sshort}
@MmuxDefineTypePredicatePositiveBuiltin{ushort}
@MmuxDefineTypePredicatePositiveBuiltin{sint}
@MmuxDefineTypePredicatePositiveBuiltin{uint}
@MmuxDefineTypePredicatePositiveBuiltin{slong}
@MmuxDefineTypePredicatePositiveBuiltin{ulong}
@MmuxDefineTypePredicatePositiveBuiltin{sllong}
@MmuxDefineTypePredicatePositiveBuiltin{ullong}

@MmuxDefineTypePredicatePositiveBuiltin{float}
@MmuxDefineTypePredicatePositiveBuiltin{double}
@MmuxDefineTypePredicatePositiveBuiltin{ldouble}

@MmuxDefineTypePredicatePositiveBuiltin{float32}
@MmuxDefineTypePredicatePositiveBuiltin{float64}
@MmuxDefineTypePredicatePositiveBuiltin{float128}

@MmuxDefineTypePredicatePositiveBuiltin{float32x}
@MmuxDefineTypePredicatePositiveBuiltin{float64x}
@MmuxDefineTypePredicatePositiveBuiltin{float128x}

@MmuxDefineTypePredicatePositiveBuiltin{decimal32}
@MmuxDefineTypePredicatePositiveBuiltin{decimal64}
@MmuxDefineTypePredicatePositiveBuiltin{decimal128}

@MmuxDefineTypePredicatePositiveBuiltin{sint8}
@MmuxDefineTypePredicatePositiveBuiltin{uint8}
@MmuxDefineTypePredicatePositiveBuiltin{sint16}
@MmuxDefineTypePredicatePositiveBuiltin{uint16}
@MmuxDefineTypePredicatePositiveBuiltin{sint32}
@MmuxDefineTypePredicatePositiveBuiltin{uint32}
@MmuxDefineTypePredicatePositiveBuiltin{sint64}
@MmuxDefineTypePredicatePositiveBuiltin{uint64}

@MmuxDefineTypePredicatePositiveBuiltin{ssize}
@MmuxDefineTypePredicatePositiveBuiltin{usize}
@MmuxDefineTypePredicatePositiveBuiltin{sintmax}
@MmuxDefineTypePredicatePositiveBuiltin{uintmax}
@MmuxDefineTypePredicatePositiveBuiltin{sintptr}
@MmuxDefineTypePredicatePositiveBuiltin{uintptr}
@MmuxDefineTypePredicatePositiveBuiltin{mode}
@MmuxDefineTypePredicatePositiveBuiltin{off}
@MmuxDefineTypePredicatePositiveBuiltin{pid}
@MmuxDefineTypePredicatePositiveBuiltin{uid}
@MmuxDefineTypePredicatePositiveBuiltin{gid}
@MmuxDefineTypePredicatePositiveBuiltin{wchar}
@MmuxDefineTypePredicatePositiveBuiltin{wint}

@c page
@node types predicates negative
@subsection Negative number predicates


@macro MmuxDefineTypePredicateNegativeBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_negative @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
negative number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNegativeBuiltin{pointer}

@MmuxDefineTypePredicateNegativeBuiltin{schar}
@MmuxDefineTypePredicateNegativeBuiltin{uchar}
@MmuxDefineTypePredicateNegativeBuiltin{sshort}
@MmuxDefineTypePredicateNegativeBuiltin{ushort}
@MmuxDefineTypePredicateNegativeBuiltin{sint}
@MmuxDefineTypePredicateNegativeBuiltin{uint}
@MmuxDefineTypePredicateNegativeBuiltin{slong}
@MmuxDefineTypePredicateNegativeBuiltin{ulong}
@MmuxDefineTypePredicateNegativeBuiltin{sllong}
@MmuxDefineTypePredicateNegativeBuiltin{ullong}

@MmuxDefineTypePredicateNegativeBuiltin{float}
@MmuxDefineTypePredicateNegativeBuiltin{double}
@MmuxDefineTypePredicateNegativeBuiltin{ldouble}

@MmuxDefineTypePredicateNegativeBuiltin{float32}
@MmuxDefineTypePredicateNegativeBuiltin{float64}
@MmuxDefineTypePredicateNegativeBuiltin{float128}

@MmuxDefineTypePredicateNegativeBuiltin{float32x}
@MmuxDefineTypePredicateNegativeBuiltin{float64x}
@MmuxDefineTypePredicateNegativeBuiltin{float128x}

@MmuxDefineTypePredicateNegativeBuiltin{float32}
@MmuxDefineTypePredicateNegativeBuiltin{float64}
@MmuxDefineTypePredicateNegativeBuiltin{float128}

@MmuxDefineTypePredicateNegativeBuiltin{float32x}
@MmuxDefineTypePredicateNegativeBuiltin{float64x}
@MmuxDefineTypePredicateNegativeBuiltin{float128x}

@MmuxDefineTypePredicateNegativeBuiltin{decimal32}
@MmuxDefineTypePredicateNegativeBuiltin{decimal64}
@MmuxDefineTypePredicateNegativeBuiltin{decimal128}

@MmuxDefineTypePredicateNegativeBuiltin{sint8}
@MmuxDefineTypePredicateNegativeBuiltin{uint8}
@MmuxDefineTypePredicateNegativeBuiltin{sint16}
@MmuxDefineTypePredicateNegativeBuiltin{uint16}
@MmuxDefineTypePredicateNegativeBuiltin{sint32}
@MmuxDefineTypePredicateNegativeBuiltin{uint32}
@MmuxDefineTypePredicateNegativeBuiltin{sint64}
@MmuxDefineTypePredicateNegativeBuiltin{uint64}

@MmuxDefineTypePredicateNegativeBuiltin{ssize}
@MmuxDefineTypePredicateNegativeBuiltin{usize}
@MmuxDefineTypePredicateNegativeBuiltin{sintmax}
@MmuxDefineTypePredicateNegativeBuiltin{uintmax}
@MmuxDefineTypePredicateNegativeBuiltin{sintptr}
@MmuxDefineTypePredicateNegativeBuiltin{uintptr}
@MmuxDefineTypePredicateNegativeBuiltin{mode}
@MmuxDefineTypePredicateNegativeBuiltin{off}
@MmuxDefineTypePredicateNegativeBuiltin{pid}
@MmuxDefineTypePredicateNegativeBuiltin{uid}
@MmuxDefineTypePredicateNegativeBuiltin{gid}
@MmuxDefineTypePredicateNegativeBuiltin{wchar}
@MmuxDefineTypePredicateNegativeBuiltin{wint}

@c page
@node types predicates non-positive
@subsection Non--positive number predicates


@macro MmuxDefineTypePredicateNonPositiveBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_non_positive @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
non--positive number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNonPositiveBuiltin{pointer}

@MmuxDefineTypePredicateNonPositiveBuiltin{schar}
@MmuxDefineTypePredicateNonPositiveBuiltin{uchar}
@MmuxDefineTypePredicateNonPositiveBuiltin{sshort}
@MmuxDefineTypePredicateNonPositiveBuiltin{ushort}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint}
@MmuxDefineTypePredicateNonPositiveBuiltin{slong}
@MmuxDefineTypePredicateNonPositiveBuiltin{ulong}
@MmuxDefineTypePredicateNonPositiveBuiltin{sllong}
@MmuxDefineTypePredicateNonPositiveBuiltin{ullong}
@MmuxDefineTypePredicateNonPositiveBuiltin{float}
@MmuxDefineTypePredicateNonPositiveBuiltin{double}
@MmuxDefineTypePredicateNonPositiveBuiltin{ldouble}

@MmuxDefineTypePredicateNonPositiveBuiltin{float32}
@MmuxDefineTypePredicateNonPositiveBuiltin{float64}
@MmuxDefineTypePredicateNonPositiveBuiltin{float128}

@MmuxDefineTypePredicateNonPositiveBuiltin{float32x}
@MmuxDefineTypePredicateNonPositiveBuiltin{float64x}
@MmuxDefineTypePredicateNonPositiveBuiltin{float128x}

@MmuxDefineTypePredicateNonPositiveBuiltin{decimal32}
@MmuxDefineTypePredicateNonPositiveBuiltin{decimal64}
@MmuxDefineTypePredicateNonPositiveBuiltin{decimal128}

@MmuxDefineTypePredicateNonPositiveBuiltin{sint8}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint8}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint16}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint16}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint32}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint32}
@MmuxDefineTypePredicateNonPositiveBuiltin{sint64}
@MmuxDefineTypePredicateNonPositiveBuiltin{uint64}

@MmuxDefineTypePredicateNonPositiveBuiltin{ssize}
@MmuxDefineTypePredicateNonPositiveBuiltin{usize}
@MmuxDefineTypePredicateNonPositiveBuiltin{sintmax}
@MmuxDefineTypePredicateNonPositiveBuiltin{uintmax}
@MmuxDefineTypePredicateNonPositiveBuiltin{sintptr}
@MmuxDefineTypePredicateNonPositiveBuiltin{uintptr}
@MmuxDefineTypePredicateNonPositiveBuiltin{mode}
@MmuxDefineTypePredicateNonPositiveBuiltin{off}
@MmuxDefineTypePredicateNonPositiveBuiltin{pid}
@MmuxDefineTypePredicateNonPositiveBuiltin{uid}
@MmuxDefineTypePredicateNonPositiveBuiltin{gid}
@MmuxDefineTypePredicateNonPositiveBuiltin{wchar}
@MmuxDefineTypePredicateNonPositiveBuiltin{wint}

@c page
@node types predicates non-negative
@subsection Non--negative number predicates


@macro MmuxDefineTypePredicateNonNegativeBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_non_negative @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
non--negative number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNonNegativeBuiltin{pointer}

@MmuxDefineTypePredicateNonNegativeBuiltin{schar}
@MmuxDefineTypePredicateNonNegativeBuiltin{uchar}
@MmuxDefineTypePredicateNonNegativeBuiltin{sshort}
@MmuxDefineTypePredicateNonNegativeBuiltin{ushort}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint}
@MmuxDefineTypePredicateNonNegativeBuiltin{slong}
@MmuxDefineTypePredicateNonNegativeBuiltin{ulong}
@MmuxDefineTypePredicateNonNegativeBuiltin{sllong}
@MmuxDefineTypePredicateNonNegativeBuiltin{ullong}
@MmuxDefineTypePredicateNonNegativeBuiltin{float}
@MmuxDefineTypePredicateNonNegativeBuiltin{double}
@MmuxDefineTypePredicateNonNegativeBuiltin{ldouble}

@MmuxDefineTypePredicateNonNegativeBuiltin{float32}
@MmuxDefineTypePredicateNonNegativeBuiltin{float64}
@MmuxDefineTypePredicateNonNegativeBuiltin{float128}

@MmuxDefineTypePredicateNonNegativeBuiltin{float32x}
@MmuxDefineTypePredicateNonNegativeBuiltin{float64x}
@MmuxDefineTypePredicateNonNegativeBuiltin{float128x}

@MmuxDefineTypePredicateNonNegativeBuiltin{decimal32}
@MmuxDefineTypePredicateNonNegativeBuiltin{decimal64}
@MmuxDefineTypePredicateNonNegativeBuiltin{decimal128}

@MmuxDefineTypePredicateNonNegativeBuiltin{sint8}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint8}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint16}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint16}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint32}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint32}
@MmuxDefineTypePredicateNonNegativeBuiltin{sint64}
@MmuxDefineTypePredicateNonNegativeBuiltin{uint64}

@MmuxDefineTypePredicateNonNegativeBuiltin{ssize}
@MmuxDefineTypePredicateNonNegativeBuiltin{usize}
@MmuxDefineTypePredicateNonNegativeBuiltin{sintmax}
@MmuxDefineTypePredicateNonNegativeBuiltin{uintmax}
@MmuxDefineTypePredicateNonNegativeBuiltin{sintptr}
@MmuxDefineTypePredicateNonNegativeBuiltin{uintptr}
@MmuxDefineTypePredicateNonNegativeBuiltin{mode}
@MmuxDefineTypePredicateNonNegativeBuiltin{off}
@MmuxDefineTypePredicateNonNegativeBuiltin{pid}
@MmuxDefineTypePredicateNonNegativeBuiltin{uid}
@MmuxDefineTypePredicateNonNegativeBuiltin{gid}
@MmuxDefineTypePredicateNonNegativeBuiltin{wchar}
@MmuxDefineTypePredicateNonNegativeBuiltin{wint}

@c page
@node types predicates nan
@subsection Not--a--number predicates


@macro MmuxDefineTypePredicateNanBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_nan @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents a
not--a--number value; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateNanBuiltin{pointer}

@MmuxDefineTypePredicateNanBuiltin{schar}
@MmuxDefineTypePredicateNanBuiltin{uchar}
@MmuxDefineTypePredicateNanBuiltin{sshort}
@MmuxDefineTypePredicateNanBuiltin{ushort}
@MmuxDefineTypePredicateNanBuiltin{sint}
@MmuxDefineTypePredicateNanBuiltin{uint}
@MmuxDefineTypePredicateNanBuiltin{slong}
@MmuxDefineTypePredicateNanBuiltin{ulong}
@MmuxDefineTypePredicateNanBuiltin{sllong}
@MmuxDefineTypePredicateNanBuiltin{ullong}
@MmuxDefineTypePredicateNanBuiltin{float}
@MmuxDefineTypePredicateNanBuiltin{double}
@MmuxDefineTypePredicateNanBuiltin{ldouble}

@MmuxDefineTypePredicateNanBuiltin{float32}
@MmuxDefineTypePredicateNanBuiltin{float64}
@MmuxDefineTypePredicateNanBuiltin{float128}

@MmuxDefineTypePredicateNanBuiltin{float32x}
@MmuxDefineTypePredicateNanBuiltin{float64x}
@MmuxDefineTypePredicateNanBuiltin{float128x}

@MmuxDefineTypePredicateNanBuiltin{decimal32}
@MmuxDefineTypePredicateNanBuiltin{decimal64}
@MmuxDefineTypePredicateNanBuiltin{decimal128}

@MmuxDefineTypePredicateNanBuiltin{complexf}
@MmuxDefineTypePredicateNanBuiltin{complexd}
@MmuxDefineTypePredicateNanBuiltin{complexld}

@MmuxDefineTypePredicateNanBuiltin{complexf32}
@MmuxDefineTypePredicateNanBuiltin{complexf64}
@MmuxDefineTypePredicateNanBuiltin{complexf128}

@MmuxDefineTypePredicateNanBuiltin{complexf32x}
@MmuxDefineTypePredicateNanBuiltin{complexf64x}
@MmuxDefineTypePredicateNanBuiltin{complexf128x}

@MmuxDefineTypePredicateNanBuiltin{complexd32}
@MmuxDefineTypePredicateNanBuiltin{complexd64}
@MmuxDefineTypePredicateNanBuiltin{complexd128}

@MmuxDefineTypePredicateNanBuiltin{sint8}
@MmuxDefineTypePredicateNanBuiltin{uint8}
@MmuxDefineTypePredicateNanBuiltin{sint16}
@MmuxDefineTypePredicateNanBuiltin{uint16}
@MmuxDefineTypePredicateNanBuiltin{sint32}
@MmuxDefineTypePredicateNanBuiltin{uint32}
@MmuxDefineTypePredicateNanBuiltin{sint64}
@MmuxDefineTypePredicateNanBuiltin{uint64}

@MmuxDefineTypePredicateNanBuiltin{ssize}
@MmuxDefineTypePredicateNanBuiltin{usize}
@MmuxDefineTypePredicateNanBuiltin{sintmax}
@MmuxDefineTypePredicateNanBuiltin{uintmax}
@MmuxDefineTypePredicateNanBuiltin{sintptr}
@MmuxDefineTypePredicateNanBuiltin{uintptr}
@MmuxDefineTypePredicateNanBuiltin{mode}
@MmuxDefineTypePredicateNanBuiltin{off}
@MmuxDefineTypePredicateNanBuiltin{pid}
@MmuxDefineTypePredicateNanBuiltin{uid}
@MmuxDefineTypePredicateNanBuiltin{gid}
@MmuxDefineTypePredicateNanBuiltin{wchar}
@MmuxDefineTypePredicateNanBuiltin{wint}

@c page
@node types predicates infinite
@subsection Infinite number predicates


@macro MmuxDefineTypePredicateInfiniteBuiltin{STEM}
@deffn Builtin mmux_\STEM\_is_infinite @var{OP}
Return true if @var{OP} is a valid string representation for the C language type and it represents
an infinite number; otherwise return false.
@end deffn

@end macro

@MmuxDefineTypePredicateInfiniteBuiltin{pointer}

@MmuxDefineTypePredicateInfiniteBuiltin{schar}
@MmuxDefineTypePredicateInfiniteBuiltin{uchar}
@MmuxDefineTypePredicateInfiniteBuiltin{sshort}
@MmuxDefineTypePredicateInfiniteBuiltin{ushort}
@MmuxDefineTypePredicateInfiniteBuiltin{sint}
@MmuxDefineTypePredicateInfiniteBuiltin{uint}
@MmuxDefineTypePredicateInfiniteBuiltin{slong}
@MmuxDefineTypePredicateInfiniteBuiltin{ulong}
@MmuxDefineTypePredicateInfiniteBuiltin{sllong}
@MmuxDefineTypePredicateInfiniteBuiltin{ullong}
@MmuxDefineTypePredicateInfiniteBuiltin{float}
@MmuxDefineTypePredicateInfiniteBuiltin{double}
@MmuxDefineTypePredicateInfiniteBuiltin{ldouble}

@MmuxDefineTypePredicateInfiniteBuiltin{float32}
@MmuxDefineTypePredicateInfiniteBuiltin{float64}
@MmuxDefineTypePredicateInfiniteBuiltin{float128}

@MmuxDefineTypePredicateInfiniteBuiltin{float32x}
@MmuxDefineTypePredicateInfiniteBuiltin{float64x}
@MmuxDefineTypePredicateInfiniteBuiltin{float128x}

@MmuxDefineTypePredicateInfiniteBuiltin{decimal32}
@MmuxDefineTypePredicateInfiniteBuiltin{decimal64}
@MmuxDefineTypePredicateInfiniteBuiltin{decimal128}

@MmuxDefineTypePredicateInfiniteBuiltin{complexf}
@MmuxDefineTypePredicateInfiniteBuiltin{complexd}
@MmuxDefineTypePredicateInfiniteBuiltin{complexld}

@MmuxDefineTypePredicateInfiniteBuiltin{complexf32}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf64}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf128}

@MmuxDefineTypePredicateInfiniteBuiltin{complexf32x}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf64x}
@MmuxDefineTypePredicateInfiniteBuiltin{complexf128x}

@MmuxDefineTypePredicateInfiniteBuiltin{complexd32}
@MmuxDefineTypePredicateInfiniteBuiltin{complexd64}
@MmuxDefineTypePredicateInfiniteBuiltin{complexd128}

@MmuxDefineTypePredicateInfiniteBuiltin{sint8}
@MmuxDefineTypePredicateInfiniteBuiltin{uint8}
@MmuxDefineTypePredicateInfiniteBuiltin{sint16}
@MmuxDefineTypePredicateInfiniteBuiltin{uint16}
@MmuxDefineTypePredicateInfiniteBuiltin{sint32}
@MmuxDefineTypePredicateInfiniteBuiltin{uint32}
@MmuxDefineTypePredicateInfiniteBuiltin{sint64}
@MmuxDefineTypePredicateInfiniteBuiltin{uint64}

@MmuxDefineTypePredicateInfiniteBuiltin{ssize}
@MmuxDefineTypePredicateInfiniteBuiltin{usize}
@MmuxDefineTypePredicateInfiniteBuiltin{sintmax}
@MmuxDefineTypePredicateInfiniteBuiltin{uintmax}
@MmuxDefineTypePredicateInfiniteBuiltin{sintptr}
@MmuxDefineTypePredicateInfiniteBuiltin{uintptr}
@MmuxDefineTypePredicateInfiniteBuiltin{mode}
@MmuxDefineTypePredicateInfiniteBuiltin{off}
@MmuxDefineTypePredicateInfiniteBuiltin{pid}
@MmuxDefineTypePredicateInfiniteBuiltin{uid}
@MmuxDefineTypePredicateInfiniteBuiltin{gid}
@MmuxDefineTypePredicateInfiniteBuiltin{wchar}
@MmuxDefineTypePredicateInfiniteBuiltin{wint}

@c page
@node types comparison
@section Comparison builtins


@menu
* types comparison exact::            Exact comparison builtins.
* types comparison approximate::      Approximate comparison builtins.
@end menu

@c page
@node types comparison exact
@subsection Exact comparison builtins


@gnu{} Bash already implements comparison operations for integer values, and such implementation
might be preferable to the builtins implemented by @value{PACKAGE}.  Anyway, for completeness, the
comparison operations are implemented for every supported data type.

@itemize
@item
The @samp{equal} builtins return true if all the operands (of which only @varo{OP} is mandatory) are
equal:

@example
@varo{OP} == @var{OP} == @dots{}
@end example

@item
The @samp{greater} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} > @var{OP} > @dots{}
@end example

@item
The @samp{lesser} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} < @var{OP} < @dots{}
@end example

@item
The @samp{greater_equal} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} >= @var{OP} >= @dots{}
@end example

@item
The @samp{lesser_equal} builtins return true if for all the operands (of which only @varo{OP} is
mandatory):

@example
@varo{OP} <= @var{OP} <= @dots{}
@end example
@end itemize


@macro MmuxDefineTypeComparisonExactBuiltin{STEM}
@deffn Builtin mmux_\STEM\_equal @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_greater @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_lesser @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_greater_equal @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_\STEM\_lesser_equal @varo{OP} @var{OP} @dots{}
Perform the comparison operations between values of type @objtype{\STEM\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@macro MmuxDefineTypeComparisonExactComplexBuiltin{STEM}
@deffn Builtin mmux_\STEM\_equal @varo{OP} @var{OP} @dots{}
Perform the comparison operations between values of type @objtype{\STEM\}.
@end deffn

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineTypeComparisonExactBuiltin{pointer}

@MmuxDefineTypeComparisonExactBuiltin{schar}
@MmuxDefineTypeComparisonExactBuiltin{uchar}
@MmuxDefineTypeComparisonExactBuiltin{sshort}
@MmuxDefineTypeComparisonExactBuiltin{ushort}
@MmuxDefineTypeComparisonExactBuiltin{sint}
@MmuxDefineTypeComparisonExactBuiltin{uint}
@MmuxDefineTypeComparisonExactBuiltin{slong}
@MmuxDefineTypeComparisonExactBuiltin{ulong}
@MmuxDefineTypeComparisonExactBuiltin{sllong}
@MmuxDefineTypeComparisonExactBuiltin{ullong}
@MmuxDefineTypeComparisonExactBuiltin{float}
@MmuxDefineTypeComparisonExactBuiltin{double}
@MmuxDefineTypeComparisonExactBuiltin{ldouble}

@MmuxDefineTypeComparisonExactBuiltin{float32}
@MmuxDefineTypeComparisonExactBuiltin{float64}
@MmuxDefineTypeComparisonExactBuiltin{float128}

@MmuxDefineTypeComparisonExactBuiltin{float32x}
@MmuxDefineTypeComparisonExactBuiltin{float64x}
@MmuxDefineTypeComparisonExactBuiltin{float128x}

@MmuxDefineTypeComparisonExactBuiltin{decimal32}
@MmuxDefineTypeComparisonExactBuiltin{decimal64}
@MmuxDefineTypeComparisonExactBuiltin{decimal128}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexf}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexd}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexld}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexf32}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf64}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf128}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexf32x}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf64x}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexf128x}

@MmuxDefineTypeComparisonExactComplexBuiltin{complexd32}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexd64}
@MmuxDefineTypeComparisonExactComplexBuiltin{complexd128}

@MmuxDefineTypeComparisonExactBuiltin{sint8}
@MmuxDefineTypeComparisonExactBuiltin{uint8}
@MmuxDefineTypeComparisonExactBuiltin{sint16}
@MmuxDefineTypeComparisonExactBuiltin{uint16}
@MmuxDefineTypeComparisonExactBuiltin{sint32}
@MmuxDefineTypeComparisonExactBuiltin{uint32}
@MmuxDefineTypeComparisonExactBuiltin{sint64}
@MmuxDefineTypeComparisonExactBuiltin{uint64}

@MmuxDefineTypeComparisonExactBuiltin{ssize}
@MmuxDefineTypeComparisonExactBuiltin{usize}
@MmuxDefineTypeComparisonExactBuiltin{sintmax}
@MmuxDefineTypeComparisonExactBuiltin{uintmax}
@MmuxDefineTypeComparisonExactBuiltin{sintptr}
@MmuxDefineTypeComparisonExactBuiltin{uintptr}
@MmuxDefineTypeComparisonExactBuiltin{mode}
@MmuxDefineTypeComparisonExactBuiltin{off}
@MmuxDefineTypeComparisonExactBuiltin{pid}
@MmuxDefineTypeComparisonExactBuiltin{uid}
@MmuxDefineTypeComparisonExactBuiltin{gid}
@MmuxDefineTypeComparisonExactBuiltin{wchar}
@MmuxDefineTypeComparisonExactBuiltin{wint}

@c page
@node types comparison approximate
@subsection Approximate comparison builtins


@menu
* types comparison approximate absmargin::  Absolute margin criterion.
* types comparison approximate relepsilon:: Relative epsilon criterion.
@end menu

@c page
@node types comparison approximate absmargin
@subsubsection Absolute margin criterion


To compare two floating--point numbers with the criterion of the absolute margin, we do:

@example
function doit () @{
    declare -r ABSOLUTE_MARGIN_FLOAT='0.1'

    mmux_float_equal_absmargin '1.0' '1.02'       @result{} 0
    mmux_float_equal_absmargin '1.0' '1.3'        @result{} 1
@}
@end example


@deffn Builtin mmux_float_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_double_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_ldouble_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexld_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal128_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128x_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd32_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd64_equal_absmargin @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd128_equal_absmargin @varo{OP} @var{OP} @dots{}
Perform the comparison operations between operands of the named type; when the comparison predicate
is satisfied: return true; otherwise return false.

The argument @varo{OP} is the only mandatory one; when only this argument is present: the return
value is true.

When multiple operands are present: @varo{OP} is compared with all the other operands in turn.  When
comparing real numbers, the predicate is:

@example
abs(@varo{OP} - @var{OP}) <= abs(@var{MARGIN})
@end example

@noindent
when comparing complex numbers, the predicate is:

@example
abs(@varo{OP_RE} - @var{OP_RE}) <= abs(@var{MARGIN_RE}) &&
abs(@varo{OP_IM} - @var{OP_IM}) <= abs(@var{MARGIN_IM})
@end example

@noindent
where: @var{MARGIN} is the value read from the shell variable @env{ABSOLUTE_MARGIN_STEM};
@code{STEM} is the stem of the numerical type; @varo{OP_RE}, @var{OP_RE}, @var{MARGIN_RE} are the
real parts; @varo{OP_IM}, @var{OP_IM}, @var{MARGIN_IM} are the imaginary parts.
@end deffn


@defvar ABSOLUTE_MARGIN_FLOAT
@defvarx ABSOLUTE_MARGIN_DOUBLE
@defvarx ABSOLUTE_MARGIN_LDOUBLE
@defvarx ABSOLUTE_MARGIN_COMPLEXF
@defvarx ABSOLUTE_MARGIN_COMPLEXD
@defvarx ABSOLUTE_MARGIN_COMPLEXLD
@defvarx ABSOLUTE_MARGIN_FLOAT32
@defvarx ABSOLUTE_MARGIN_FLOAT64
@defvarx ABSOLUTE_MARGIN_FLOAT128
@defvarx ABSOLUTE_MARGIN_FLOAT32X
@defvarx ABSOLUTE_MARGIN_FLOAT64X
@defvarx ABSOLUTE_MARGIN_FLOAT128X
@defvarx ABSOLUTE_MARGIN_DECIMAL32
@defvarx ABSOLUTE_MARGIN_DECIMAL64
@defvarx ABSOLUTE_MARGIN_DECIMAL128
@defvarx ABSOLUTE_MARGIN_COMPLEXF32
@defvarx ABSOLUTE_MARGIN_COMPLEXF64
@defvarx ABSOLUTE_MARGIN_COMPLEXF128
@defvarx ABSOLUTE_MARGIN_COMPLEXF32X
@defvarx ABSOLUTE_MARGIN_COMPLEXF64X
@defvarx ABSOLUTE_MARGIN_COMPLEXF128X
@defvarx ABSOLUTE_MARGIN_COMPLEXD32
@defvarx ABSOLUTE_MARGIN_COMPLEXD64
@defvarx ABSOLUTE_MARGIN_COMPLEXD128
Shell variables used to select the margin for the equality with absolute margin builtins.  Each
variable is used to select a margin for the named numerical type.

For real numbers: the variable holds a real number being the margin.

For complex numbers: the variable holds a complex number; its real part is the margin for comparison
of real parts; its imaginary part is the margin for comparison of imaginary parts.

When a shell variable is not set: the default margin for real numbers is @samp{1e-6}; the default
margin for complex numbers is @samp{(1e-6)+i* types(1e-6)}.
@end defvar

@c page
@node types comparison approximate relepsilon
@subsubsection Relative epsilon criterion


To compare two floating--point numbers with the criterion of the relative epsilon, we do:

@example
function doit () @{
    declare -r RELATIVE_EPSILON_FLOAT='0.1'

    mmux_float_equal_relepsilon '1.0' '1.02'       @result{} 0
    mmux_float_equal_relepsilon '1.0' '1.3'        @result{} 1
@}
@end example


@deffn Builtin mmux_float_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_double_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_ldouble_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexld_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float32x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float64x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_float128x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_decimal128_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf32x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf64x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexf128x_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd32_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd64_equal_relepsilon @varo{OP} @var{OP} @dots{}
@deffnx Builtin mmux_complexd128_equal_relepsilon @varo{OP} @var{OP} @dots{}
Perform the comparison operations between operands of the named type; when the comparison predicate
is satisfied: return true; otherwise return false.

The argument @varo{OP} is the only mandatory one; when only this argument is present: the return
value is true.

When multiple operands are present: @varo{OP} is compared with all the other operands in turn.  When
comparing real numbers, the predicate is:

@example
abs(@varo{OP} - @var{OP}) <= (@var{EPSILON} * types max(abs(@varo{OP}), abs(@var{OP})))
@end example

@noindent
when comparing complex numbers, the predicate is:

@example
abs(@varo{OP_RE} - @var{OP_RE}) <= (@var{EPSILON_RE} * types max(abs(@varo{OP_RE}), abs(@var{OP_RE}))) &&
abs(@varo{OP_IM} - @var{OP_IM}) <= (@var{EPSILON_IM} * types max(abs(@varo{OP_IM}), abs(@var{OP_IM})))
@end example

@noindent
where: @var{EPSILON} is the value read from the shell variable @env{RELATIVE_EPSILON_STEM};
@code{STEM} is the stem of the numerical type; @varo{OP_RE}, @var{OP_RE}, @var{EPSILON_RE} are the
real parts; @varo{OP_IM}, @var{OP_IM}, @var{EPSILON_IM} are the imaginary parts.
@end deffn


@defvar RELATIVE_EPSILON_FLOAT
@defvarx RELATIVE_EPSILON_DOUBLE
@defvarx RELATIVE_EPSILON_LDOUBLE
@defvarx RELATIVE_EPSILON_COMPLEXF
@defvarx RELATIVE_EPSILON_COMPLEXD
@defvarx RELATIVE_EPSILON_COMPLEXLD
@defvarx RELATIVE_EPSILON_FLOAT32
@defvarx RELATIVE_EPSILON_FLOAT64
@defvarx RELATIVE_EPSILON_FLOAT128
@defvarx RELATIVE_EPSILON_FLOAT32X
@defvarx RELATIVE_EPSILON_FLOAT64X
@defvarx RELATIVE_EPSILON_FLOAT128X
@defvarx RELATIVE_EPSILON_DECIMAL32
@defvarx RELATIVE_EPSILON_DECIMAL64
@defvarx RELATIVE_EPSILON_DECIMAL128
@defvarx RELATIVE_EPSILON_COMPLEXF32
@defvarx RELATIVE_EPSILON_COMPLEXF64
@defvarx RELATIVE_EPSILON_COMPLEXF128
@defvarx RELATIVE_EPSILON_COMPLEXF32X
@defvarx RELATIVE_EPSILON_COMPLEXF64X
@defvarx RELATIVE_EPSILON_COMPLEXF128X
@defvarx RELATIVE_EPSILON_COMPLEXD32
@defvarx RELATIVE_EPSILON_COMPLEXD64
@defvarx RELATIVE_EPSILON_COMPLEXD128
Shell variables used to select the epsilon for the equality with relative epsilon.  Each variable is
used to select an epsilon for the named numerical type.

For real numbers: the variable holds a real number being the epsilon.

For complex numbers: the variable holds a complex number; its real part is the epsilon for
comparison of real parts; its imaginary part is the epsilon for comparison of imaginary parts.

When a shell variable is not set: the default epsilon for real numbers is @samp{1e-6}; the default
epsilon for complex numbers is @samp{(1e-6)+i* types(1e-6)}.
@end defvar

@c page
@node types arithmetics
@section Arithmetics operation builtins


@gnu{} Bash already implements arithmetics operations for integer values, and such implementation
might be preferable to the builtins implemented by @value{PACKAGE}.  Anyway, for completeness, the
bitwise operations are implemented for every supported data type.

@menu
* types arithmetics addition::        Addition builtins.
* types arithmetics subtraction::     Subtraction builtins.
* types arithmetics multiplication::  Multiplication builtins.
* types arithmetics division::        Division builtins.
* types arithmetics remainder::       Remainder builtins.
* types arithmetics negation::        Negation builtins.
* types arithmetics inversion::       Inversion builtins.
* types arithmetics incrdecr::        Increment and decrement builtins.
@end menu

@c page
@node types arithmetics addition
@subsection Addition builtins


@deffn Builtin mmux_pointer_add @var{PTRVAR} @var{PTR} @var{DELTA}
Perform the addition between @var{PTR} and @var{DELTA}, then store a string representation of the
result in the variable @var{PTRVAR}; when successful: return true, otherwise return false and set
the shell variable @code{ERRNO} to the string representation of an exact integer, itself
representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer.

The argument @var{DELTA} must be the string representation of an exact number, in the range of the C
language type @objtype{ptrdiff_t}.
@end deffn


For the following builtins, the addition operation is as follows:

@example
@var{ROP} = @varo{OP} + @var{OP} + @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the addition between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeAdditionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_add @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the addition between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeAdditionBuiltin{schar}
@MmuxDefineTypeAdditionBuiltin{uchar}
@MmuxDefineTypeAdditionBuiltin{sshort}
@MmuxDefineTypeAdditionBuiltin{ushort}
@MmuxDefineTypeAdditionBuiltin{sint}
@MmuxDefineTypeAdditionBuiltin{uint}
@MmuxDefineTypeAdditionBuiltin{slong}
@MmuxDefineTypeAdditionBuiltin{ulong}
@MmuxDefineTypeAdditionBuiltin{sllong}
@MmuxDefineTypeAdditionBuiltin{ullong}
@MmuxDefineTypeAdditionBuiltin{float}
@MmuxDefineTypeAdditionBuiltin{double}
@MmuxDefineTypeAdditionBuiltin{ldouble}

@MmuxDefineTypeAdditionBuiltin{float32}
@MmuxDefineTypeAdditionBuiltin{float64}
@MmuxDefineTypeAdditionBuiltin{float128}

@MmuxDefineTypeAdditionBuiltin{float32x}
@MmuxDefineTypeAdditionBuiltin{float64x}
@MmuxDefineTypeAdditionBuiltin{float128x}

@MmuxDefineTypeAdditionBuiltin{decimal32}
@MmuxDefineTypeAdditionBuiltin{decimal64}
@MmuxDefineTypeAdditionBuiltin{decimal128}

@MmuxDefineTypeAdditionBuiltin{complexf}
@MmuxDefineTypeAdditionBuiltin{complexd}
@MmuxDefineTypeAdditionBuiltin{complexld}

@MmuxDefineTypeAdditionBuiltin{complexf32}
@MmuxDefineTypeAdditionBuiltin{complexf64}
@MmuxDefineTypeAdditionBuiltin{complexf128}

@MmuxDefineTypeAdditionBuiltin{complexf32x}
@MmuxDefineTypeAdditionBuiltin{complexf64x}
@MmuxDefineTypeAdditionBuiltin{complexf128x}

@MmuxDefineTypeAdditionBuiltin{complexd32}
@MmuxDefineTypeAdditionBuiltin{complexd64}
@MmuxDefineTypeAdditionBuiltin{complexd128}

@MmuxDefineTypeAdditionBuiltin{sint8}
@MmuxDefineTypeAdditionBuiltin{uint8}
@MmuxDefineTypeAdditionBuiltin{sint16}
@MmuxDefineTypeAdditionBuiltin{uint16}
@MmuxDefineTypeAdditionBuiltin{sint32}
@MmuxDefineTypeAdditionBuiltin{uint32}
@MmuxDefineTypeAdditionBuiltin{sint64}
@MmuxDefineTypeAdditionBuiltin{uint64}

@MmuxDefineTypeAdditionBuiltin{ssize}
@MmuxDefineTypeAdditionBuiltin{usize}
@MmuxDefineTypeAdditionBuiltin{sintmax}
@MmuxDefineTypeAdditionBuiltin{uintmax}
@MmuxDefineTypeAdditionBuiltin{sintptr}
@MmuxDefineTypeAdditionBuiltin{uintptr}
@MmuxDefineTypeAdditionBuiltin{mode}
@MmuxDefineTypeAdditionBuiltin{off}
@MmuxDefineTypeAdditionBuiltin{pid}
@MmuxDefineTypeAdditionBuiltin{uid}
@MmuxDefineTypeAdditionBuiltin{gid}
@MmuxDefineTypeAdditionBuiltin{wchar}
@MmuxDefineTypeAdditionBuiltin{wint}

@c page
@node types arithmetics subtraction
@subsection Subtraction builtins


For the following builtins, the subtraction operation is as follows:

@example
@var{ROP} = @varo{OP} - @var{OP} - @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the subtraction between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeSubtractionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_sub @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the subtraction between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeSubtractionBuiltin{schar}
@MmuxDefineTypeSubtractionBuiltin{uchar}
@MmuxDefineTypeSubtractionBuiltin{sshort}
@MmuxDefineTypeSubtractionBuiltin{ushort}
@MmuxDefineTypeSubtractionBuiltin{sint}
@MmuxDefineTypeSubtractionBuiltin{uint}
@MmuxDefineTypeSubtractionBuiltin{slong}
@MmuxDefineTypeSubtractionBuiltin{ulong}
@MmuxDefineTypeSubtractionBuiltin{sllong}
@MmuxDefineTypeSubtractionBuiltin{ullong}
@MmuxDefineTypeSubtractionBuiltin{float}
@MmuxDefineTypeSubtractionBuiltin{double}
@MmuxDefineTypeSubtractionBuiltin{ldouble}

@MmuxDefineTypeSubtractionBuiltin{float32}
@MmuxDefineTypeSubtractionBuiltin{float64}
@MmuxDefineTypeSubtractionBuiltin{float128}

@MmuxDefineTypeSubtractionBuiltin{float32x}
@MmuxDefineTypeSubtractionBuiltin{float64x}
@MmuxDefineTypeSubtractionBuiltin{float128x}

@MmuxDefineTypeSubtractionBuiltin{decimal32}
@MmuxDefineTypeSubtractionBuiltin{decimal64}
@MmuxDefineTypeSubtractionBuiltin{decimal128}

@MmuxDefineTypeSubtractionBuiltin{complexf}
@MmuxDefineTypeSubtractionBuiltin{complexd}
@MmuxDefineTypeSubtractionBuiltin{complexld}

@MmuxDefineTypeSubtractionBuiltin{complexf32}
@MmuxDefineTypeSubtractionBuiltin{complexf64}
@MmuxDefineTypeSubtractionBuiltin{complexf128}

@MmuxDefineTypeSubtractionBuiltin{complexd32}
@MmuxDefineTypeSubtractionBuiltin{complexd64}
@MmuxDefineTypeSubtractionBuiltin{complexd128}

@MmuxDefineTypeSubtractionBuiltin{sint8}
@MmuxDefineTypeSubtractionBuiltin{uint8}
@MmuxDefineTypeSubtractionBuiltin{sint16}
@MmuxDefineTypeSubtractionBuiltin{uint16}
@MmuxDefineTypeSubtractionBuiltin{sint32}
@MmuxDefineTypeSubtractionBuiltin{uint32}
@MmuxDefineTypeSubtractionBuiltin{sint64}
@MmuxDefineTypeSubtractionBuiltin{uint64}

@MmuxDefineTypeSubtractionBuiltin{ssize}
@MmuxDefineTypeSubtractionBuiltin{usize}
@MmuxDefineTypeSubtractionBuiltin{sintmax}
@MmuxDefineTypeSubtractionBuiltin{uintmax}
@MmuxDefineTypeSubtractionBuiltin{sintptr}
@MmuxDefineTypeSubtractionBuiltin{uintptr}
@MmuxDefineTypeSubtractionBuiltin{mode}
@MmuxDefineTypeSubtractionBuiltin{off}
@MmuxDefineTypeSubtractionBuiltin{pid}
@MmuxDefineTypeSubtractionBuiltin{uid}
@MmuxDefineTypeSubtractionBuiltin{gid}
@MmuxDefineTypeSubtractionBuiltin{wchar}
@MmuxDefineTypeSubtractionBuiltin{wint}

@c page
@node types arithmetics multiplication
@subsection Multiplication builtins


For the following builtins, the multiplication operation is as follows:

@example
@var{ROP} = @varo{OP} * types @var{OP} * types @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the multiplication between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeMultiplicationBuiltin{STEM}
@deffn Builtin mmux_\STEM\_mul @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the multiplication between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeMultiplicationBuiltin{schar}
@MmuxDefineTypeMultiplicationBuiltin{uchar}
@MmuxDefineTypeMultiplicationBuiltin{sshort}
@MmuxDefineTypeMultiplicationBuiltin{ushort}
@MmuxDefineTypeMultiplicationBuiltin{sint}
@MmuxDefineTypeMultiplicationBuiltin{uint}
@MmuxDefineTypeMultiplicationBuiltin{slong}
@MmuxDefineTypeMultiplicationBuiltin{ulong}
@MmuxDefineTypeMultiplicationBuiltin{sllong}
@MmuxDefineTypeMultiplicationBuiltin{ullong}
@MmuxDefineTypeMultiplicationBuiltin{float}
@MmuxDefineTypeMultiplicationBuiltin{double}
@MmuxDefineTypeMultiplicationBuiltin{ldouble}

@MmuxDefineTypeMultiplicationBuiltin{float32}
@MmuxDefineTypeMultiplicationBuiltin{float64}
@MmuxDefineTypeMultiplicationBuiltin{float128}

@MmuxDefineTypeMultiplicationBuiltin{float32x}
@MmuxDefineTypeMultiplicationBuiltin{float64x}
@MmuxDefineTypeMultiplicationBuiltin{float128x}

@MmuxDefineTypeMultiplicationBuiltin{decimal32}
@MmuxDefineTypeMultiplicationBuiltin{decimal64}
@MmuxDefineTypeMultiplicationBuiltin{decimal128}

@MmuxDefineTypeMultiplicationBuiltin{complexf}
@MmuxDefineTypeMultiplicationBuiltin{complexd}
@MmuxDefineTypeMultiplicationBuiltin{complexld}

@MmuxDefineTypeMultiplicationBuiltin{complexf32}
@MmuxDefineTypeMultiplicationBuiltin{complexf64}
@MmuxDefineTypeMultiplicationBuiltin{complexf128}

@MmuxDefineTypeMultiplicationBuiltin{complexd32}
@MmuxDefineTypeMultiplicationBuiltin{complexd64}
@MmuxDefineTypeMultiplicationBuiltin{complexd128}

@MmuxDefineTypeMultiplicationBuiltin{sint8}
@MmuxDefineTypeMultiplicationBuiltin{uint8}
@MmuxDefineTypeMultiplicationBuiltin{sint16}
@MmuxDefineTypeMultiplicationBuiltin{uint16}
@MmuxDefineTypeMultiplicationBuiltin{sint32}
@MmuxDefineTypeMultiplicationBuiltin{uint32}
@MmuxDefineTypeMultiplicationBuiltin{sint64}
@MmuxDefineTypeMultiplicationBuiltin{uint64}

@MmuxDefineTypeMultiplicationBuiltin{ssize}
@MmuxDefineTypeMultiplicationBuiltin{usize}
@MmuxDefineTypeMultiplicationBuiltin{sintmax}
@MmuxDefineTypeMultiplicationBuiltin{uintmax}
@MmuxDefineTypeMultiplicationBuiltin{sintptr}
@MmuxDefineTypeMultiplicationBuiltin{uintptr}
@MmuxDefineTypeMultiplicationBuiltin{mode}
@MmuxDefineTypeMultiplicationBuiltin{off}
@MmuxDefineTypeMultiplicationBuiltin{pid}
@MmuxDefineTypeMultiplicationBuiltin{uid}
@MmuxDefineTypeMultiplicationBuiltin{gid}
@MmuxDefineTypeMultiplicationBuiltin{wchar}
@MmuxDefineTypeMultiplicationBuiltin{wint}

@c page
@node types arithmetics division
@subsection Division builtins


For the following builtins, the division operation is as follows:

@example
@var{ROP} = @varo{OP} * types @var{OP} * types @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the division between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.


@macro MmuxDefineTypeDivisionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_div @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the division between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeDivisionBuiltin{schar}
@MmuxDefineTypeDivisionBuiltin{uchar}
@MmuxDefineTypeDivisionBuiltin{sshort}
@MmuxDefineTypeDivisionBuiltin{ushort}
@MmuxDefineTypeDivisionBuiltin{sint}
@MmuxDefineTypeDivisionBuiltin{uint}
@MmuxDefineTypeDivisionBuiltin{slong}
@MmuxDefineTypeDivisionBuiltin{ulong}
@MmuxDefineTypeDivisionBuiltin{sllong}
@MmuxDefineTypeDivisionBuiltin{ullong}
@MmuxDefineTypeDivisionBuiltin{float}
@MmuxDefineTypeDivisionBuiltin{double}
@MmuxDefineTypeDivisionBuiltin{ldouble}

@MmuxDefineTypeDivisionBuiltin{float32}
@MmuxDefineTypeDivisionBuiltin{float64}
@MmuxDefineTypeDivisionBuiltin{float128}

@MmuxDefineTypeDivisionBuiltin{float32x}
@MmuxDefineTypeDivisionBuiltin{float64x}
@MmuxDefineTypeDivisionBuiltin{float128x}

@MmuxDefineTypeDivisionBuiltin{decimal32}
@MmuxDefineTypeDivisionBuiltin{decimal64}
@MmuxDefineTypeDivisionBuiltin{decimal128}

@MmuxDefineTypeDivisionBuiltin{complexf}
@MmuxDefineTypeDivisionBuiltin{complexd}
@MmuxDefineTypeDivisionBuiltin{complexld}

@MmuxDefineTypeDivisionBuiltin{complexf32}
@MmuxDefineTypeDivisionBuiltin{complexf64}
@MmuxDefineTypeDivisionBuiltin{complexf128}

@MmuxDefineTypeDivisionBuiltin{complexd32}
@MmuxDefineTypeDivisionBuiltin{complexd64}
@MmuxDefineTypeDivisionBuiltin{complexd128}

@MmuxDefineTypeDivisionBuiltin{sint8}
@MmuxDefineTypeDivisionBuiltin{uint8}
@MmuxDefineTypeDivisionBuiltin{sint16}
@MmuxDefineTypeDivisionBuiltin{uint16}
@MmuxDefineTypeDivisionBuiltin{sint32}
@MmuxDefineTypeDivisionBuiltin{uint32}
@MmuxDefineTypeDivisionBuiltin{sint64}
@MmuxDefineTypeDivisionBuiltin{uint64}

@MmuxDefineTypeDivisionBuiltin{ssize}
@MmuxDefineTypeDivisionBuiltin{usize}
@MmuxDefineTypeDivisionBuiltin{sintmax}
@MmuxDefineTypeDivisionBuiltin{uintmax}
@MmuxDefineTypeDivisionBuiltin{sintptr}
@MmuxDefineTypeDivisionBuiltin{uintptr}
@MmuxDefineTypeDivisionBuiltin{mode}
@MmuxDefineTypeDivisionBuiltin{off}
@MmuxDefineTypeDivisionBuiltin{pid}
@MmuxDefineTypeDivisionBuiltin{uid}
@MmuxDefineTypeDivisionBuiltin{gid}
@MmuxDefineTypeDivisionBuiltin{wchar}
@MmuxDefineTypeDivisionBuiltin{wint}

@c page
@node types arithmetics remainder
@subsection Remainder builtins


For the following builtins, the remainder operation is as follows:

@example
@var{ROP} = @vari{OP} % @varii{OP}
@end example

All the builtins perform the remainder between the operands @var{OP}, then store a string
representation of the result in the variable @var{ROPVAR}; when successful: return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.


@macro MmuxDefineTypeRemainderBuiltin{STEM}
@deffn Builtin mmux_\STEM\_mod @var{ROPVAR} @vari{OP} @varii{OP}
Perform the remainder between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeRemainderBuiltin{schar}
@MmuxDefineTypeRemainderBuiltin{uchar}
@MmuxDefineTypeRemainderBuiltin{sshort}
@MmuxDefineTypeRemainderBuiltin{ushort}
@MmuxDefineTypeRemainderBuiltin{sint}
@MmuxDefineTypeRemainderBuiltin{uint}
@MmuxDefineTypeRemainderBuiltin{slong}
@MmuxDefineTypeRemainderBuiltin{ulong}
@MmuxDefineTypeRemainderBuiltin{sllong}
@MmuxDefineTypeRemainderBuiltin{ullong}

@MmuxDefineTypeRemainderBuiltin{sint8}
@MmuxDefineTypeRemainderBuiltin{uint8}
@MmuxDefineTypeRemainderBuiltin{sint16}
@MmuxDefineTypeRemainderBuiltin{uint16}
@MmuxDefineTypeRemainderBuiltin{sint32}
@MmuxDefineTypeRemainderBuiltin{uint32}
@MmuxDefineTypeRemainderBuiltin{sint64}
@MmuxDefineTypeRemainderBuiltin{uint64}

@MmuxDefineTypeRemainderBuiltin{ssize}
@MmuxDefineTypeRemainderBuiltin{usize}
@MmuxDefineTypeRemainderBuiltin{sintmax}
@MmuxDefineTypeRemainderBuiltin{uintmax}
@MmuxDefineTypeRemainderBuiltin{sintptr}
@MmuxDefineTypeRemainderBuiltin{uintptr}
@MmuxDefineTypeRemainderBuiltin{mode}
@MmuxDefineTypeRemainderBuiltin{off}
@MmuxDefineTypeRemainderBuiltin{pid}
@MmuxDefineTypeRemainderBuiltin{uid}
@MmuxDefineTypeRemainderBuiltin{gid}
@MmuxDefineTypeRemainderBuiltin{wchar}
@MmuxDefineTypeRemainderBuiltin{wint}

@c page
@node types arithmetics negation
@subsection Negation builtins


For the following builtins, the negation operation is as follows:

@example
@var{ROP} = - @var{OP}
@end example

All the builtins perform the negation of the operand @var{OP}, then store a string representation of
the result in the variable @var{ROPVAR}; when successful: return true, otherwise return false and
set the shell variable @code{ERRNO} to the string representation of an exact integer, itself
representing an @code{errno} error code.

The argument @var{OP} must be a string representation of a value of the specific builtin type.

@strong{NOTE} The builtins are implemented also for unsigned integers, for which the operation is
undefined; this will be fixed in the future, probably@dots{}


@macro MmuxDefineTypeNegationBuiltin{STEM}
@deffn Builtin mmux_\STEM\_neg @var{ROPVAR} @var{OP}
Perform the negation of a value of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeNegationBuiltin{schar}
@MmuxDefineTypeNegationBuiltin{uchar}
@MmuxDefineTypeNegationBuiltin{sshort}
@MmuxDefineTypeNegationBuiltin{ushort}
@MmuxDefineTypeNegationBuiltin{sint}
@MmuxDefineTypeNegationBuiltin{uint}
@MmuxDefineTypeNegationBuiltin{slong}
@MmuxDefineTypeNegationBuiltin{ulong}
@MmuxDefineTypeNegationBuiltin{sllong}
@MmuxDefineTypeNegationBuiltin{ullong}
@MmuxDefineTypeNegationBuiltin{float}
@MmuxDefineTypeNegationBuiltin{double}
@MmuxDefineTypeNegationBuiltin{ldouble}

@MmuxDefineTypeNegationBuiltin{float32}
@MmuxDefineTypeNegationBuiltin{float64}
@MmuxDefineTypeNegationBuiltin{float128}

@MmuxDefineTypeNegationBuiltin{float32x}
@MmuxDefineTypeNegationBuiltin{float64x}
@MmuxDefineTypeNegationBuiltin{float128x}

@MmuxDefineTypeNegationBuiltin{decimal32}
@MmuxDefineTypeNegationBuiltin{decimal64}
@MmuxDefineTypeNegationBuiltin{decimal128}

@MmuxDefineTypeNegationBuiltin{complexf}
@MmuxDefineTypeNegationBuiltin{complexd}
@MmuxDefineTypeNegationBuiltin{complexld}

@MmuxDefineTypeNegationBuiltin{complexf32}
@MmuxDefineTypeNegationBuiltin{complexf64}
@MmuxDefineTypeNegationBuiltin{complexf128}

@MmuxDefineTypeNegationBuiltin{complexd32}
@MmuxDefineTypeNegationBuiltin{complexd64}
@MmuxDefineTypeNegationBuiltin{complexd128}

@MmuxDefineTypeNegationBuiltin{sint8}
@MmuxDefineTypeNegationBuiltin{uint8}
@MmuxDefineTypeNegationBuiltin{sint16}
@MmuxDefineTypeNegationBuiltin{uint16}
@MmuxDefineTypeNegationBuiltin{sint32}
@MmuxDefineTypeNegationBuiltin{uint32}
@MmuxDefineTypeNegationBuiltin{sint64}
@MmuxDefineTypeNegationBuiltin{uint64}

@MmuxDefineTypeNegationBuiltin{ssize}
@MmuxDefineTypeNegationBuiltin{usize}
@MmuxDefineTypeNegationBuiltin{sintmax}
@MmuxDefineTypeNegationBuiltin{uintmax}
@MmuxDefineTypeNegationBuiltin{sintptr}
@MmuxDefineTypeNegationBuiltin{uintptr}
@MmuxDefineTypeNegationBuiltin{mode}
@MmuxDefineTypeNegationBuiltin{off}
@MmuxDefineTypeNegationBuiltin{pid}
@MmuxDefineTypeNegationBuiltin{uid}
@MmuxDefineTypeNegationBuiltin{gid}
@MmuxDefineTypeNegationBuiltin{wchar}
@MmuxDefineTypeNegationBuiltin{wint}

@c page
@node types arithmetics inversion
@subsection Inversion builtins


For the following builtins, the inversion operation is as follows:

@example
@var{ROP} = 1 / @var{OP}
@end example

All the builtins perform the inversion of the operand @var{OP}, then store a string representation of
the result in the variable @var{ROPVAR}; when successful: return true, otherwise return false and
set the shell variable @code{ERRNO} to the string representation of an exact integer, itself
representing an @code{errno} error code.

The argument @var{OP} must be a string representation of a value of the specific builtin type.


@macro MmuxDefineTypeInversionBuiltin{STEM}
@deffn Builtin mmux_\STEM\_inv @var{ROPVAR} @var{OP}
Perform the inversion of a value of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeInversionBuiltin{schar}
@MmuxDefineTypeInversionBuiltin{uchar}
@MmuxDefineTypeInversionBuiltin{sshort}
@MmuxDefineTypeInversionBuiltin{ushort}
@MmuxDefineTypeInversionBuiltin{sint}
@MmuxDefineTypeInversionBuiltin{uint}
@MmuxDefineTypeInversionBuiltin{slong}
@MmuxDefineTypeInversionBuiltin{ulong}
@MmuxDefineTypeInversionBuiltin{sllong}
@MmuxDefineTypeInversionBuiltin{ullong}
@MmuxDefineTypeInversionBuiltin{float}
@MmuxDefineTypeInversionBuiltin{double}
@MmuxDefineTypeInversionBuiltin{ldouble}

@MmuxDefineTypeInversionBuiltin{float32}
@MmuxDefineTypeInversionBuiltin{float64}
@MmuxDefineTypeInversionBuiltin{float128}

@MmuxDefineTypeInversionBuiltin{float32x}
@MmuxDefineTypeInversionBuiltin{float64x}
@MmuxDefineTypeInversionBuiltin{float128x}

@MmuxDefineTypeInversionBuiltin{decimal32}
@MmuxDefineTypeInversionBuiltin{decimal64}
@MmuxDefineTypeInversionBuiltin{decimal128}

@MmuxDefineTypeInversionBuiltin{complexf}
@MmuxDefineTypeInversionBuiltin{complexd}
@MmuxDefineTypeInversionBuiltin{complexld}

@MmuxDefineTypeInversionBuiltin{complexf32}
@MmuxDefineTypeInversionBuiltin{complexf64}
@MmuxDefineTypeInversionBuiltin{complexf128}

@MmuxDefineTypeInversionBuiltin{complexd32}
@MmuxDefineTypeInversionBuiltin{complexd64}
@MmuxDefineTypeInversionBuiltin{complexd128}

@MmuxDefineTypeInversionBuiltin{sint8}
@MmuxDefineTypeInversionBuiltin{uint8}
@MmuxDefineTypeInversionBuiltin{sint16}
@MmuxDefineTypeInversionBuiltin{uint16}
@MmuxDefineTypeInversionBuiltin{sint32}
@MmuxDefineTypeInversionBuiltin{uint32}
@MmuxDefineTypeInversionBuiltin{sint64}
@MmuxDefineTypeInversionBuiltin{uint64}

@MmuxDefineTypeInversionBuiltin{ssize}
@MmuxDefineTypeInversionBuiltin{usize}
@MmuxDefineTypeInversionBuiltin{sintmax}
@MmuxDefineTypeInversionBuiltin{uintmax}
@MmuxDefineTypeInversionBuiltin{sintptr}
@MmuxDefineTypeInversionBuiltin{uintptr}
@MmuxDefineTypeInversionBuiltin{mode}
@MmuxDefineTypeInversionBuiltin{off}
@MmuxDefineTypeInversionBuiltin{pid}
@MmuxDefineTypeInversionBuiltin{uid}
@MmuxDefineTypeInversionBuiltin{gid}
@MmuxDefineTypeInversionBuiltin{wchar}
@MmuxDefineTypeInversionBuiltin{wint}

@c page
@node types arithmetics incrdecr
@subsection Increment and decrement builtins


@macro MmuxDefineTypeIncrdecrBuiltin{STEM}
@deffn Builtin mmux_\STEM\_incr @var{ROPVAR} @var{OP}
@deffnx Builtin mmux_\STEM\_decr @var{ROPVAR} @var{OP}
Increment or decrement @var{OP}, store the result in the shell variable @var{ROPVAR}.
@end deffn

@end macro

@MmuxDefineTypeIncrdecrBuiltin{schar}
@MmuxDefineTypeIncrdecrBuiltin{uchar}
@MmuxDefineTypeIncrdecrBuiltin{sshort}
@MmuxDefineTypeIncrdecrBuiltin{ushort}
@MmuxDefineTypeIncrdecrBuiltin{sint}
@MmuxDefineTypeIncrdecrBuiltin{uint}
@MmuxDefineTypeIncrdecrBuiltin{slong}
@MmuxDefineTypeIncrdecrBuiltin{ulong}
@MmuxDefineTypeIncrdecrBuiltin{sllong}
@MmuxDefineTypeIncrdecrBuiltin{ullong}

@MmuxDefineTypeIncrdecrBuiltin{sint8}
@MmuxDefineTypeIncrdecrBuiltin{uint8}
@MmuxDefineTypeIncrdecrBuiltin{sint16}
@MmuxDefineTypeIncrdecrBuiltin{uint16}
@MmuxDefineTypeIncrdecrBuiltin{sint32}
@MmuxDefineTypeIncrdecrBuiltin{uint32}
@MmuxDefineTypeIncrdecrBuiltin{sint64}
@MmuxDefineTypeIncrdecrBuiltin{uint64}

@MmuxDefineTypeIncrdecrBuiltin{ssize}
@MmuxDefineTypeIncrdecrBuiltin{usize}
@MmuxDefineTypeIncrdecrBuiltin{sintmax}
@MmuxDefineTypeIncrdecrBuiltin{uintmax}
@MmuxDefineTypeIncrdecrBuiltin{sintptr}
@MmuxDefineTypeIncrdecrBuiltin{uintptr}
@MmuxDefineTypeIncrdecrBuiltin{mode}
@MmuxDefineTypeIncrdecrBuiltin{off}
@MmuxDefineTypeIncrdecrBuiltin{pid}
@MmuxDefineTypeIncrdecrBuiltin{uid}
@MmuxDefineTypeIncrdecrBuiltin{gid}
@MmuxDefineTypeIncrdecrBuiltin{wchar}
@MmuxDefineTypeIncrdecrBuiltin{wint}

@c page
@node types complex
@section Basic complex number builtins


@menu
* types complex make::          Constructing complex numbers.
* types complex parts::         Extracting the real and imaginary parts.
* types complex abs::           Computing the absolute value.
* types complex arg::           Computing the argument value.
* types complex conj::          Computing the complex conjugate value.
@end menu

@c page
@node types complex make
@subsection Constructing complex numbers


To construct a complex number from its real and imaginary parts, we do:

@example
declare ROP

mmux_complexd_make_rectangular ROP '1.2' '3.4'
"$ROP"  @result{} (1.2)+i* types(3.4)
@end example



@macro MmuxDefineComplexMakeRectangularBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_make_rectangular @var{ROPVAR} @var{REP} @var{IMP}
Construct a complex number, of type @objtype{\CPLXSTEM\}, from the real and imaginary parts
@var{REP} and @var{IMP}, of type @objtype{\REALSTEM\}.  Store a string representation of the result
in the shell variable @var{ROPVAR}.
@end deffn

@end macro

@MmuxDefineComplexMakeRectangularBuiltin{complexf, float}
@MmuxDefineComplexMakeRectangularBuiltin{complexd, double}
@MmuxDefineComplexMakeRectangularBuiltin{complexld, ldouble}

@MmuxDefineComplexMakeRectangularBuiltin{complexf32, float32}
@MmuxDefineComplexMakeRectangularBuiltin{complexf64, float64}
@MmuxDefineComplexMakeRectangularBuiltin{complexf128, float128}

@MmuxDefineComplexMakeRectangularBuiltin{complexf32x, float32x}
@MmuxDefineComplexMakeRectangularBuiltin{complexf64x, float64x}
@MmuxDefineComplexMakeRectangularBuiltin{complexf128x, float128x}

@MmuxDefineComplexMakeRectangularBuiltin{complexd32, decimal32}
@MmuxDefineComplexMakeRectangularBuiltin{complexd64, decimal64}
@MmuxDefineComplexMakeRectangularBuiltin{complexd128, decimal128}

@c page
@node types complex parts
@subsection Extracting the real and imaginary parts


To extract the real and imaginary parts of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' REP IMP

mmux_complexd_real_part REP "$Z"
mmux_complexd_real_part IMP "$Z"
"$REP"  @result{} 1.2
"$IMP"  @result{} 3.4
@end example


@macro MmuxDefineComplexRealImagPartBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_real_part @var{REPVAR} @var{OP}
@deffnx Builtin mmux_\CPLXSTEM\_imag_part @var{IMPVAR} @var{OP}
Extract the real or imaginary parts, which will be of type @objtype{\REALSTEM\}, from the complex
number @var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell
variable @var{REPVAR} or @var{IMPVAR}.
@end deffn

@end macro

@MmuxDefineComplexRealImagPartBuiltin{complexf, float}
@MmuxDefineComplexRealImagPartBuiltin{complexd, double}
@MmuxDefineComplexRealImagPartBuiltin{complexld, ldouble}

@MmuxDefineComplexRealImagPartBuiltin{complexf32, float32}
@MmuxDefineComplexRealImagPartBuiltin{complexf64, float64}
@MmuxDefineComplexRealImagPartBuiltin{complexf128, float128}

@MmuxDefineComplexRealImagPartBuiltin{complexf32x, float32x}
@MmuxDefineComplexRealImagPartBuiltin{complexf64x, float64x}
@MmuxDefineComplexRealImagPartBuiltin{complexf128x, float128x}

@MmuxDefineComplexRealImagPartBuiltin{complexd32, decimal32}
@MmuxDefineComplexRealImagPartBuiltin{complexd64, decimal64}
@MmuxDefineComplexRealImagPartBuiltin{complexd128, decimal128}

@c page
@node types complex abs
@subsection Computing the absolute value


To compute the absolute value of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' A

mmux_complexd_abs A "$Z"
"$A"    @result{} 3.605551275463989
@end example


@macro MmuxDefineComplexAbsBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_abs @var{ABSVAR} @var{OP}
Extract the absolute value, which will be of type @objtype{\REALSTEM\}, from the complex number
@var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell variable
@var{ABSVAR}.
@end deffn

@end macro

@MmuxDefineComplexAbsBuiltin{complexf, float}
@MmuxDefineComplexAbsBuiltin{complexd, double}
@MmuxDefineComplexAbsBuiltin{complexld, ldouble}

@MmuxDefineComplexAbsBuiltin{complexf32, float32}
@MmuxDefineComplexAbsBuiltin{complexf64, float64}
@MmuxDefineComplexAbsBuiltin{complexf128, float128}

@MmuxDefineComplexAbsBuiltin{complexf32x, float32x}
@MmuxDefineComplexAbsBuiltin{complexf64x, float64x}
@MmuxDefineComplexAbsBuiltin{complexf128x, float128x}

@MmuxDefineComplexAbsBuiltin{complexd32, decimal32}
@MmuxDefineComplexAbsBuiltin{complexd64, decimal64}
@MmuxDefineComplexAbsBuiltin{complexd128, decimal128}

@c page
@node types complex arg
@subsection Computing the argument value


To compute the argument value of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' A

mmux_complexd_arg A "$Z"
"$A"    @result{} 1.231503712340852
@end example


@macro MmuxDefineComplexArgBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_arg @var{ARGVAR} @var{OP}
Extract the argument value, which will be of type @objtype{\REALSTEM\}, from the complex number
@var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell variable
@var{ARGVAR}.
@end deffn

@end macro

@MmuxDefineComplexArgBuiltin{complexf, float}
@MmuxDefineComplexArgBuiltin{complexd, double}
@MmuxDefineComplexArgBuiltin{complexld, ldouble}

@MmuxDefineComplexArgBuiltin{complexf32, float32}
@MmuxDefineComplexArgBuiltin{complexf64, float64}
@MmuxDefineComplexArgBuiltin{complexf128, float128}

@MmuxDefineComplexArgBuiltin{complexf32x, float32x}
@MmuxDefineComplexArgBuiltin{complexf64x, float64x}
@MmuxDefineComplexArgBuiltin{complexf128x, float128x}

@MmuxDefineComplexArgBuiltin{complexd32, decimal32}
@MmuxDefineComplexArgBuiltin{complexd64, decimal64}
@MmuxDefineComplexArgBuiltin{complexd128, decimal128}

@c page
@node types complex conj
@subsection Computing the complex conjugate value


To compute the complex conjugate value of a complex number, we do:

@example
declare Z='(1.2)+i* types(3.4)' W

mmux_complexd_conj W "$Z"
"$W"    @result{} (1.2)+i* types(-3.4)
@end example


@macro MmuxDefineComplexConjBuiltin{CPLXSTEM,REALSTEM}
@deffn Builtin mmux_\CPLXSTEM\_conj @var{CONJVAR} @var{OP}
Compute the complex conjugate value, which will be of type @objtype{\CPLXSTEM\}, from the complex
number @var{OP}, which must be of type @objtype{\CPLXSTEM\}, and store the result in the shell
variable @var{CONJVAR}.
@end deffn

@end macro

@MmuxDefineComplexConjBuiltin{complexf, float}
@MmuxDefineComplexConjBuiltin{complexd, double}
@MmuxDefineComplexConjBuiltin{complexld, ldouble}

@MmuxDefineComplexConjBuiltin{complexf32, float32}
@MmuxDefineComplexConjBuiltin{complexf64, float64}
@MmuxDefineComplexConjBuiltin{complexf128, float128}

@MmuxDefineComplexConjBuiltin{complexf32x, float32x}
@MmuxDefineComplexConjBuiltin{complexf64x, float64x}
@MmuxDefineComplexConjBuiltin{complexf128x, float128x}

@MmuxDefineComplexConjBuiltin{complexd32, decimal32}
@MmuxDefineComplexConjBuiltin{complexd64, decimal64}
@MmuxDefineComplexConjBuiltin{complexd128, decimal128}

@c page
@node types bitwise
@section Bitwise operation builtins


@gnu{} Bash already implements bitwise operations for integer values, and such implementation might
be preferable to the builtins implemented by @value{PACKAGE}.  Anyway, for completeness, the bitwise
operations are implemented for every supported data type.

@menu
* types bitwise and::           Bitwise AND operation.
* types bitwise or::            Bitwise OR operation.
* types bitwise xor::           Bitwise XOR operation.
* types bitwise not::           Bitwise NOT operation.
* types bitwise shl::           Bitwise shift--left operation.
* types bitwise shr::           Bitwise shift--right operation.
@end menu

@c page
@node types bitwise and
@subsection Bitwise AND operation


@deffn Builtin mmux_pointer_bitwise_and @var{PTRVAR} @var{PTR} @var{MASK}
Compose a pointer value @var{PTR} with the exact unsigned integer value @var{MASK} using the bitwise
AND operation, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.

The argument @var{MASK} must be the string representation of a number of type @objtype{uintptr_t}.
@end deffn


For the following builtins, the bitwise AND operation is as follows:

@example
@var{ROP} = @varo{OP} & @var{OP} & @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the operation between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.

@macro MmuxDefineTypeBitwiseAndBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_and @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the bitwise AND operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseAndBuiltin{schar}
@MmuxDefineTypeBitwiseAndBuiltin{uchar}
@MmuxDefineTypeBitwiseAndBuiltin{sshort}
@MmuxDefineTypeBitwiseAndBuiltin{ushort}
@MmuxDefineTypeBitwiseAndBuiltin{sint}
@MmuxDefineTypeBitwiseAndBuiltin{uint}
@MmuxDefineTypeBitwiseAndBuiltin{slong}
@MmuxDefineTypeBitwiseAndBuiltin{ulong}
@MmuxDefineTypeBitwiseAndBuiltin{sllong}
@MmuxDefineTypeBitwiseAndBuiltin{ullong}

@MmuxDefineTypeBitwiseAndBuiltin{sint8}
@MmuxDefineTypeBitwiseAndBuiltin{uint8}
@MmuxDefineTypeBitwiseAndBuiltin{sint16}
@MmuxDefineTypeBitwiseAndBuiltin{uint16}
@MmuxDefineTypeBitwiseAndBuiltin{sint32}
@MmuxDefineTypeBitwiseAndBuiltin{uint32}
@MmuxDefineTypeBitwiseAndBuiltin{sint64}
@MmuxDefineTypeBitwiseAndBuiltin{uint64}

@MmuxDefineTypeBitwiseAndBuiltin{ssize}
@MmuxDefineTypeBitwiseAndBuiltin{usize}
@MmuxDefineTypeBitwiseAndBuiltin{sintmax}
@MmuxDefineTypeBitwiseAndBuiltin{uintmax}
@MmuxDefineTypeBitwiseAndBuiltin{sintptr}
@MmuxDefineTypeBitwiseAndBuiltin{uintptr}
@MmuxDefineTypeBitwiseAndBuiltin{mode}
@MmuxDefineTypeBitwiseAndBuiltin{off}
@MmuxDefineTypeBitwiseAndBuiltin{pid}
@MmuxDefineTypeBitwiseAndBuiltin{uid}
@MmuxDefineTypeBitwiseAndBuiltin{gid}
@MmuxDefineTypeBitwiseAndBuiltin{wchar}
@MmuxDefineTypeBitwiseAndBuiltin{wint}

@c page
@node types bitwise or
@subsection Bitwise OR operation


@deffn Builtin mmux_pointer_bitwise_or @var{PTRVAR} @var{PTR} @var{MASK}
Compose a pointer value @var{PTR} with the exact unsigned integer value @var{MASK} using the bitwise
OR operation, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.

The argument @var{MASK} must be the string representation of a number of type @objtype{uintptr_t}.
@end deffn


For the following builtins, the bitwise OR operation is as follows:

@example
@var{ROP} = @varo{OP} | @var{OP} | @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the operation between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.

@macro MmuxDefineTypeBitwiseOrBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_or @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the bitwise OR operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseOrBuiltin{schar}
@MmuxDefineTypeBitwiseOrBuiltin{uchar}
@MmuxDefineTypeBitwiseOrBuiltin{sshort}
@MmuxDefineTypeBitwiseOrBuiltin{ushort}
@MmuxDefineTypeBitwiseOrBuiltin{sint}
@MmuxDefineTypeBitwiseOrBuiltin{uint}
@MmuxDefineTypeBitwiseOrBuiltin{slong}
@MmuxDefineTypeBitwiseOrBuiltin{ulong}
@MmuxDefineTypeBitwiseOrBuiltin{sllong}
@MmuxDefineTypeBitwiseOrBuiltin{ullong}

@MmuxDefineTypeBitwiseOrBuiltin{sint8}
@MmuxDefineTypeBitwiseOrBuiltin{uint8}
@MmuxDefineTypeBitwiseOrBuiltin{sint16}
@MmuxDefineTypeBitwiseOrBuiltin{uint16}
@MmuxDefineTypeBitwiseOrBuiltin{sint32}
@MmuxDefineTypeBitwiseOrBuiltin{uint32}
@MmuxDefineTypeBitwiseOrBuiltin{sint64}
@MmuxDefineTypeBitwiseOrBuiltin{uint64}

@MmuxDefineTypeBitwiseOrBuiltin{ssize}
@MmuxDefineTypeBitwiseOrBuiltin{usize}
@MmuxDefineTypeBitwiseOrBuiltin{sintmax}
@MmuxDefineTypeBitwiseOrBuiltin{uintmax}
@MmuxDefineTypeBitwiseOrBuiltin{sintptr}
@MmuxDefineTypeBitwiseOrBuiltin{uintptr}
@MmuxDefineTypeBitwiseOrBuiltin{mode}
@MmuxDefineTypeBitwiseOrBuiltin{off}
@MmuxDefineTypeBitwiseOrBuiltin{pid}
@MmuxDefineTypeBitwiseOrBuiltin{uid}
@MmuxDefineTypeBitwiseOrBuiltin{gid}
@MmuxDefineTypeBitwiseOrBuiltin{wchar}
@MmuxDefineTypeBitwiseOrBuiltin{wint}

@c page
@node types bitwise xor
@subsection Bitwise XOR operation


@deffn Builtin mmux_pointer_bitwise_xor @var{PTRVAR} @var{PTR} @var{MASK}
Compose a pointer value @var{PTR} with the exact unsigned integer value @var{MASK} using the bitwise
XOR operation, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.

The argument @var{MASK} must be the string representation of a number of type @objtype{uintptr_t}.
@end deffn


For the following builtins, the bitwise XOR operation is as follows:

@example
@var{ROP} = @varo{OP} ^ @var{OP} ^ @dots{}
@end example

@noindent
and there can be any number of operands, depending on the capabilities of the underlying platform.

All the builtins perform the operation between the operands @var{OP}, of which @varo{OP} is
mandatory, then store a string representation of the result in the variable @var{ROPVAR}; when
successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The arguments @var{OP} must be string representations of values of the specific builtin type.  If
only @varo{OP} is present: the result is @varo{OP} itself.

@macro MmuxDefineTypeBitwiseXorBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_xor @var{ROPVAR} @varo{OP} @var{OP} @dots{}
Perform the bitwise XOR operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseXorBuiltin{schar}
@MmuxDefineTypeBitwiseXorBuiltin{uchar}
@MmuxDefineTypeBitwiseXorBuiltin{sshort}
@MmuxDefineTypeBitwiseXorBuiltin{ushort}
@MmuxDefineTypeBitwiseXorBuiltin{sint}
@MmuxDefineTypeBitwiseXorBuiltin{uint}
@MmuxDefineTypeBitwiseXorBuiltin{slong}
@MmuxDefineTypeBitwiseXorBuiltin{ulong}
@MmuxDefineTypeBitwiseXorBuiltin{sllong}
@MmuxDefineTypeBitwiseXorBuiltin{ullong}

@MmuxDefineTypeBitwiseXorBuiltin{sint8}
@MmuxDefineTypeBitwiseXorBuiltin{uint8}
@MmuxDefineTypeBitwiseXorBuiltin{sint16}
@MmuxDefineTypeBitwiseXorBuiltin{uint16}
@MmuxDefineTypeBitwiseXorBuiltin{sint32}
@MmuxDefineTypeBitwiseXorBuiltin{uint32}
@MmuxDefineTypeBitwiseXorBuiltin{sint64}
@MmuxDefineTypeBitwiseXorBuiltin{uint64}

@MmuxDefineTypeBitwiseXorBuiltin{ssize}
@MmuxDefineTypeBitwiseXorBuiltin{usize}
@MmuxDefineTypeBitwiseXorBuiltin{sintmax}
@MmuxDefineTypeBitwiseXorBuiltin{uintmax}
@MmuxDefineTypeBitwiseXorBuiltin{sintptr}
@MmuxDefineTypeBitwiseXorBuiltin{uintptr}
@MmuxDefineTypeBitwiseXorBuiltin{mode}
@MmuxDefineTypeBitwiseXorBuiltin{off}
@MmuxDefineTypeBitwiseXorBuiltin{pid}
@MmuxDefineTypeBitwiseXorBuiltin{uid}
@MmuxDefineTypeBitwiseXorBuiltin{gid}
@MmuxDefineTypeBitwiseXorBuiltin{wchar}
@MmuxDefineTypeBitwiseXorBuiltin{wint}

@c page
@node types bitwise not
@subsection Bitwise NOT operation


@deffn Builtin mmux_pointer_bitwise_not @var{PTRVAR} @var{PTR}
Perform the bitwise NOT operation on a pointer value @var{PTR}, then store the result in the
variable @var{ROPVAR}; when successful: return true, otherwise return false and set the shell
variable @code{ERRNO} to the string representation of an exact integer, itself representing an
@code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer value.
@end deffn


For the following builtins, the bitwise NOT operation is as follows:

@example
@var{ROP} = ~ @var{OP}
@end example

@noindent

When successful: return true, otherwise return false and set the shell variable @code{ERRNO} to the
string representation of an exact integer, itself representing an @code{errno} error code.

The argument @var{OP} must be a string representation of a value of the specific builtin type.

@macro MmuxDefineTypeBitwiseNotBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_not @var{ROPVAR} @varo{OP}
Perform the bitwise NOT operation between values of type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineTypeBitwiseNotBuiltin{schar}
@MmuxDefineTypeBitwiseNotBuiltin{uchar}
@MmuxDefineTypeBitwiseNotBuiltin{sshort}
@MmuxDefineTypeBitwiseNotBuiltin{ushort}
@MmuxDefineTypeBitwiseNotBuiltin{sint}
@MmuxDefineTypeBitwiseNotBuiltin{uint}
@MmuxDefineTypeBitwiseNotBuiltin{slong}
@MmuxDefineTypeBitwiseNotBuiltin{ulong}
@MmuxDefineTypeBitwiseNotBuiltin{sllong}
@MmuxDefineTypeBitwiseNotBuiltin{ullong}

@MmuxDefineTypeBitwiseNotBuiltin{sint8}
@MmuxDefineTypeBitwiseNotBuiltin{uint8}
@MmuxDefineTypeBitwiseNotBuiltin{sint16}
@MmuxDefineTypeBitwiseNotBuiltin{uint16}
@MmuxDefineTypeBitwiseNotBuiltin{sint32}
@MmuxDefineTypeBitwiseNotBuiltin{uint32}
@MmuxDefineTypeBitwiseNotBuiltin{sint64}
@MmuxDefineTypeBitwiseNotBuiltin{uint64}

@MmuxDefineTypeBitwiseNotBuiltin{ssize}
@MmuxDefineTypeBitwiseNotBuiltin{usize}
@MmuxDefineTypeBitwiseNotBuiltin{sintmax}
@MmuxDefineTypeBitwiseNotBuiltin{uintmax}
@MmuxDefineTypeBitwiseNotBuiltin{sintptr}
@MmuxDefineTypeBitwiseNotBuiltin{uintptr}
@MmuxDefineTypeBitwiseNotBuiltin{mode}
@MmuxDefineTypeBitwiseNotBuiltin{off}
@MmuxDefineTypeBitwiseNotBuiltin{pid}
@MmuxDefineTypeBitwiseNotBuiltin{uid}
@MmuxDefineTypeBitwiseNotBuiltin{gid}
@MmuxDefineTypeBitwiseNotBuiltin{wchar}
@MmuxDefineTypeBitwiseNotBuiltin{wint}

@c page
@node types bitwise shl
@subsection Bitwise shift--left operation


All the following builtins perform the bitwise shift--left operation on a value @var{OP}, shifting
by @var{NBITS}, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{NBITS} must be the string representation of a @objtype{sint}.


@macro MmuxDefineTypeBitwiseShlBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_shl @var{ROPVAR} @var{OP} @var{NBITS}
Perform the bitwise shift--left operation on an operand of type \STEM\.
@end deffn

@end macro

@MmuxDefineTypeBitwiseShlBuiltin{schar}
@MmuxDefineTypeBitwiseShlBuiltin{uchar}
@MmuxDefineTypeBitwiseShlBuiltin{sshort}
@MmuxDefineTypeBitwiseShlBuiltin{ushort}
@MmuxDefineTypeBitwiseShlBuiltin{sint}
@MmuxDefineTypeBitwiseShlBuiltin{uint}
@MmuxDefineTypeBitwiseShlBuiltin{slong}
@MmuxDefineTypeBitwiseShlBuiltin{ulong}
@MmuxDefineTypeBitwiseShlBuiltin{sllong}
@MmuxDefineTypeBitwiseShlBuiltin{ullong}

@MmuxDefineTypeBitwiseShlBuiltin{sint8}
@MmuxDefineTypeBitwiseShlBuiltin{uint8}
@MmuxDefineTypeBitwiseShlBuiltin{sint16}
@MmuxDefineTypeBitwiseShlBuiltin{uint16}
@MmuxDefineTypeBitwiseShlBuiltin{sint32}
@MmuxDefineTypeBitwiseShlBuiltin{uint32}
@MmuxDefineTypeBitwiseShlBuiltin{sint64}
@MmuxDefineTypeBitwiseShlBuiltin{uint64}

@MmuxDefineTypeBitwiseShlBuiltin{ssize}
@MmuxDefineTypeBitwiseShlBuiltin{usize}
@MmuxDefineTypeBitwiseShlBuiltin{sintmax}
@MmuxDefineTypeBitwiseShlBuiltin{uintmax}
@MmuxDefineTypeBitwiseShlBuiltin{sintptr}
@MmuxDefineTypeBitwiseShlBuiltin{uintptr}
@MmuxDefineTypeBitwiseShlBuiltin{mode}
@MmuxDefineTypeBitwiseShlBuiltin{off}
@MmuxDefineTypeBitwiseShlBuiltin{pid}
@MmuxDefineTypeBitwiseShlBuiltin{uid}
@MmuxDefineTypeBitwiseShlBuiltin{gid}
@MmuxDefineTypeBitwiseShlBuiltin{wchar}
@MmuxDefineTypeBitwiseShlBuiltin{wint}

@c page
@node types bitwise shr
@subsection Bitwise shift--right operation


All the following builtins perform the bitwise shift--right operation on a value @var{OP}, shifting
by @var{NBITS}, then store the result in the variable @var{ROPVAR}; when successful: return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing an @code{errno} error code.

The argument @var{NBITS} must be the string representation of a @objtype{sint}.


@macro MmuxDefineTypeBitwiseShrBuiltin{STEM}
@deffn Builtin mmux_\STEM\_bitwise_shr @var{ROPVAR} @var{OP} @var{NBITS}
Perform the bitwise shift--right operation on an operand of type \STEM\.
@end deffn

@end macro

@MmuxDefineTypeBitwiseShrBuiltin{schar}
@MmuxDefineTypeBitwiseShrBuiltin{uchar}
@MmuxDefineTypeBitwiseShrBuiltin{sshort}
@MmuxDefineTypeBitwiseShrBuiltin{ushort}
@MmuxDefineTypeBitwiseShrBuiltin{sint}
@MmuxDefineTypeBitwiseShrBuiltin{uint}
@MmuxDefineTypeBitwiseShrBuiltin{slong}
@MmuxDefineTypeBitwiseShrBuiltin{ulong}
@MmuxDefineTypeBitwiseShrBuiltin{sllong}
@MmuxDefineTypeBitwiseShrBuiltin{ullong}

@MmuxDefineTypeBitwiseShrBuiltin{sint8}
@MmuxDefineTypeBitwiseShrBuiltin{uint8}
@MmuxDefineTypeBitwiseShrBuiltin{sint16}
@MmuxDefineTypeBitwiseShrBuiltin{uint16}
@MmuxDefineTypeBitwiseShrBuiltin{sint32}
@MmuxDefineTypeBitwiseShrBuiltin{uint32}
@MmuxDefineTypeBitwiseShrBuiltin{sint64}
@MmuxDefineTypeBitwiseShrBuiltin{uint64}

@MmuxDefineTypeBitwiseShrBuiltin{ssize}
@MmuxDefineTypeBitwiseShrBuiltin{usize}
@MmuxDefineTypeBitwiseShrBuiltin{sintmax}
@MmuxDefineTypeBitwiseShrBuiltin{uintmax}
@MmuxDefineTypeBitwiseShrBuiltin{sintptr}
@MmuxDefineTypeBitwiseShrBuiltin{uintptr}
@MmuxDefineTypeBitwiseShrBuiltin{mode}
@MmuxDefineTypeBitwiseShrBuiltin{off}
@MmuxDefineTypeBitwiseShrBuiltin{pid}
@MmuxDefineTypeBitwiseShrBuiltin{uid}
@MmuxDefineTypeBitwiseShrBuiltin{gid}
@MmuxDefineTypeBitwiseShrBuiltin{wchar}
@MmuxDefineTypeBitwiseShrBuiltin{wint}

@c page
@node types formats
@section Input and output formats


@menu
* types formats float::         Selecting the printing format for floating--point numbers.
@end menu

@c page
@node types formats float
@subsection Selecting the printing format for floating--point numbers


To select an output format for the result of operations, we do:

@example
declare OLD_FORMAT ROP OP1='123.4' OP2='567.8'

mmux_double_set_format '%g' OLD_FORMAT
@{
    mmux_double_add ROP "$OP1" "$OP2"
@}
mmux_double_set_format "$OLD_FORMAT"

"$ROP"  @result{} 6.912000e+02
@end example

Remembering that when the @samp{add} functions are called with a single operand they just return
that operand, if we want to reformat a number we do:

@example
declare OLD_FORMAT OP='123.4567890'

mmux_double_set_format '%g' OLD_FORMAT
@{
    mmux_double_add OP "$OP"
@}
mmux_double_set_format "$OLD_FORMAT"

"$OP"   @result{} 1.234568e+02
@end example

The string representation of exact integers is an acceptable format for floating--point numbers: we
can use the formatting capabilities implemented for floating--point numbers to format exact
integers.

String representations of complex floating--point numbers are composed using the format selected for
the corresponding real floating--point type.

For the following builtins:

@itemize
@item
The argument @var{OUTPUT_FORMAT} must be a string compatible with the @cfunc{printf} format
selection for floating--point numbers.  Each supported type may have limitations in the available
format.

@item
The optional argument @var{OLD_FORMAT_VAR} must be a shell variable name in which the builtin will
store the old output format, so that: it is possible to temporarily select a new format, then
restore the old one.
@end itemize

@quotation
@strong{NOTE} We should be careful @strong{not} to select a field width of zero; that is, to avoid
formats like @samp{%0e}.
@end quotation


@macro MmuxSelectOutputFormatBuiltin{STEM,DEFAULTFORMAT}
@deffn Builtin mmux_\STEM\_set_format @var{OUTPUT_FORMAT}
@deffnx Builtin mmux_\STEM\_set_format @var{OUTPUT_FORMAT} @var{OLD_FORMAT_VAR}
Select a new output format for string representations of floating--point numbers of type
@objtype{\STEM\}.  The default format is @samp{\DEFAULTFORMAT\}.
@end deffn

@end macro


@MmuxSelectOutputFormatBuiltin{float, %A}
@MmuxSelectOutputFormatBuiltin{double, %A}
@MmuxSelectOutputFormatBuiltin{ldouble, %A}

@MmuxSelectOutputFormatBuiltin{float32, %A}
@MmuxSelectOutputFormatBuiltin{float64, %A}
@MmuxSelectOutputFormatBuiltin{float128, %A}

@MmuxSelectOutputFormatBuiltin{float32x, %A}
@MmuxSelectOutputFormatBuiltin{float64x, %A}
@MmuxSelectOutputFormatBuiltin{float128x, %A}

@MmuxSelectOutputFormatBuiltin{decimal32, %f}
@MmuxSelectOutputFormatBuiltin{decimal64, %f}
@MmuxSelectOutputFormatBuiltin{decimal128, %f}

@c page
@node memory
@chapter Raw memory operations


@menu
* memory alloc::                Standard memory allocation.
* memory operations::           Standard memory operations.
* memory pointers::             Memory block accessors and mutators.
* memory arrays::               Memory arrays accessors and mutators.
* memory conversions::          Converting data to and from memory blocks.
@end menu

@c page
@node memory alloc
@section Standard memory allocation


Basically, to allocate new memory we should do:

@example
declare PTR

if mmux_libc_malloc PTR 123
then exit 1
fi
@{
  # do something
@}
mmux_libc_free $PTR
@end example

@noindent
we must remember that if we execute code in a subshell: the pointers will not be valid across
shells; so the following will not work:

@example
declare PTR

$(mmux_libc_malloc PTR 123)
mmux_libc_free $PTR
@end example

@noindent
because @func{mmux_libc_malloc} allocates memory in a subshell.


@deffn Builtin mmux_libc_malloc @var{PTRVAR} @var{SIZE}
Allocate a memory block using the standard @cfunc{malloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to the string representation of an
exact integer, itself representing the @code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{SIZE} must be the string representation of an exact, positive, integer, itself
representing the requested number of bytes in the newly allocated block; it must fit the C language
type @objtype{size_t}.
@end deffn


@deffn Builtin mmux_libc_calloc @var{PTRVAR} @var{ITEM_COUNT} @var{ITEM_SIZE}
Allocate a memory block using the standard @cfunc{calloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to an exact integer representing the
@code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{ITEM_COUNT} must be the string representation of an exact, positive, integer,
itself representing the number of items the memory block has to contain; it must fit the C language
type @objtype{size_t}.

The argument @var{ITEM_SIZE} must be the string representation of an exact, positive, integer, itself
representing the size of each item the memory block has to contain; it must fit the C language type
@objtype{size_t}.
@end deffn


@deffn Builtin mmux_libc_realloc @var{PTRVAR} @var{OLDPTR} @var{NEWSIZE}
Reallocate a memory block using the standard @cfunc{realloc} function; if successful return true,
otherwise return false and set the shell variable @code{ERRNO} to an exact integer representing the
@code{errno} error code.

The argument @var{PTRVAR} must be the name of a variable in which this builtin will store a string
representation of the pointer to the newly allocated block.

The argument @var{OLDPTR} must be the string representation of the old memory pointer.

The argument @var{SIZE} must be the string representation of an exact, positive, integer, itself
representing the newly requested number of bytes in the newly allocated block; it must fit the C
language type @objtype{size_t}.
@end deffn


@deffn Builtin mmux_libc_free @var{PTR}
Release a previously allocated memory block using the standard @cfunc{free} function; if successful
return true, otherwise return false and set the shell variable @code{ERRNO} to an exact integer
representing the @code{errno} error code.

The argument @var{PTR} must be the string representation of a memory pointer referencing a
previously allocated block.

Notice that this builtin can fail if the argument @var{PTR} is not a valid pointer string
representation; in this case the error code is @samp{EINVAL}.
@end deffn

@c page
@node memory operations
@section Standard memory operations


The following builtins can fail if one of the arguments @var{PTR} is not a valid pointer string
representation; in this case the @code{ERRNO} error code is @samp{EINVAL}.


@deffn Builtin mmux_libc_memset @var{PTR} @var{BYTE} @var{SIZE}
Interface to the standard C language function @cfunc{memset}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR} must be the string representation of a pointer referencing a previously
allocated memory block.

The argument @var{BYTE} must be the string representation of an exact, positive, integer itself
representing the value to which memory bytes must be set; it must fit an unsigned 8-bit integer.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to set to @var{BYTE}; it must fit the C language type
@objtype{size_t}.

@example
declare PTR SIZE=123

mmux_libc_malloc PTR $SIZE
mmux_libc_memset $PTR 1 $SIZE
@end example
@end deffn


@deffn Builtin mmux_libc_memcpy @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Interface to the standard C language function @cfunc{memcpy}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the destination of the copy operation.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare PTR_FROM PTR_TO SIZE=123

mmux_libc_malloc PTR_FROM $SIZE
mmux_libc_malloc PTR_TO   $SIZE

mmux_libc_memcpy $PTR_TO $PTR_FROM $SIZE
@end example
@end deffn


@deffn Builtin mmux_libc_memmove @var{PTR_TO} @var{PTR_FROM} @var{SIZE}
Interface to the standard C language function @cfunc{memmove}; if successful return true, otherwise
return false and set the shell variable @code{ERRNO} to the string representation of an exact
integer, itself representing an @code{errno} error code.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the destination of the copy operation.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy.

@example
declare PTR_FROM PTR_TO SIZE=123

mmux_libc_malloc PTR_FROM $SIZE
mmux_libc_malloc PTR_TO   $SIZE

mmux_libc_memmove $PTR_TO $PTR_FROM $SIZE
@end example
@end deffn

@c page
@node memory pointers
@section Memory block accessors and mutators


If we allocate memory using the standard C library functions, we can poke and peek values in the
memory blocks:

@example
declare PTR VALUE

mmux_libc_malloc PTR 1024
@{
  mmux_double_pointer_set $PTR 0 1.23
  mmux_double_pointer_ref VALUE $PTR 0
@}
mmux_libc_free $PTR
@end example

For all the following builtins, the argument:

@table @var
@item POINTER
must be the string representation of a memory pointer referencing a previously allocated block;

@item OFFSET
must be the string representation of an exact, non--negative integer, compatible with the C language
type @code{size_t}, itself representing an offset from @var{POINTER} @strong{measured in bytes};

@item VALUE
must be the string representation of a number, compatible with a C language type of the specific
mutator: such number is stored by the mutators at @var{OFFSET} from @var{POINTER};

@item VALUEVAR
must be a string representing the name of a shell variable: it is used by the accessors to store the
value extracted at @var{OFFSET} from @var{POINTER}.
@end table

For all the following builtins: if the operation is successful, the return value is true; otherwise
the return value is false and the shell variable @code{ERRNO} is set to the string representation of
an exact integer, itself representing an @code{errno} error code.


@macro MmuxDefineAccessorMutator{STEM}
@deffn {Builtin Mutator} mmux_\STEM\_pointer_set @var{POINTER} @var{OFFSET} @var{VALUE}
@deffnx {Builtin Accessor} mmux_\STEM\_pointer_ref @var{VALUEVAR} @var{POINTER} @var{OFFSET}
Accessor and mutator for memory blocks operating on the C language type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineAccessorMutator{pointer}

@MmuxDefineAccessorMutator{schar}
@MmuxDefineAccessorMutator{uchar}
@MmuxDefineAccessorMutator{sint}
@MmuxDefineAccessorMutator{uint}
@MmuxDefineAccessorMutator{sshort}
@MmuxDefineAccessorMutator{ushort}
@MmuxDefineAccessorMutator{slong}
@MmuxDefineAccessorMutator{ulong}
@MmuxDefineAccessorMutator{sllong}
@MmuxDefineAccessorMutator{ullong}
@MmuxDefineAccessorMutator{float}
@MmuxDefineAccessorMutator{double}
@MmuxDefineAccessorMutator{ldouble}

@MmuxDefineAccessorMutator{float32}
@MmuxDefineAccessorMutator{float64}
@MmuxDefineAccessorMutator{float128}

@MmuxDefineAccessorMutator{float32x}
@MmuxDefineAccessorMutator{float64x}
@MmuxDefineAccessorMutator{float128x}

@MmuxDefineAccessorMutator{decimal32}
@MmuxDefineAccessorMutator{decimal64}
@MmuxDefineAccessorMutator{decimal128}

@MmuxDefineAccessorMutator{complexf}
@MmuxDefineAccessorMutator{complexd}
@MmuxDefineAccessorMutator{complexld}

@MmuxDefineAccessorMutator{complexf32}
@MmuxDefineAccessorMutator{complexf64}
@MmuxDefineAccessorMutator{complexf128}

@MmuxDefineAccessorMutator{complexf32x}
@MmuxDefineAccessorMutator{complexf64x}
@MmuxDefineAccessorMutator{complexf128x}

@MmuxDefineAccessorMutator{complexd32}
@MmuxDefineAccessorMutator{complexd64}
@MmuxDefineAccessorMutator{complexd128}

@MmuxDefineAccessorMutator{sint8}
@MmuxDefineAccessorMutator{uint8}
@MmuxDefineAccessorMutator{sint16}
@MmuxDefineAccessorMutator{uint16}
@MmuxDefineAccessorMutator{sint32}
@MmuxDefineAccessorMutator{uint32}
@MmuxDefineAccessorMutator{sint64}
@MmuxDefineAccessorMutator{uint64}

@MmuxDefineAccessorMutator{ssize}
@MmuxDefineAccessorMutator{usize}
@MmuxDefineAccessorMutator{sintmax}
@MmuxDefineAccessorMutator{uintmax}
@MmuxDefineAccessorMutator{sintptr}
@MmuxDefineAccessorMutator{uintptr}
@MmuxDefineAccessorMutator{mode}
@MmuxDefineAccessorMutator{off}
@MmuxDefineAccessorMutator{pid}
@MmuxDefineAccessorMutator{uid}
@MmuxDefineAccessorMutator{gid}

@c page
@node memory arrays
@section Memory arrays accessors and mutators


If we allocate memory using the standard C library functions, we can poke and peek values in the
memory blocks, handling them as arrays of a specified C type:

@example
declare PTR VALUE

mmux_libc_malloc PTR $(( 55 * mmux_ulong_SIZEOF ))
@{
  mmux_ulong_array_set $PTR 0 1234567890
  mmux_ulong_array_ref VALUE $PTR 0
@}
mmux_libc_free $PTR
@end example

For all the following builtins, the argument:

@table @var
@item ARRAY
must be the string representation of a memory pointer referencing a previously allocated block; the
block is to be interpreted as an array of a specified C type;

@item INDEX
must be the string representation of an exact, non--negative integer, compatible with the C language
type @code{size_t}, itself representing an index in @var{ARRAY};

@item VALUE
must be the string representation of a number, compatible with a C language type of the specific
mutator: it is stored by the mutators at @var{INDEX} in @var{ARRAY};

@item VALUEVAR
must be a string representing the name of a shell variable: it is used by the accessors to store the
value extracted at @var{INDEX} from @var{ARRAY}.
@end table

For all the following builtins: if the operation is successful, the return value is true; otherwise
the return value is false and the shell variable @code{ERRNO} is set to the string representation of
an exact integer, itself representing an @code{errno} error code.


@macro MmuxDefineArrayAccessorMutator{STEM}
@deffn {Builtin Mutator} mmux_\STEM\_array_set @var{ARRAY} @var{INDEX} @var{VALUE}
@deffnx {Builtin Accessor} mmux_\STEM\_array_ref @var{VALUEVAR} @var{ARRAY} @var{INDEX}
Accessor and mutator for memory blocks operating on the C language type @code{\STEM\}.
@end deffn

@end macro

@MmuxDefineArrayAccessorMutator{pointer}

@MmuxDefineArrayAccessorMutator{schar}
@MmuxDefineArrayAccessorMutator{uchar}
@MmuxDefineArrayAccessorMutator{sshort}
@MmuxDefineArrayAccessorMutator{ushort}
@MmuxDefineArrayAccessorMutator{sint}
@MmuxDefineArrayAccessorMutator{uint}
@MmuxDefineArrayAccessorMutator{slong}
@MmuxDefineArrayAccessorMutator{ulong}
@MmuxDefineArrayAccessorMutator{sllong}
@MmuxDefineArrayAccessorMutator{ullong}
@MmuxDefineArrayAccessorMutator{float}
@MmuxDefineArrayAccessorMutator{double}
@MmuxDefineArrayAccessorMutator{ldouble}

@MmuxDefineArrayAccessorMutator{float32}
@MmuxDefineArrayAccessorMutator{float64}
@MmuxDefineArrayAccessorMutator{float128}

@MmuxDefineArrayAccessorMutator{float32x}
@MmuxDefineArrayAccessorMutator{float64x}
@MmuxDefineArrayAccessorMutator{float128x}

@MmuxDefineArrayAccessorMutator{decimal32}
@MmuxDefineArrayAccessorMutator{decimal64}
@MmuxDefineArrayAccessorMutator{decimal128}

@MmuxDefineArrayAccessorMutator{complexf}
@MmuxDefineArrayAccessorMutator{complexd}
@MmuxDefineArrayAccessorMutator{complexld}

@MmuxDefineArrayAccessorMutator{complexf32}
@MmuxDefineArrayAccessorMutator{complexf64}
@MmuxDefineArrayAccessorMutator{complexf128}

@MmuxDefineArrayAccessorMutator{complexf32x}
@MmuxDefineArrayAccessorMutator{complexf64x}
@MmuxDefineArrayAccessorMutator{complexf128x}

@MmuxDefineArrayAccessorMutator{complexd32}
@MmuxDefineArrayAccessorMutator{complexd64}
@MmuxDefineArrayAccessorMutator{complexd128}

@MmuxDefineArrayAccessorMutator{sint8}
@MmuxDefineArrayAccessorMutator{uint8}
@MmuxDefineArrayAccessorMutator{sint16}
@MmuxDefineArrayAccessorMutator{uint16}
@MmuxDefineArrayAccessorMutator{sint32}
@MmuxDefineArrayAccessorMutator{uint32}
@MmuxDefineArrayAccessorMutator{sint64}
@MmuxDefineArrayAccessorMutator{uint64}

@MmuxDefineArrayAccessorMutator{ssize}
@MmuxDefineArrayAccessorMutator{usize}
@MmuxDefineArrayAccessorMutator{sintmax}
@MmuxDefineArrayAccessorMutator{uintmax}
@MmuxDefineArrayAccessorMutator{sintptr}
@MmuxDefineArrayAccessorMutator{uintptr}
@MmuxDefineArrayAccessorMutator{mode}
@MmuxDefineArrayAccessorMutator{off}
@MmuxDefineArrayAccessorMutator{pid}
@MmuxDefineArrayAccessorMutator{uid}
@MmuxDefineArrayAccessorMutator{gid}

@c page
@node memory conversions
@section Converting data to and from memory blocks


@menu
* memory conversions arrays::   Converting data to and from index arrays.
* memory conversions strings::  Converting data to and from strings.
@end menu

@c page
@node memory conversions arrays
@subsection Converting data to and from index arrays


@defun mmux-bash-pointers-array-from-memory @var{ARRY_TO} @var{PTR_FROM} @var{SIZE}
Copy byte by byte data from a memory block into a Bash index array.

The argument @var{ARRY_TO} must be a string representing the name of a Bash index array; this
function stores in this array the bytes from the memory block, starting from index zero.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a ARRY

if ! mmux_libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-array-from-memory ARRY $POINTER $SIZE
@end example
@end defun


@defun mmux-bash-pointers-memory-from-array @var{PTR_TO} @var{ARRY_FROM} @var{SIZE}
Copy byte by byte data from a Bash index array into a memory block.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the target of the copy operation.

The argument @var{ARRY_FROM} must be a string representing the name of a Bash index array; this
function reads from this array the bytes to store in the memory block, starting from index zero.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a ARRY=(1 2 3 4 5)

if ! mmux_libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-memory-from-array $POINTER ARRY $SIZE
@end example
@end defun

@c page
@node memory conversions strings
@subsection Converting data to and from strings


@defun mmux-bash-pointers-string-from-memory @var{STRINGVAR_TO} @var{PTR_FROM} @var{SIZE}
Copy byte by byte data from a memory block into a Bash string.

The argument @var{STRINGVAR_TO} must be a string representing a Bash variable name; this function
stores in this variable a string built with the bytes from the memory block, starting from index
zero.

The argument @var{PTR_FROM} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the source of the copy operation.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare STRING

if ! mmux_libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-string-from-memory STRING $POINTER $SIZE
@end example
@end defun


@defun mmux-bash-pointers-memory-from-string @var{PTR_TO} @var{STRING_FROM} @var{SIZE}
Copy byte by byte data from a Bash string into a memory block.

The argument @var{PTR_TO} must be the string representation of a pointer referencing a previously
allocated memory block; the referenced memory is the target of the copy operation.

The argument @var{STRING_FROM} must be a string; this function reads from this strings the bytes to
store in the memory block, starting from index zero.

The argument @var{SIZE} must be the string representation of an exact, positive, integer itself
representing the number of bytes to copy; it must fit the C language type @objtype{size_t}.

@example
declare POINTER
declare -i SIZE=5
declare -a STRING="12345"

if ! mmux_libc_malloc POINTER $SIZE
then exit 1
fi

mmux-bash-pointers-memory-from-string $POINTER $STRING $SIZE
@end example
@end defun

@c page
@node errors
@chapter Handling errors


@defvr {Shell Variable} ERRNO
If an error occurs in the call to a builtin that interfaces a Standard C Library function: the
builtin will set the shell variable @env{ERRNO} to the string representation of an exact integer,
itself representing a standard @code{errno} code.

@example
declare PTR ERRNO=0 SYM

mmux_libc_malloc PTR 'ciao'
mmux-bash-pointers-errno-to-string SYM $ERRNO
$SYM    @result{} EINVAL
@end example
@end defvr


@deffn Builtin mmux_libc_strerror @var{MSGVAR} @var{ERRNUM}
Store in @var{MSGVAR} the error message corresponding to @var{ERRNUM}, which must be the string
representation of an exact integer, itself representing a valid value for @code{errno}; @var{ERRNUM}
must fit the C language type @code{int}.

@example
declare MSG

if test -v mmux_libc_EINVAL
then mmux_libc_strerror MSG $mmux_libc_EINVAL
else MSG='EINVAL undefined'
fi

"$MSG"  @result{} Invalid argument
@end example
@end deffn


@defun mmux-bash-pointers-errno-to-string @var{SYMVAR} @var{ERRNUM}
Store in @var{SYMVAR} a string representation of the @code{errno} code @var{ERRNUM}.  When
successful return true, otherwise return false.

@example
declare SYM

mmux-bash-pointers-errno-to-string SYM $mmux_libc_ENOMEM
"$SYM"  @result{} ENOMEM
@end example
@end defun

@c page
@node fds
@chapter Core file descriptor operations


@deffn Builtin mmux_libc_open @var{FDVAR} @var{FILENAME} @var{FLAGS}
@deffnx Builtin mmux_libc_open @var{FDVAR} @var{FILENAME} @var{FLAGS} @var{MODE}
Interface to the standard C function @cfunc{open}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{FDVAR} must be a string representing a shell variable name; when the operation is
successful: a string representing the new file descriptor is stored in the variable.

The argument @var{FILENAME} must be a string representing the file pathname.

The argument @var{FLAGS} must be a string representing the exact integer resulting from the bitwise
OR combination of the flags supported by the standard function.

The optional argument @var{MODE} must a string representing the exact integer resulting from the
bitwise OR combination of the mode flags supported by the standard function; when not present it
defaults to @samp{0}.

@example
declare FILENAME='/path/to/name.ext'
declare -i FLAGS=$((mmux_libc_O_RDWR | mmux_libc_O_CREAT))
declare -i MODE=$((mmux_libc_S_IRUSR | mmux_libc_S_IWUSR))
declare -i FD ERRNO

if ! mmuc_libc_open FD "$FILENAME" $FLAGS $MODE
then # handle the error
fi
@end example
@end deffn


@deffn Builtin mmux_libc_close @var{FD}
Interface to the standard C function @cfunc{close}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{FD} must be the string representation of a file descriptor.
@end deffn


@deffn Builtin mmux_libc_read @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE}
Interface to the standard C function @cfunc{read}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{read} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from the file descriptor and write to memory; it must be compatible with
the type @objtype{usize}.

@example
declare -i ERRNO; # to be used in case of error
declare -i ITEM_SIZE=$mmux_sint32_SIZEOF
declare -i ITEM_COUNT=123
declare BUFFER

@{
    declare -i OCTET_SIZE=$(( ITEM_SIZE * ITEM_COUNT ))

    if ! mmux_libc_calloc BUFFER $ITEM_COUNT $ITEM_SIZE
    then # error
    fi

    @{
        declare -i DONE FD=$(gimme-an-fd)

        if ! mmux_libc_read DONE $FD $BUFFER $OCTET_SIZE
        then # error
        fi
    @}
@}

@{
    declare -a VALUES

    mmux_sint32_array_ref 'VALUES[0]' $BUFFER 0
    mmux_sint32_array_ref 'VALUES[1]' $BUFFER 1
@}
@end example
@end deffn


@deffn Builtin mmux_libc_write @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE}
Interface to the standard C function @cfunc{write}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{write} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from memory and write to the file descriptor; it must be compatible with
the type @objtype{usize}.

@example
declare -i ERRNO; # to be used in case of error
declare -i ITEM_SIZE=$mmux_sint32_SIZEOF ITEM_COUNT=123
declare BUFFER

if ! mmux_libc_calloc BUFFER $ITEM_COUNT $ITEM_SIZE
then # error
fi

@{
    mmux_sint32_array_set $BUFFER 0 '123'
    mmux_sint32_array_set $BUFFER 1 '456'
    # ...
@}

@{
    declare -i FD=$(gimme-an-fd)
    declare -i OCTET_SIZE=$(( ITEM_SIZE * ITEM_COUNT ))
    declare -i DONE

    if ! mmux_libc_write DONE $FD $BUFFER $OCTET_SIZE
    then # error
    fi
@}
@end example
@end deffn


@deffn Builtin mmux_libc_pread @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE} @var{OFFSET}
Interface to the standard C function @cfunc{pread}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{read} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from the file descriptor and write to memory; it must be compatible with
the type @objtype{usize}.

The argument @var{OFFSET} must be the string representation of an exact, non-negative, integer being
the offset from the start of the file for the read operation; it must be compatible with the type
@objtype{usize}.
@end deffn


@deffn Builtin mmux_libc_pwrite @var{DONEVAR} @var{FD} @var{BUFFER} @var{SIZE} @var{OFFSET}
Interface to the standard C function @cfunc{pwrite}.  When successful: return true; otherwise set
the shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return
false.

The argument @var{DONEVAR} must be the name of a shell variable in which the return value of
@cfunc{pwrite} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{BUFFER} must be the string representation of a pointer from which data will be
read.

The argument @var{SIZE} must be the string representation of an exact, non-negative, integer being
the number of bytes to read from memory and write to the file descriptor; it must be compatible with
the type @objtype{usize}.

The argument @var{OFFSET} must be the string representation of an exact, non-negative, integer being
the offset from the start of the file for the write operation; it must be compatible with the type
@objtype{off}.
@end deffn


@deffn Builtin mmux_libc_lseek @var{OFFVAR} @var{FD} @var{OFFSET} @var{WHENCE}
Interface to the standard C function @cfunc{lseek}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{OFFVAR} must be the name of a shell variable in which the return value of
@cfunc{lseek} will be stored.

The argument @var{FD} must be the string representation of a file descriptor.

The argument @var{OFFSET} must be the string representation of an exact, non-negative, integer being
the offset from the position selected by @var{WHENCE}; it must be compatible with the type
@objtype{off}.

The argument @var{WHENCE} must be the string representation of an exact, non-negative, integer being
one of the constants @code{mmux_libc_SEEK_SET}, @code{mmux_libc_SEEK_CUR},
@code{mmux_libc_SEEK_END}, and others if supported.

@example
declare -i RESULT_OFFSET ERRNO FD=$(gimme-an-fd)

if ! mmux_libc_lseek RESULT_OFFSET $FD 123 $mmux_libc_SEEK_CUR
then # error
fi
@end example
@end deffn


@deffn Builtin mmux_libc_dup @var{FDVAR} @var{OLD_FD}
Interface to the standard C function @cfunc{dup}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{FDVAR} must be the name of a shell variable in which the return value of
@cfunc{dup} will be stored.

The argument @var{OLD_FD} must be the string representation of a file descriptor.
@end deffn


@deffn Builtin mmux_libc_dup2 @var{RVAR} @var{OLD_FD} @var{NEW_FD}
Interface to the standard C function @cfunc{dup2}.  When successful: return true; otherwise set the
shell variable @env{ERRNO} to a string representation of the @code{errno} code, then return false.

The argument @var{rDVAR} must be the name of a shell variable in which the return value of
@cfunc{dup} will be stored.

The argument @var{OLD_FD} must be the string representation of a file descriptor.

The argument @var{NEW_FD} must be the string representation of a file descriptor.
@end deffn

@c page
@node misc
@chapter Miscellaneous features


@defun mmux_bash_pointers_builtin_p @var{NAME}
Return true if @var{NAME} is the identifier of an existing builtin; otherwise return false.  We can
use this function to test if a shell library implements a builtin whose availability depends on the
underlying platform.

For example, the package @mmux{} Bash @acronym{MPFR} implements the builtin
@code{mpfr_set_decimal128} only if the underlying platform implements the C language type
@objtype{_Decimal128} and all the involved libraries were compiled with support for such type.  So
we can do:

@example
if mmux_bash_pointers_builtin_p mpfr_set_decimal128
then # builtin implemented
else # builtin not implemented
fi
@end example
@end defun


@c page
@c ------------------------------------------------------------
@c Appendices.
@c ------------------------------------------------------------

@include gpl-3.0.texi
@include fdl-1.3.texi

@c page
@node shared library
@appendix Using the shared library


@value{PACKAGE} installs a shared library:

@center @file{libmmux-bash-pointers.so}

@noindent
and C language headers:

@center @file{libmmux-bash-pointers.h}
@center @file{libmmux-bash-pointers-config.h}

@noindent
we can write code that links to the shared library to reuse some of its facilities.  @ref{overview
linking} for details.

@menu
* shared library config::       How to configure a package to link the shared library.
* shared library version::      Version functions.
* shared library retvals::      Return values of C language functions.
* shared library typedefs::     Type definitions.
* shared library sizeof::       Type size measured in bytes.
* shared library predicates::   Type predicates for string representations.
* shared library maximum::      Type representations of maximum values.
* shared library minimum::      Type representations of minimum values.
* shared library parsers::      Parsing string representations of C language types.
* shared library sprinters::    Printing string representations of C language types.
* shared library bindings::     Binding values to variables.
* shared library errors::       Handling errors.
@end menu

@c page
@node shared library config
@appendixsec How to configure a package to link the shared library


It happens that some rare platform may not implement the C language types @objtype{signed long long
int}, @objtype{unsigned long long int} and @objtype{long double}; more platforms may not implement
the extension types @objtype{_FloatN} and @objtype{_FloatNx}, which usually are:

@example
_Float32
_Float64
_Float128
_Float32x
_Float64x
_Float128x
@end example

@noindent
even more platforms may not implement the extension types @objtype{_DecimalN}, which usually are:

@example
_Decimal32
_Decimal64
_Decimal128
@end example

@noindent
these types are supported by @value{PACKAGE}.

This package assumes that: if the real floating--point types are supported, the corresponding
complex floating--point types are also supported; so the following types are supported:

@example
_Float32 complex
_Float64 complex
_Float128 complex
_Float32x complex
_Float64x complex
_Float128x complex
@end example

This package implements complex floating--point numbers whose real and imaginary parts are
@objtype{_DecimalN} numbers through a custom data structure.

At package--configuration time: @value{PACKAGE} tries to determine if these types are supported and
it defines the following symbols in its header files.

@c ------------------------------------------------------------------------

We can use the following C preprocesso symbols with code like:

@example
#if ((defined MMUX_HAVE_CC_TYPE_LDOUBLE) && (1 == MMUX_HAVE_CC_TYPE_LDOUBLE))
...
#endif
@end example

@macro MmuxDefineCppSymbolHaveType{CPPSTEM}
@defvr {C Preprocessor Symbol} MMUX_HAVE_CC_TYPE_\CPPSTEM\
If this preprocessor symbol is defined and its use expands to @samp{1}: the corresponding C language
type is supported.
@end defvr

@end macro

@MmuxDefineCppSymbolHaveType{SLLONG}
@MmuxDefineCppSymbolHaveType{ULLONG}
@MmuxDefineCppSymbolHaveType{LDOUBLE}
@MmuxDefineCppSymbolHaveType{FLOAT32}
@MmuxDefineCppSymbolHaveType{FLOAT64}
@MmuxDefineCppSymbolHaveType{FLOAT128}
@MmuxDefineCppSymbolHaveType{FLOAT32X}
@MmuxDefineCppSymbolHaveType{FLOAT64X}
@MmuxDefineCppSymbolHaveType{FLOAT128X}
@MmuxDefineCppSymbolHaveType{DECIMAL32}
@MmuxDefineCppSymbolHaveType{DECIMAL64}
@MmuxDefineCppSymbolHaveType{DECIMAL128}
@MmuxDefineCppSymbolHaveType{COMPLEXF32}
@MmuxDefineCppSymbolHaveType{COMPLEXF64}
@MmuxDefineCppSymbolHaveType{COMPLEXF128}
@MmuxDefineCppSymbolHaveType{COMPLEXF32X}
@MmuxDefineCppSymbolHaveType{COMPLEXF64X}
@MmuxDefineCppSymbolHaveType{COMPLEXF128X}
@MmuxDefineCppSymbolHaveType{COMPLEXD32}
@MmuxDefineCppSymbolHaveType{COMPLEXD64}
@MmuxDefineCppSymbolHaveType{COMPLEXD128}

@c page
@node shared library version
@appendixsec Version functions


The installed libraries follow version numbering as established by the @gnu{} Autotools.  For an
explanation of interface numbers as managed by @gnu{} Libtool @xref{Libtool versioning, interface,
Libtool's versioning system, libtool, Shared library support for @gnu{}}.


@deftypefun {char const *} mmux_bash_pointers_version_string (void)
Return a pointer to a statically allocated @asciiz{} string representing the interface version
number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_current (void)
Return an integer representing the library interface current number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_revision (void)
Return an integer representing the library interface current revision number.
@end deftypefun


@deftypefun int mmux_bash_pointers_version_interface_age (void)
Return an integer representing the library interface current age.
@end deftypefun

@c page
@node shared library retvals
@appendixsec Return values of C language functions


@deftp {Typedef} mmux_bash_rv_t
Type of constant values used as return value by C language functions.
@end deftp


@deftypevr {Constant} mmux_bash_rv_t MMUX_SUCCESS
Return value used to signal a successful function call.
@end deftypevr


@deftypevr {Constant} mmux_bash_rv_t MMUX_FAILURE
Return value used to signal a failed function call.
@end deftypevr

@c page
@node shared library typedefs
@appendixsec Type definitions


@cindex Type stems
@cindex @code{pointer}, type stem
@cindex @code{schar}, type stem
@cindex @code{uchar}, type stem
@cindex @code{sshort}, type stem
@cindex @code{ushort}, type stem
@cindex @code{sint}, type stem
@cindex @code{uint}, type stem
@cindex @code{slong}, type stem
@cindex @code{ulong}, type stem
@cindex @code{sllong}, type stem
@cindex @code{ullong}, type stem
@cindex @code{float}, type stem
@cindex @code{double}, type stem
@cindex @code{ldouble}, type stem

@cindex @code{float32}, type stem
@cindex @code{float64}, type stem
@cindex @code{float128}, type stem

@cindex @code{float32x}, type stem
@cindex @code{float64x}, type stem
@cindex @code{float128x}, type stem

@cindex @code{decimal32}, type stem
@cindex @code{decimal64}, type stem
@cindex @code{decimal128}, type stem

@cindex @code{complexf}, type stem
@cindex @code{complexd}, type stem
@cindex @code{complexld}, type stem

@cindex @code{complexf32}, type stem
@cindex @code{complexf64}, type stem
@cindex @code{complexf128}, type stem

@cindex @code{complexf32x}, type stem
@cindex @code{complexf64x}, type stem
@cindex @code{complexf128x}, type stem

@cindex @code{complexd32}, type stem
@cindex @code{complexd64}, type stem
@cindex @code{complexd128}, type stem

@cindex @code{sint8}, type stem
@cindex @code{uint8}, type stem
@cindex @code{sint16}, type stem
@cindex @code{uint16}, type stem
@cindex @code{sint32}, type stem
@cindex @code{uint32}, type stem
@cindex @code{sint64}, type stem
@cindex @code{uint64}, type stem

@cindex @code{ssize}, type stem
@cindex @code{usize}, type stem
@cindex @code{sintmax}, type stem
@cindex @code{uintmax}, type stem
@cindex @code{sintptr}, type stem
@cindex @code{uintptr}, type stem
@cindex @code{mode}, type stem
@cindex @code{off}, type stem
@cindex @code{pid}, type stem
@cindex @code{uid}, type stem
@cindex @code{gid}, type stem
@cindex @code{wchar}, type stem
@cindex @code{wint}, type stem


The following type definitions just alias the corresponding C language type; the type name is
composed from a ``stem'': a single word representing the name of the type.  Such uniform names are
useful when using preprocessor macros to generate code.

@macro MmuxDefineCAliasTypedef{STEM,TYPE}
@deftp {Typedef} mmux_\STEM\_t
Type definition aliasing the C language type @objtype{\TYPE\}.
@end deftp

@end macro

@macro MmuxDefineCAliasTypedefPart{COMPLEXSTEM,PARTSTEM}
@deftp {Typedef} mmux_\COMPLEXSTEM\_part_t
Type definition aliasing the C language type @objtype{mmux_\PARTSTEM\_t}, representing the real and
imaginary parts type of @objtype{mmux_\COMPLEXSTEM\_t}.
@end deftp

@end macro

@c ------------------------------------------------------------------------

@MmuxDefineCAliasTypedef{pointer,void *}

@MmuxDefineCAliasTypedef{schar,signed char}
@MmuxDefineCAliasTypedef{uchar,unsigned char}
@MmuxDefineCAliasTypedef{sshort,signed short int}
@MmuxDefineCAliasTypedef{ushort,unsigned short int}
@MmuxDefineCAliasTypedef{sint,signed int}
@MmuxDefineCAliasTypedef{uint,unsigned int}
@MmuxDefineCAliasTypedef{slong,signed long}
@MmuxDefineCAliasTypedef{ulong,unsigned long}
@MmuxDefineCAliasTypedef{sllong,signed long long}
@MmuxDefineCAliasTypedef{ullong,unsigned long long}
@MmuxDefineCAliasTypedef{float,float}
@MmuxDefineCAliasTypedef{double,double}
@MmuxDefineCAliasTypedef{ldouble,long double}

@MmuxDefineCAliasTypedef{float32, _Float32}
@MmuxDefineCAliasTypedef{float64, _Float64}
@MmuxDefineCAliasTypedef{float128, _Float128}

@MmuxDefineCAliasTypedef{float32x, _Float32x}
@MmuxDefineCAliasTypedef{float64x, _Float64x}
@MmuxDefineCAliasTypedef{float128x, _Float128x}

@MmuxDefineCAliasTypedef{decimal32, _Decimal32}
@MmuxDefineCAliasTypedef{decimal64, _Decimal64}
@MmuxDefineCAliasTypedef{decimal128, _Decimal128}

@MmuxDefineCAliasTypedef{complexf,float complex}
@MmuxDefineCAliasTypedef{complexd,double complex}
@MmuxDefineCAliasTypedef{complexld,long double complex}

@MmuxDefineCAliasTypedef{complexf32, _Float32 complex}
@MmuxDefineCAliasTypedef{complexf64, _Float64 complex}
@MmuxDefineCAliasTypedef{complexf128, _Float128 complex}

@MmuxDefineCAliasTypedef{complexf32x, _Float32x complex}
@MmuxDefineCAliasTypedef{complexf64x, _Float64x complex}
@MmuxDefineCAliasTypedef{complexf128x, _Float128x complex}

@deftp {Typedef} mmux_complexd32_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_decimal32_t}.
@end deftp

@deftp {Typedef} mmux_complexd64_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_decimal64_t}.
@end deftp

@deftp {Typedef} mmux_complexd128_t
Non--standard type definition representing a complex floating--point number whose real and imaginary
parts are values of type @objtype{mmux_decimal128_t}.
@end deftp

@MmuxDefineCAliasTypedef{sint8,int8_t}
@MmuxDefineCAliasTypedef{uint8,uint8_t}
@MmuxDefineCAliasTypedef{sint16,int16_t}
@MmuxDefineCAliasTypedef{uint16,uint16_t}
@MmuxDefineCAliasTypedef{sint32,int32_t}
@MmuxDefineCAliasTypedef{uint32,uint32_t}
@MmuxDefineCAliasTypedef{sint64,int64_t}
@MmuxDefineCAliasTypedef{uint64,uint64_t}

@MmuxDefineCAliasTypedef{ssize,ssize_t}
@MmuxDefineCAliasTypedef{usize,size_t}
@MmuxDefineCAliasTypedef{sintmax, intmax_t}
@MmuxDefineCAliasTypedef{uintmax, uintmax_t}
@MmuxDefineCAliasTypedef{sintptr, intptr_t}
@MmuxDefineCAliasTypedef{uintptr, uintptr_t}
@MmuxDefineCAliasTypedef{mode, mode_t}
@MmuxDefineCAliasTypedef{off, off_t}
@MmuxDefineCAliasTypedef{pid, pid_t}
@MmuxDefineCAliasTypedef{uid, uid_t}
@MmuxDefineCAliasTypedef{gid, gid_t}
@MmuxDefineCAliasTypedef{wchar, wchar_t}
@MmuxDefineCAliasTypedef{wint, wint_t}


@MmuxDefineCAliasTypedefPart{complexf,float}
@MmuxDefineCAliasTypedefPart{complexd,double}
@MmuxDefineCAliasTypedefPart{complexld,ldouble}

@MmuxDefineCAliasTypedefPart{complexf32, float32}
@MmuxDefineCAliasTypedefPart{complexf64, float64}
@MmuxDefineCAliasTypedefPart{complexf128, float128}

@MmuxDefineCAliasTypedefPart{complexf32x, float32x}
@MmuxDefineCAliasTypedefPart{complexf64x, float64x}
@MmuxDefineCAliasTypedefPart{complexf128x, float128x}

@MmuxDefineCAliasTypedefPart{complexd32, decimal32}
@MmuxDefineCAliasTypedefPart{complexd64, decimal64}
@MmuxDefineCAliasTypedefPart{complexd128, decimal128}

@c page
@node shared library sizeof
@appendixsec Type size measured in bytes


@macro MmuxDefineCFunctionSizeof{STEM}
@deftypefun int mmux_\STEM\_sizeof (void)
Return a positive integer representing the size in bytes of the C language type
@objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSizeof{pointer}

@MmuxDefineCFunctionSizeof{schar}
@MmuxDefineCFunctionSizeof{uchar}
@MmuxDefineCFunctionSizeof{sshort}
@MmuxDefineCFunctionSizeof{ushort}
@MmuxDefineCFunctionSizeof{sint}
@MmuxDefineCFunctionSizeof{uint}
@MmuxDefineCFunctionSizeof{slong}
@MmuxDefineCFunctionSizeof{ulong}
@MmuxDefineCFunctionSizeof{sllong}
@MmuxDefineCFunctionSizeof{ullong}
@MmuxDefineCFunctionSizeof{float}
@MmuxDefineCFunctionSizeof{double}
@MmuxDefineCFunctionSizeof{ldouble}

@MmuxDefineCFunctionSizeof{float32}
@MmuxDefineCFunctionSizeof{float64}
@MmuxDefineCFunctionSizeof{float128}

@MmuxDefineCFunctionSizeof{float32x}
@MmuxDefineCFunctionSizeof{float64x}
@MmuxDefineCFunctionSizeof{float128x}

@MmuxDefineCFunctionSizeof{decimal32}
@MmuxDefineCFunctionSizeof{decimal64}
@MmuxDefineCFunctionSizeof{decimal128}

@MmuxDefineCFunctionSizeof{complexf}
@MmuxDefineCFunctionSizeof{complexd}
@MmuxDefineCFunctionSizeof{complexld}

@MmuxDefineCFunctionSizeof{complexf32}
@MmuxDefineCFunctionSizeof{complexf64}
@MmuxDefineCFunctionSizeof{complexf128}

@MmuxDefineCFunctionSizeof{complexf32x}
@MmuxDefineCFunctionSizeof{complexf64x}
@MmuxDefineCFunctionSizeof{complexf128x}

@MmuxDefineCFunctionSizeof{complexd32}
@MmuxDefineCFunctionSizeof{complexd64}
@MmuxDefineCFunctionSizeof{complexd128}

@MmuxDefineCFunctionSizeof{sint8}
@MmuxDefineCFunctionSizeof{uint8}
@MmuxDefineCFunctionSizeof{sint16}
@MmuxDefineCFunctionSizeof{uint16}
@MmuxDefineCFunctionSizeof{sint32}
@MmuxDefineCFunctionSizeof{uint32}
@MmuxDefineCFunctionSizeof{sint64}
@MmuxDefineCFunctionSizeof{uint64}

@MmuxDefineCFunctionSizeof{ssize}
@MmuxDefineCFunctionSizeof{usize}
@MmuxDefineCFunctionSizeof{sintmax}
@MmuxDefineCFunctionSizeof{uintmax}
@MmuxDefineCFunctionSizeof{sintptr}
@MmuxDefineCFunctionSizeof{uintptr}
@MmuxDefineCFunctionSizeof{mode}
@MmuxDefineCFunctionSizeof{off}
@MmuxDefineCFunctionSizeof{pid}
@MmuxDefineCFunctionSizeof{uid}
@MmuxDefineCFunctionSizeof{gid}
@MmuxDefineCFunctionSizeof{wchar}
@MmuxDefineCFunctionSizeof{wint}

@c page
@node shared library predicates
@appendixsec Type predicates for string representations


@macro MmuxDefineCFunctionPredicate{STEM}
@deftypefun bool mmux_string_is_\STEM\ (char const * @var{str})
Return @ctrue{} if @var{str} references the string representation, in @asciiz{} format, of a
value of type @objtype{mmux_\STEM\_t}; otherwise return @cfalse{}.
@end deftypefun

@end macro


@MmuxDefineCFunctionPredicate{pointer}

@MmuxDefineCFunctionPredicate{schar}
@MmuxDefineCFunctionPredicate{uchar}
@MmuxDefineCFunctionPredicate{sshort}
@MmuxDefineCFunctionPredicate{ushort}
@MmuxDefineCFunctionPredicate{sint}
@MmuxDefineCFunctionPredicate{uint}
@MmuxDefineCFunctionPredicate{slong}
@MmuxDefineCFunctionPredicate{ulong}
@MmuxDefineCFunctionPredicate{sllong}
@MmuxDefineCFunctionPredicate{ullong}
@MmuxDefineCFunctionPredicate{float}
@MmuxDefineCFunctionPredicate{double}
@MmuxDefineCFunctionPredicate{ldouble}

@MmuxDefineCFunctionPredicate{float32}
@MmuxDefineCFunctionPredicate{float64}
@MmuxDefineCFunctionPredicate{float128}

@MmuxDefineCFunctionPredicate{float32x}
@MmuxDefineCFunctionPredicate{float64x}
@MmuxDefineCFunctionPredicate{float128x}

@MmuxDefineCFunctionPredicate{decimal32}
@MmuxDefineCFunctionPredicate{decimal64}
@MmuxDefineCFunctionPredicate{decimal128}

@MmuxDefineCFunctionPredicate{complexf}
@MmuxDefineCFunctionPredicate{complexd}
@MmuxDefineCFunctionPredicate{complexld}

@MmuxDefineCFunctionPredicate{complexf32}
@MmuxDefineCFunctionPredicate{complexf64}
@MmuxDefineCFunctionPredicate{complexf128}

@MmuxDefineCFunctionPredicate{complexf32x}
@MmuxDefineCFunctionPredicate{complexf64x}
@MmuxDefineCFunctionPredicate{complexf128x}

@MmuxDefineCFunctionPredicate{complexd32}
@MmuxDefineCFunctionPredicate{complexd64}
@MmuxDefineCFunctionPredicate{complexd128}

@MmuxDefineCFunctionPredicate{sint8}
@MmuxDefineCFunctionPredicate{uint8}
@MmuxDefineCFunctionPredicate{sint16}
@MmuxDefineCFunctionPredicate{uint16}
@MmuxDefineCFunctionPredicate{sint32}
@MmuxDefineCFunctionPredicate{uint32}
@MmuxDefineCFunctionPredicate{sint64}
@MmuxDefineCFunctionPredicate{uint64}

@MmuxDefineCFunctionPredicate{ssize}
@MmuxDefineCFunctionPredicate{usize}
@MmuxDefineCFunctionPredicate{sintmax}
@MmuxDefineCFunctionPredicate{uintmax}
@MmuxDefineCFunctionPredicate{sintptr}
@MmuxDefineCFunctionPredicate{uintptr}
@MmuxDefineCFunctionPredicate{mode}
@MmuxDefineCFunctionPredicate{off}
@MmuxDefineCFunctionPredicate{pid}
@MmuxDefineCFunctionPredicate{uid}
@MmuxDefineCFunctionPredicate{gid}
@MmuxDefineCFunctionPredicate{wchar}
@MmuxDefineCFunctionPredicate{wint}

@c page
@node shared library maximum
@appendixsec Type representations of maximum values


@macro MmuxDefineCFunctionMaximum{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_maximum (void)
Return the maximum value representable by the range of values of the type @objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionMaximum{pointer}

@MmuxDefineCFunctionMaximum{schar}
@MmuxDefineCFunctionMaximum{uchar}
@MmuxDefineCFunctionMaximum{sshort}
@MmuxDefineCFunctionMaximum{ushort}
@MmuxDefineCFunctionMaximum{sint}
@MmuxDefineCFunctionMaximum{uint}
@MmuxDefineCFunctionMaximum{slong}
@MmuxDefineCFunctionMaximum{ulong}
@MmuxDefineCFunctionMaximum{sllong}
@MmuxDefineCFunctionMaximum{ullong}
@MmuxDefineCFunctionMaximum{float}
@MmuxDefineCFunctionMaximum{double}
@MmuxDefineCFunctionMaximum{ldouble}

@MmuxDefineCFunctionMaximum{float32}
@MmuxDefineCFunctionMaximum{float64}
@MmuxDefineCFunctionMaximum{float128}

@MmuxDefineCFunctionMaximum{float32x}
@MmuxDefineCFunctionMaximum{float64x}
@MmuxDefineCFunctionMaximum{float128x}

@MmuxDefineCFunctionMaximum{decimal32}
@MmuxDefineCFunctionMaximum{decimal64}
@MmuxDefineCFunctionMaximum{decimal128}

@MmuxDefineCFunctionMaximum{sint8}
@MmuxDefineCFunctionMaximum{uint8}
@MmuxDefineCFunctionMaximum{sint16}
@MmuxDefineCFunctionMaximum{uint16}
@MmuxDefineCFunctionMaximum{sint32}
@MmuxDefineCFunctionMaximum{uint32}
@MmuxDefineCFunctionMaximum{sint64}
@MmuxDefineCFunctionMaximum{uint64}

@MmuxDefineCFunctionMaximum{ssize}
@MmuxDefineCFunctionMaximum{usize}
@MmuxDefineCFunctionMaximum{sintmax}
@MmuxDefineCFunctionMaximum{uintmax}
@MmuxDefineCFunctionMaximum{sintptr}
@MmuxDefineCFunctionMaximum{uintptr}
@MmuxDefineCFunctionMaximum{mode}
@MmuxDefineCFunctionMaximum{off}
@MmuxDefineCFunctionMaximum{pid}
@MmuxDefineCFunctionMaximum{uid}
@MmuxDefineCFunctionMaximum{gid}
@MmuxDefineCFunctionMaximum{wchar}
@MmuxDefineCFunctionMaximum{wint}

@c page
@node shared library minimum
@appendixsec Type representations of minimum values


The following functions return the minimum value representable by a C language real number type;
this is true even for floating--point numbers: the returned value is the minimum negative
representable value.  This is different from the standard C language constants like @code{FLT_MIN},
@code{DBL_MIN}, @code{LDBL_MIN}, which represent some sort of minimum representable positive value.


@macro MmuxDefineCFunctionMinimum{STEM}
@deftypefun mmux_\STEM\_t mmux_\STEM\_minimum (void)
Return the minimum value representable by the range of values of the type
@objtype{mmux_\STEM\_t}.
@end deftypefun

@end macro


@MmuxDefineCFunctionMinimum{pointer}

@MmuxDefineCFunctionMinimum{schar}
@MmuxDefineCFunctionMinimum{uchar}
@MmuxDefineCFunctionMinimum{sshort}
@MmuxDefineCFunctionMinimum{ushort}
@MmuxDefineCFunctionMinimum{sint}
@MmuxDefineCFunctionMinimum{uint}
@MmuxDefineCFunctionMinimum{slong}
@MmuxDefineCFunctionMinimum{ulong}
@MmuxDefineCFunctionMinimum{sllong}
@MmuxDefineCFunctionMinimum{ullong}
@MmuxDefineCFunctionMinimum{float}
@MmuxDefineCFunctionMinimum{double}
@MmuxDefineCFunctionMinimum{ldouble}

@MmuxDefineCFunctionMinimum{float32}
@MmuxDefineCFunctionMinimum{float64}
@MmuxDefineCFunctionMinimum{float128}

@MmuxDefineCFunctionMinimum{float32x}
@MmuxDefineCFunctionMinimum{float64x}
@MmuxDefineCFunctionMinimum{float128x}

@MmuxDefineCFunctionMinimum{decimal32}
@MmuxDefineCFunctionMinimum{decimal64}
@MmuxDefineCFunctionMinimum{decimal128}

@MmuxDefineCFunctionMinimum{sint8}
@MmuxDefineCFunctionMinimum{uint8}
@MmuxDefineCFunctionMinimum{sint16}
@MmuxDefineCFunctionMinimum{uint16}
@MmuxDefineCFunctionMinimum{sint32}
@MmuxDefineCFunctionMinimum{uint32}
@MmuxDefineCFunctionMinimum{sint64}
@MmuxDefineCFunctionMinimum{uint64}

@MmuxDefineCFunctionMinimum{ssize}
@MmuxDefineCFunctionMinimum{usize}
@MmuxDefineCFunctionMinimum{sintmax}
@MmuxDefineCFunctionMinimum{uintmax}
@MmuxDefineCFunctionMinimum{sintptr}
@MmuxDefineCFunctionMinimum{uintptr}
@MmuxDefineCFunctionMinimum{mode}
@MmuxDefineCFunctionMinimum{off}
@MmuxDefineCFunctionMinimum{pid}
@MmuxDefineCFunctionMinimum{uid}
@MmuxDefineCFunctionMinimum{gid}
@MmuxDefineCFunctionMinimum{wchar}
@MmuxDefineCFunctionMinimum{wint}

@c page
@node shared library parsers
@appendixsec Parsing string representations of C language types


Type parsers convert string representations to C language values; to parse a @code{mmuc_libc_sint_t}
representation we do:

@example
char const *            arg = "123";
mmux_sint_t        value;
int                     rv;

rv = mmux_sint_parse(&value, arg, "my-builtin");
@end example


@macro MmuxDefineCFunctionParser{STEM}
@deftypefun mmux_bash_rv_t mmux_\STEM\_parse (mmux_\STEM\_t * @var{PTR}, char const * @var{STR}, char const * @var{CALLER_NAME})
Parse a string which is meant to be the representation of a C language type @objtype{\STEM\}; when
successful store the result in the variable referenced by @var{PTR}, then return
@code{MMUX_SUCCESS}; otherwise leave @var{PTR} untouched and return @code{MMUX_FAILURE}.

In case of failure: if @var{CALLER_NAME} is not @cnull{}, print on @stderr{} a message describing
the parsing error; @var{CALLER_NAME} must reference an @asciiz{} string representing the entity that
requested the parsing operation, for example: the name of a builtin.
@end deftypefun

@end macro


@MmuxDefineCFunctionParser{pointer}

@MmuxDefineCFunctionParser{schar}
@MmuxDefineCFunctionParser{uchar}
@MmuxDefineCFunctionParser{sshort}
@MmuxDefineCFunctionParser{ushort}
@MmuxDefineCFunctionParser{sint}
@MmuxDefineCFunctionParser{uint}
@MmuxDefineCFunctionParser{slong}
@MmuxDefineCFunctionParser{ulong}
@MmuxDefineCFunctionParser{sllong}
@MmuxDefineCFunctionParser{ullong}
@MmuxDefineCFunctionParser{float}
@MmuxDefineCFunctionParser{double}
@MmuxDefineCFunctionParser{ldouble}

@MmuxDefineCFunctionParser{float32}
@MmuxDefineCFunctionParser{float64}
@MmuxDefineCFunctionParser{float128}

@MmuxDefineCFunctionParser{float32x}
@MmuxDefineCFunctionParser{float64x}
@MmuxDefineCFunctionParser{float128x}

@MmuxDefineCFunctionParser{decimal32}
@MmuxDefineCFunctionParser{decimal64}
@MmuxDefineCFunctionParser{decimal128}

@MmuxDefineCFunctionParser{complexf}
@MmuxDefineCFunctionParser{complexd}
@MmuxDefineCFunctionParser{complexld}

@MmuxDefineCFunctionParser{complexf32}
@MmuxDefineCFunctionParser{complexf64}
@MmuxDefineCFunctionParser{complexf128}

@MmuxDefineCFunctionParser{complexf32x}
@MmuxDefineCFunctionParser{complexf64x}
@MmuxDefineCFunctionParser{complexf128x}

@MmuxDefineCFunctionParser{complexd32}
@MmuxDefineCFunctionParser{complexd64}
@MmuxDefineCFunctionParser{complexd128}

@MmuxDefineCFunctionParser{sint8}
@MmuxDefineCFunctionParser{uint8}
@MmuxDefineCFunctionParser{sint16}
@MmuxDefineCFunctionParser{uint16}
@MmuxDefineCFunctionParser{sint32}
@MmuxDefineCFunctionParser{uint32}
@MmuxDefineCFunctionParser{sint64}
@MmuxDefineCFunctionParser{uint64}

@MmuxDefineCFunctionParser{ssize}
@MmuxDefineCFunctionParser{usize}
@MmuxDefineCFunctionParser{sintmax}
@MmuxDefineCFunctionParser{uintmax}
@MmuxDefineCFunctionParser{sintptr}
@MmuxDefineCFunctionParser{uintptr}
@MmuxDefineCFunctionParser{mode}
@MmuxDefineCFunctionParser{off}
@MmuxDefineCFunctionParser{pid}
@MmuxDefineCFunctionParser{uid}
@MmuxDefineCFunctionParser{gid}
@MmuxDefineCFunctionParser{wchar}
@MmuxDefineCFunctionParser{wint}

@c page
@node shared library sprinters
@appendixsec Printing string representations of C language types


Type string printers convert binary representations of C language values to string representations;
to print a @objtype{mmux_sint_t} string representation we do:

@example
mmux_sint_t     value = 123;
int             required_nbytes;

required_nbytes = mmux_sint_sprint_size(value);
if (0 > required_nbytes) @{
  /* error */
@} else @{
  char    str[required_nbytes];
  int     rv;

  rv = mmux_sint_sprint(str, required_nbytes, value);
@}
@end example


@macro MmuxDefineCFunctionSprinter{STEM}
@deftypefun mmux_bash_rv_t mmux_\STEM\_sprint (char * @var{STRPTR}, int @var{LEN}, mmux_\STEM\_t @var{VALUE})
@deftypefunx int mmux_\STEM\_sprint_size (mmux_\STEM\_t @var{VALUE})
The @samp{sprint} function generates a string representation of @var{VALUE} and stores it, in
@asciiz{} format, in the string referenced by @var{STRPTR}, which can hold at most @var{LEN}
characters (terminating zero included).  When successful return @code{MMUX_SUCCESS}; otherwise
leave @var{STRPTR} untouched and return @code{MMUX_FAILURE}.

The @samp{sprint_size} function computes how many characters are needed to hold the string
representation of @var{VALUE}.  When successful returns the number of characters, @strong{including
the terminating zero}; otherwise return @samp{-1}.
@end deftypefun

@end macro


@MmuxDefineCFunctionSprinter{pointer}

@MmuxDefineCFunctionSprinter{schar}
@MmuxDefineCFunctionSprinter{uchar}
@MmuxDefineCFunctionSprinter{sshort}
@MmuxDefineCFunctionSprinter{ushort}
@MmuxDefineCFunctionSprinter{sint}
@MmuxDefineCFunctionSprinter{uint}
@MmuxDefineCFunctionSprinter{slong}
@MmuxDefineCFunctionSprinter{ulong}
@MmuxDefineCFunctionSprinter{sllong}
@MmuxDefineCFunctionSprinter{ullong}
@MmuxDefineCFunctionSprinter{float}
@MmuxDefineCFunctionSprinter{double}
@MmuxDefineCFunctionSprinter{ldouble}

@MmuxDefineCFunctionSprinter{float32}
@MmuxDefineCFunctionSprinter{float64}
@MmuxDefineCFunctionSprinter{float128}

@MmuxDefineCFunctionSprinter{float32x}
@MmuxDefineCFunctionSprinter{float64x}
@MmuxDefineCFunctionSprinter{float128x}

@MmuxDefineCFunctionSprinter{decimal32}
@MmuxDefineCFunctionSprinter{decimal64}
@MmuxDefineCFunctionSprinter{decimal128}

@MmuxDefineCFunctionSprinter{complexf}
@MmuxDefineCFunctionSprinter{complexd}
@MmuxDefineCFunctionSprinter{complexld}

@MmuxDefineCFunctionSprinter{complexf32}
@MmuxDefineCFunctionSprinter{complexf64}
@MmuxDefineCFunctionSprinter{complexf128}

@MmuxDefineCFunctionSprinter{complexf32x}
@MmuxDefineCFunctionSprinter{complexf64x}
@MmuxDefineCFunctionSprinter{complexf128x}

@MmuxDefineCFunctionSprinter{complexd32}
@MmuxDefineCFunctionSprinter{complexd64}
@MmuxDefineCFunctionSprinter{complexd128}

@MmuxDefineCFunctionSprinter{sint8}
@MmuxDefineCFunctionSprinter{uint8}
@MmuxDefineCFunctionSprinter{sint16}
@MmuxDefineCFunctionSprinter{uint16}
@MmuxDefineCFunctionSprinter{sint32}
@MmuxDefineCFunctionSprinter{uint32}
@MmuxDefineCFunctionSprinter{sint64}
@MmuxDefineCFunctionSprinter{uint64}

@MmuxDefineCFunctionSprinter{ssize}
@MmuxDefineCFunctionSprinter{usize}
@MmuxDefineCFunctionSprinter{sintmax}
@MmuxDefineCFunctionSprinter{uintmax}
@MmuxDefineCFunctionSprinter{sintptr}
@MmuxDefineCFunctionSprinter{uintptr}
@MmuxDefineCFunctionSprinter{mode}
@MmuxDefineCFunctionSprinter{off}
@MmuxDefineCFunctionSprinter{pid}
@MmuxDefineCFunctionSprinter{uid}
@MmuxDefineCFunctionSprinter{gid}
@MmuxDefineCFunctionSprinter{wchar}
@MmuxDefineCFunctionSprinter{wint}

@c page
@node shared library bindings
@appendixsec Binding values to variables


@macro MmuxDefineCFunctionBindToVariable{STEM}
@deftypefun mmux_bash_rv_t mmux_\STEM\_bind_to_variable (char const * @var{variable_name}, mmux_\STEM\_t @var{value}, char const * @var{who})
Assign @var{value} to the shell @var{variable_name}.  When successful return @code{MMUX_SUCCESS};
otherwise return @code{MMUX_FAILURE}.

When @var{who} is not @cnull{} and an error occurs: an error message is printed on @stderr{}, and
@var{who} is used as ``subject'' that signalled the error.  @var{who} is usually the name of a
builtin.
@end deftypefun

@end macro


@MmuxDefineCFunctionBindToVariable{pointer}

@MmuxDefineCFunctionBindToVariable{schar}
@MmuxDefineCFunctionBindToVariable{uchar}
@MmuxDefineCFunctionBindToVariable{sshort}
@MmuxDefineCFunctionBindToVariable{ushort}
@MmuxDefineCFunctionBindToVariable{sint}
@MmuxDefineCFunctionBindToVariable{uint}
@MmuxDefineCFunctionBindToVariable{slong}
@MmuxDefineCFunctionBindToVariable{ulong}
@MmuxDefineCFunctionBindToVariable{sllong}
@MmuxDefineCFunctionBindToVariable{ullong}
@MmuxDefineCFunctionBindToVariable{float}
@MmuxDefineCFunctionBindToVariable{double}
@MmuxDefineCFunctionBindToVariable{ldouble}

@MmuxDefineCFunctionBindToVariable{float32}
@MmuxDefineCFunctionBindToVariable{float64}
@MmuxDefineCFunctionBindToVariable{float128}

@MmuxDefineCFunctionBindToVariable{float32x}
@MmuxDefineCFunctionBindToVariable{float64x}
@MmuxDefineCFunctionBindToVariable{float128x}

@MmuxDefineCFunctionBindToVariable{decimal32}
@MmuxDefineCFunctionBindToVariable{decimal64}
@MmuxDefineCFunctionBindToVariable{decimal128}

@MmuxDefineCFunctionBindToVariable{complexf}
@MmuxDefineCFunctionBindToVariable{complexd}
@MmuxDefineCFunctionBindToVariable{complexld}

@MmuxDefineCFunctionBindToVariable{complexf32}
@MmuxDefineCFunctionBindToVariable{complexf64}
@MmuxDefineCFunctionBindToVariable{complexf128}

@MmuxDefineCFunctionBindToVariable{complexf32x}
@MmuxDefineCFunctionBindToVariable{complexf64x}
@MmuxDefineCFunctionBindToVariable{complexf128x}

@MmuxDefineCFunctionBindToVariable{complexd32}
@MmuxDefineCFunctionBindToVariable{complexd64}
@MmuxDefineCFunctionBindToVariable{complexd128}

@MmuxDefineCFunctionBindToVariable{sint8}
@MmuxDefineCFunctionBindToVariable{uint8}
@MmuxDefineCFunctionBindToVariable{sint16}
@MmuxDefineCFunctionBindToVariable{uint16}
@MmuxDefineCFunctionBindToVariable{sint32}
@MmuxDefineCFunctionBindToVariable{uint32}
@MmuxDefineCFunctionBindToVariable{sint64}
@MmuxDefineCFunctionBindToVariable{uint64}

@MmuxDefineCFunctionBindToVariable{ssize}
@MmuxDefineCFunctionBindToVariable{usize}
@MmuxDefineCFunctionBindToVariable{sintmax}
@MmuxDefineCFunctionBindToVariable{uintmax}
@MmuxDefineCFunctionBindToVariable{sintptr}
@MmuxDefineCFunctionBindToVariable{uintptr}
@MmuxDefineCFunctionBindToVariable{mode}
@MmuxDefineCFunctionBindToVariable{off}
@MmuxDefineCFunctionBindToVariable{pid}
@MmuxDefineCFunctionBindToVariable{uid}
@MmuxDefineCFunctionBindToVariable{gid}
@MmuxDefineCFunctionBindToVariable{wchar}
@MmuxDefineCFunctionBindToVariable{wint}

@c page
@node shared library errors
@appendixsec Handling errors


@deftypefun mmux_bash_rv_t mmux_bash_pointers_set_ERRNO (int @var{errnum}, char const * @var{who})
Set the shell variable @env{ERRNO} to a string representation of @var{errnum}.  When successful
return @samp{MMUX_SUCCESS}, otherwise return @samp{MMUX_FAILURE}.

If an error occurs and @var{who} is not @cnull{}: print an error message to @stderr{}.
@end deftypefun


@deftypefun mmux_bash_rv_t mmux_bash_pointers_consume_errno (char const * @var{who})
Call @cfunc{mmux_bash_pointers_set_ERRNO} to deal with the current value of the standard
@code{errno}; the set @code{errno} itself to zero.  When successful return @samp{MMUX_SUCCESS},
otherwise return @samp{MMUX_FAILURE}.

If an error occurs and @var{who} is not @cnull{}: print an error message to @stderr{}.
@end deftypefun

@c page
@node references
@appendix Bibliography and references


The documentation of @value{PACKAGE} is available online:

@center @value{DocumentationUrl}

@noindent
development takes place at:

@center @value{GithubUrl}

@noindent
the package @mbfl{} is available online:

@center @url{http://github.com/marcomaggi/mbfl/}

the package @code{libdfp} is available online:

@center @url{https://github.com/libdfp/libdfp}

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file

